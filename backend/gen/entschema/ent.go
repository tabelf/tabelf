// Code generated by entc, DO NOT EDIT.

package entschema

import (
	"errors"
	"fmt"
	"tabelf/backend/gen/entschema/account"
	"tabelf/backend/gen/entschema/admin"
	"tabelf/backend/gen/entschema/collaboration"
	"tabelf/backend/gen/entschema/community"
	"tabelf/backend/gen/entschema/communitycategory"
	"tabelf/backend/gen/entschema/communitymeta"
	"tabelf/backend/gen/entschema/feedback"
	"tabelf/backend/gen/entschema/focus"
	"tabelf/backend/gen/entschema/goodarticle"
	"tabelf/backend/gen/entschema/goodarticlecategory"
	"tabelf/backend/gen/entschema/goodarticlehot"
	"tabelf/backend/gen/entschema/goodarticlemeta"
	"tabelf/backend/gen/entschema/invite"
	"tabelf/backend/gen/entschema/message"
	"tabelf/backend/gen/entschema/notice"
	"tabelf/backend/gen/entschema/payorder"
	"tabelf/backend/gen/entschema/payorderfeedback"
	"tabelf/backend/gen/entschema/personalfolder"
	"tabelf/backend/gen/entschema/recharge"
	"tabelf/backend/gen/entschema/sharelink"
	"tabelf/backend/gen/entschema/station"
	"tabelf/backend/gen/entschema/stationcategory"
	"tabelf/backend/gen/entschema/stationmeta"
	"tabelf/backend/gen/entschema/team"
	"tabelf/backend/gen/entschema/teamfolder"
	"tabelf/backend/gen/entschema/teamgroup"
	"tabelf/backend/gen/entschema/urlcrawl"
	"tabelf/backend/gen/entschema/weblink"
	"tabelf/backend/gen/entschema/workspace"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

// ent aliases to avoid import conflicts in user's code.
type (
	Op         = ent.Op
	Hook       = ent.Hook
	Value      = ent.Value
	Query      = ent.Query
	Policy     = ent.Policy
	Mutator    = ent.Mutator
	Mutation   = ent.Mutation
	MutateFunc = ent.MutateFunc
)

// OrderFunc applies an ordering on the sql selector.
type OrderFunc func(*sql.Selector)

// columnChecker returns a function indicates if the column exists in the given column.
func columnChecker(table string) func(string) error {
	checks := map[string]func(string) bool{
		account.Table:             account.ValidColumn,
		admin.Table:               admin.ValidColumn,
		collaboration.Table:       collaboration.ValidColumn,
		community.Table:           community.ValidColumn,
		communitycategory.Table:   communitycategory.ValidColumn,
		communitymeta.Table:       communitymeta.ValidColumn,
		feedback.Table:            feedback.ValidColumn,
		focus.Table:               focus.ValidColumn,
		goodarticle.Table:         goodarticle.ValidColumn,
		goodarticlecategory.Table: goodarticlecategory.ValidColumn,
		goodarticlehot.Table:      goodarticlehot.ValidColumn,
		goodarticlemeta.Table:     goodarticlemeta.ValidColumn,
		invite.Table:              invite.ValidColumn,
		message.Table:             message.ValidColumn,
		notice.Table:              notice.ValidColumn,
		payorder.Table:            payorder.ValidColumn,
		payorderfeedback.Table:    payorderfeedback.ValidColumn,
		personalfolder.Table:      personalfolder.ValidColumn,
		recharge.Table:            recharge.ValidColumn,
		sharelink.Table:           sharelink.ValidColumn,
		station.Table:             station.ValidColumn,
		stationcategory.Table:     stationcategory.ValidColumn,
		stationmeta.Table:         stationmeta.ValidColumn,
		team.Table:                team.ValidColumn,
		teamfolder.Table:          teamfolder.ValidColumn,
		teamgroup.Table:           teamgroup.ValidColumn,
		urlcrawl.Table:            urlcrawl.ValidColumn,
		weblink.Table:             weblink.ValidColumn,
		workspace.Table:           workspace.ValidColumn,
	}
	check, ok := checks[table]
	if !ok {
		return func(string) error {
			return fmt.Errorf("unknown table %q", table)
		}
	}
	return func(column string) error {
		if !check(column) {
			return fmt.Errorf("unknown column %q for table %q", column, table)
		}
		return nil
	}
}

// Asc applies the given fields in ASC order.
func Asc(fields ...string) OrderFunc {
	return func(s *sql.Selector) {
		check := columnChecker(s.TableName())
		for _, f := range fields {
			if err := check(f); err != nil {
				s.AddError(&ValidationError{Name: f, err: fmt.Errorf("entschema: %w", err)})
			}
			s.OrderBy(sql.Asc(s.C(f)))
		}
	}
}

// Desc applies the given fields in DESC order.
func Desc(fields ...string) OrderFunc {
	return func(s *sql.Selector) {
		check := columnChecker(s.TableName())
		for _, f := range fields {
			if err := check(f); err != nil {
				s.AddError(&ValidationError{Name: f, err: fmt.Errorf("entschema: %w", err)})
			}
			s.OrderBy(sql.Desc(s.C(f)))
		}
	}
}

// AggregateFunc applies an aggregation step on the group-by traversal/selector.
type AggregateFunc func(*sql.Selector) string

// As is a pseudo aggregation function for renaming another other functions with custom names. For example:
//
//	GroupBy(field1, field2).
//	Aggregate(entschema.As(entschema.Sum(field1), "sum_field1"), (entschema.As(entschema.Sum(field2), "sum_field2")).
//	Scan(ctx, &v)
//
func As(fn AggregateFunc, end string) AggregateFunc {
	return func(s *sql.Selector) string {
		return sql.As(fn(s), end)
	}
}

// Count applies the "count" aggregation function on each group.
func Count() AggregateFunc {
	return func(s *sql.Selector) string {
		return sql.Count("*")
	}
}

// Max applies the "max" aggregation function on the given field of each group.
func Max(field string) AggregateFunc {
	return func(s *sql.Selector) string {
		check := columnChecker(s.TableName())
		if err := check(field); err != nil {
			s.AddError(&ValidationError{Name: field, err: fmt.Errorf("entschema: %w", err)})
			return ""
		}
		return sql.Max(s.C(field))
	}
}

// Mean applies the "mean" aggregation function on the given field of each group.
func Mean(field string) AggregateFunc {
	return func(s *sql.Selector) string {
		check := columnChecker(s.TableName())
		if err := check(field); err != nil {
			s.AddError(&ValidationError{Name: field, err: fmt.Errorf("entschema: %w", err)})
			return ""
		}
		return sql.Avg(s.C(field))
	}
}

// Min applies the "min" aggregation function on the given field of each group.
func Min(field string) AggregateFunc {
	return func(s *sql.Selector) string {
		check := columnChecker(s.TableName())
		if err := check(field); err != nil {
			s.AddError(&ValidationError{Name: field, err: fmt.Errorf("entschema: %w", err)})
			return ""
		}
		return sql.Min(s.C(field))
	}
}

// Sum applies the "sum" aggregation function on the given field of each group.
func Sum(field string) AggregateFunc {
	return func(s *sql.Selector) string {
		check := columnChecker(s.TableName())
		if err := check(field); err != nil {
			s.AddError(&ValidationError{Name: field, err: fmt.Errorf("entschema: %w", err)})
			return ""
		}
		return sql.Sum(s.C(field))
	}
}

// ValidationError returns when validating a field or edge fails.
type ValidationError struct {
	Name string // Field or edge name.
	err  error
}

// Error implements the error interface.
func (e *ValidationError) Error() string {
	return e.err.Error()
}

// Unwrap implements the errors.Wrapper interface.
func (e *ValidationError) Unwrap() error {
	return e.err
}

// IsValidationError returns a boolean indicating whether the error is a validation error.
func IsValidationError(err error) bool {
	if err == nil {
		return false
	}
	var e *ValidationError
	return errors.As(err, &e)
}

// NotFoundError returns when trying to fetch a specific entity and it was not found in the database.
type NotFoundError struct {
	label string
}

// Error implements the error interface.
func (e *NotFoundError) Error() string {
	return "entschema: " + e.label + " not found"
}

// IsNotFound returns a boolean indicating whether the error is a not found error.
func IsNotFound(err error) bool {
	if err == nil {
		return false
	}
	var e *NotFoundError
	return errors.As(err, &e)
}

// MaskNotFound masks not found error.
func MaskNotFound(err error) error {
	if IsNotFound(err) {
		return nil
	}
	return err
}

// NotSingularError returns when trying to fetch a singular entity and more then one was found in the database.
type NotSingularError struct {
	label string
}

// Error implements the error interface.
func (e *NotSingularError) Error() string {
	return "entschema: " + e.label + " not singular"
}

// IsNotSingular returns a boolean indicating whether the error is a not singular error.
func IsNotSingular(err error) bool {
	if err == nil {
		return false
	}
	var e *NotSingularError
	return errors.As(err, &e)
}

// NotLoadedError returns when trying to get a node that was not loaded by the query.
type NotLoadedError struct {
	edge string
}

// Error implements the error interface.
func (e *NotLoadedError) Error() string {
	return "entschema: " + e.edge + " edge was not loaded"
}

// IsNotLoaded returns a boolean indicating whether the error is a not loaded error.
func IsNotLoaded(err error) bool {
	if err == nil {
		return false
	}
	var e *NotLoadedError
	return errors.As(err, &e)
}

// ConstraintError returns when trying to create/update one or more entities and
// one or more of their constraints failed. For example, violation of edge or
// field uniqueness.
type ConstraintError struct {
	msg  string
	wrap error
}

// Error implements the error interface.
func (e ConstraintError) Error() string {
	return "entschema: constraint failed: " + e.msg
}

// Unwrap implements the errors.Wrapper interface.
func (e *ConstraintError) Unwrap() error {
	return e.wrap
}

// IsConstraintError returns a boolean indicating whether the error is a constraint failure.
func IsConstraintError(err error) bool {
	if err == nil {
		return false
	}
	var e *ConstraintError
	return errors.As(err, &e)
}
