// Code generated by entc, DO NOT EDIT.

package entschema

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"tabelf/backend/gen/entschema/account"
	"tabelf/backend/gen/entschema/admin"
	"tabelf/backend/gen/entschema/collaboration"
	"tabelf/backend/gen/entschema/community"
	"tabelf/backend/gen/entschema/communitycategory"
	"tabelf/backend/gen/entschema/communitymeta"
	"tabelf/backend/gen/entschema/feedback"
	"tabelf/backend/gen/entschema/focus"
	"tabelf/backend/gen/entschema/goodarticle"
	"tabelf/backend/gen/entschema/goodarticlecategory"
	"tabelf/backend/gen/entschema/goodarticlehot"
	"tabelf/backend/gen/entschema/goodarticlemeta"
	"tabelf/backend/gen/entschema/invite"
	"tabelf/backend/gen/entschema/message"
	"tabelf/backend/gen/entschema/notice"
	"tabelf/backend/gen/entschema/payorder"
	"tabelf/backend/gen/entschema/payorderfeedback"
	"tabelf/backend/gen/entschema/personalfolder"
	"tabelf/backend/gen/entschema/predicate"
	"tabelf/backend/gen/entschema/recharge"
	"tabelf/backend/gen/entschema/sharelink"
	"tabelf/backend/gen/entschema/station"
	"tabelf/backend/gen/entschema/stationcategory"
	"tabelf/backend/gen/entschema/stationmeta"
	"tabelf/backend/gen/entschema/team"
	"tabelf/backend/gen/entschema/teamfolder"
	"tabelf/backend/gen/entschema/teamgroup"
	"tabelf/backend/gen/entschema/urlcrawl"
	"tabelf/backend/gen/entschema/weblink"
	"tabelf/backend/gen/entschema/workspace"
	"tabelf/backend/spec/schema"
	"time"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccount             = "Account"
	TypeAdmin               = "Admin"
	TypeCollaboration       = "Collaboration"
	TypeCommunity           = "Community"
	TypeCommunityCategory   = "CommunityCategory"
	TypeCommunityMeta       = "CommunityMeta"
	TypeFeedback            = "Feedback"
	TypeFocus               = "Focus"
	TypeGoodArticle         = "GoodArticle"
	TypeGoodArticleCategory = "GoodArticleCategory"
	TypeGoodArticleHot      = "GoodArticleHot"
	TypeGoodArticleMeta     = "GoodArticleMeta"
	TypeInvite              = "Invite"
	TypeMessage             = "Message"
	TypeNotice              = "Notice"
	TypePayOrder            = "PayOrder"
	TypePayOrderFeedback    = "PayOrderFeedback"
	TypePersonalFolder      = "PersonalFolder"
	TypeRecharge            = "Recharge"
	TypeShareLink           = "ShareLink"
	TypeStation             = "Station"
	TypeStationCategory     = "StationCategory"
	TypeStationMeta         = "StationMeta"
	TypeTeam                = "Team"
	TypeTeamFolder          = "TeamFolder"
	TypeTeamGroup           = "TeamGroup"
	TypeUrlCrawl            = "UrlCrawl"
	TypeWebLink             = "WebLink"
	TypeWorkspace           = "Workspace"
)

// AccountMutation represents an operation that mutates the Account nodes in the graph.
type AccountMutation struct {
	config
	op             Op
	typ            string
	id             *uint64
	uid            *string
	created_at     *time.Time
	updated_at     *time.Time
	deactivated_at *time.Time
	phone          *string
	email          *string
	nickname       *string
	sex            *int
	addsex         *int
	password       *string
	wx_openid      *string
	image          *string
	industry       *string
	description    *string
	address        *schema.Address
	auth_code      *string
	auth_expired   *time.Time
	url_count      *int
	addurl_count   *int
	url_limit      *int
	addurl_limit   *int
	member_type    *string
	member_expired *time.Time
	has_entire     *bool
	has_new        *bool
	has_admin      *bool
	fans           *int
	addfans        *int
	focus          *int
	addfocus       *int
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Account, error)
	predicates     []predicate.Account
}

var _ ent.Mutation = (*AccountMutation)(nil)

// accountOption allows management of the mutation configuration using functional options.
type accountOption func(*AccountMutation)

// newAccountMutation creates new mutation for the Account entity.
func newAccountMutation(c config, op Op, opts ...accountOption) *AccountMutation {
	m := &AccountMutation{
		config:        c,
		op:            op,
		typ:           TypeAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountID sets the ID field of the mutation.
func withAccountID(id uint64) accountOption {
	return func(m *AccountMutation) {
		var (
			err   error
			once  sync.Once
			value *Account
		)
		m.oldValue = func(ctx context.Context) (*Account, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Account.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccount sets the old Account of the mutation.
func withAccount(node *Account) accountOption {
	return func(m *AccountMutation) {
		m.oldValue = func(context.Context) (*Account, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entschema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Account entities.
func (m *AccountMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Account.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUID sets the "uid" field.
func (m *AccountMutation) SetUID(s string) {
	m.uid = &s
}

// UID returns the value of the "uid" field in the mutation.
func (m *AccountMutation) UID() (r string, exists bool) {
	v := m.uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old "uid" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// ResetUID resets all changes to the "uid" field.
func (m *AccountMutation) ResetUID() {
	m.uid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeactivatedAt sets the "deactivated_at" field.
func (m *AccountMutation) SetDeactivatedAt(t time.Time) {
	m.deactivated_at = &t
}

// DeactivatedAt returns the value of the "deactivated_at" field in the mutation.
func (m *AccountMutation) DeactivatedAt() (r time.Time, exists bool) {
	v := m.deactivated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeactivatedAt returns the old "deactivated_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldDeactivatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeactivatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeactivatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeactivatedAt: %w", err)
	}
	return oldValue.DeactivatedAt, nil
}

// ClearDeactivatedAt clears the value of the "deactivated_at" field.
func (m *AccountMutation) ClearDeactivatedAt() {
	m.deactivated_at = nil
	m.clearedFields[account.FieldDeactivatedAt] = struct{}{}
}

// DeactivatedAtCleared returns if the "deactivated_at" field was cleared in this mutation.
func (m *AccountMutation) DeactivatedAtCleared() bool {
	_, ok := m.clearedFields[account.FieldDeactivatedAt]
	return ok
}

// ResetDeactivatedAt resets all changes to the "deactivated_at" field.
func (m *AccountMutation) ResetDeactivatedAt() {
	m.deactivated_at = nil
	delete(m.clearedFields, account.FieldDeactivatedAt)
}

// SetPhone sets the "phone" field.
func (m *AccountMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *AccountMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *AccountMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[account.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *AccountMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[account.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *AccountMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, account.FieldPhone)
}

// SetEmail sets the "email" field.
func (m *AccountMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *AccountMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *AccountMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[account.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *AccountMutation) EmailCleared() bool {
	_, ok := m.clearedFields[account.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *AccountMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, account.FieldEmail)
}

// SetNickname sets the "nickname" field.
func (m *AccountMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *AccountMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ClearNickname clears the value of the "nickname" field.
func (m *AccountMutation) ClearNickname() {
	m.nickname = nil
	m.clearedFields[account.FieldNickname] = struct{}{}
}

// NicknameCleared returns if the "nickname" field was cleared in this mutation.
func (m *AccountMutation) NicknameCleared() bool {
	_, ok := m.clearedFields[account.FieldNickname]
	return ok
}

// ResetNickname resets all changes to the "nickname" field.
func (m *AccountMutation) ResetNickname() {
	m.nickname = nil
	delete(m.clearedFields, account.FieldNickname)
}

// SetSex sets the "sex" field.
func (m *AccountMutation) SetSex(i int) {
	m.sex = &i
	m.addsex = nil
}

// Sex returns the value of the "sex" field in the mutation.
func (m *AccountMutation) Sex() (r int, exists bool) {
	v := m.sex
	if v == nil {
		return
	}
	return *v, true
}

// OldSex returns the old "sex" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldSex(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSex: %w", err)
	}
	return oldValue.Sex, nil
}

// AddSex adds i to the "sex" field.
func (m *AccountMutation) AddSex(i int) {
	if m.addsex != nil {
		*m.addsex += i
	} else {
		m.addsex = &i
	}
}

// AddedSex returns the value that was added to the "sex" field in this mutation.
func (m *AccountMutation) AddedSex() (r int, exists bool) {
	v := m.addsex
	if v == nil {
		return
	}
	return *v, true
}

// ResetSex resets all changes to the "sex" field.
func (m *AccountMutation) ResetSex() {
	m.sex = nil
	m.addsex = nil
}

// SetPassword sets the "password" field.
func (m *AccountMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *AccountMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *AccountMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[account.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *AccountMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[account.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *AccountMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, account.FieldPassword)
}

// SetWxOpenid sets the "wx_openid" field.
func (m *AccountMutation) SetWxOpenid(s string) {
	m.wx_openid = &s
}

// WxOpenid returns the value of the "wx_openid" field in the mutation.
func (m *AccountMutation) WxOpenid() (r string, exists bool) {
	v := m.wx_openid
	if v == nil {
		return
	}
	return *v, true
}

// OldWxOpenid returns the old "wx_openid" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldWxOpenid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWxOpenid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWxOpenid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWxOpenid: %w", err)
	}
	return oldValue.WxOpenid, nil
}

// ClearWxOpenid clears the value of the "wx_openid" field.
func (m *AccountMutation) ClearWxOpenid() {
	m.wx_openid = nil
	m.clearedFields[account.FieldWxOpenid] = struct{}{}
}

// WxOpenidCleared returns if the "wx_openid" field was cleared in this mutation.
func (m *AccountMutation) WxOpenidCleared() bool {
	_, ok := m.clearedFields[account.FieldWxOpenid]
	return ok
}

// ResetWxOpenid resets all changes to the "wx_openid" field.
func (m *AccountMutation) ResetWxOpenid() {
	m.wx_openid = nil
	delete(m.clearedFields, account.FieldWxOpenid)
}

// SetImage sets the "image" field.
func (m *AccountMutation) SetImage(s string) {
	m.image = &s
}

// Image returns the value of the "image" field in the mutation.
func (m *AccountMutation) Image() (r string, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ClearImage clears the value of the "image" field.
func (m *AccountMutation) ClearImage() {
	m.image = nil
	m.clearedFields[account.FieldImage] = struct{}{}
}

// ImageCleared returns if the "image" field was cleared in this mutation.
func (m *AccountMutation) ImageCleared() bool {
	_, ok := m.clearedFields[account.FieldImage]
	return ok
}

// ResetImage resets all changes to the "image" field.
func (m *AccountMutation) ResetImage() {
	m.image = nil
	delete(m.clearedFields, account.FieldImage)
}

// SetIndustry sets the "industry" field.
func (m *AccountMutation) SetIndustry(s string) {
	m.industry = &s
}

// Industry returns the value of the "industry" field in the mutation.
func (m *AccountMutation) Industry() (r string, exists bool) {
	v := m.industry
	if v == nil {
		return
	}
	return *v, true
}

// OldIndustry returns the old "industry" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldIndustry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndustry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndustry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndustry: %w", err)
	}
	return oldValue.Industry, nil
}

// ClearIndustry clears the value of the "industry" field.
func (m *AccountMutation) ClearIndustry() {
	m.industry = nil
	m.clearedFields[account.FieldIndustry] = struct{}{}
}

// IndustryCleared returns if the "industry" field was cleared in this mutation.
func (m *AccountMutation) IndustryCleared() bool {
	_, ok := m.clearedFields[account.FieldIndustry]
	return ok
}

// ResetIndustry resets all changes to the "industry" field.
func (m *AccountMutation) ResetIndustry() {
	m.industry = nil
	delete(m.clearedFields, account.FieldIndustry)
}

// SetDescription sets the "description" field.
func (m *AccountMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AccountMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AccountMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[account.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AccountMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[account.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AccountMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, account.FieldDescription)
}

// SetAddress sets the "address" field.
func (m *AccountMutation) SetAddress(s schema.Address) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *AccountMutation) Address() (r schema.Address, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldAddress(ctx context.Context) (v schema.Address, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *AccountMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[account.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *AccountMutation) AddressCleared() bool {
	_, ok := m.clearedFields[account.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *AccountMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, account.FieldAddress)
}

// SetAuthCode sets the "auth_code" field.
func (m *AccountMutation) SetAuthCode(s string) {
	m.auth_code = &s
}

// AuthCode returns the value of the "auth_code" field in the mutation.
func (m *AccountMutation) AuthCode() (r string, exists bool) {
	v := m.auth_code
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthCode returns the old "auth_code" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldAuthCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthCode: %w", err)
	}
	return oldValue.AuthCode, nil
}

// ResetAuthCode resets all changes to the "auth_code" field.
func (m *AccountMutation) ResetAuthCode() {
	m.auth_code = nil
}

// SetAuthExpired sets the "auth_expired" field.
func (m *AccountMutation) SetAuthExpired(t time.Time) {
	m.auth_expired = &t
}

// AuthExpired returns the value of the "auth_expired" field in the mutation.
func (m *AccountMutation) AuthExpired() (r time.Time, exists bool) {
	v := m.auth_expired
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthExpired returns the old "auth_expired" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldAuthExpired(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthExpired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthExpired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthExpired: %w", err)
	}
	return oldValue.AuthExpired, nil
}

// ResetAuthExpired resets all changes to the "auth_expired" field.
func (m *AccountMutation) ResetAuthExpired() {
	m.auth_expired = nil
}

// SetURLCount sets the "url_count" field.
func (m *AccountMutation) SetURLCount(i int) {
	m.url_count = &i
	m.addurl_count = nil
}

// URLCount returns the value of the "url_count" field in the mutation.
func (m *AccountMutation) URLCount() (r int, exists bool) {
	v := m.url_count
	if v == nil {
		return
	}
	return *v, true
}

// OldURLCount returns the old "url_count" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldURLCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURLCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURLCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURLCount: %w", err)
	}
	return oldValue.URLCount, nil
}

// AddURLCount adds i to the "url_count" field.
func (m *AccountMutation) AddURLCount(i int) {
	if m.addurl_count != nil {
		*m.addurl_count += i
	} else {
		m.addurl_count = &i
	}
}

// AddedURLCount returns the value that was added to the "url_count" field in this mutation.
func (m *AccountMutation) AddedURLCount() (r int, exists bool) {
	v := m.addurl_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetURLCount resets all changes to the "url_count" field.
func (m *AccountMutation) ResetURLCount() {
	m.url_count = nil
	m.addurl_count = nil
}

// SetURLLimit sets the "url_limit" field.
func (m *AccountMutation) SetURLLimit(i int) {
	m.url_limit = &i
	m.addurl_limit = nil
}

// URLLimit returns the value of the "url_limit" field in the mutation.
func (m *AccountMutation) URLLimit() (r int, exists bool) {
	v := m.url_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldURLLimit returns the old "url_limit" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldURLLimit(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURLLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURLLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURLLimit: %w", err)
	}
	return oldValue.URLLimit, nil
}

// AddURLLimit adds i to the "url_limit" field.
func (m *AccountMutation) AddURLLimit(i int) {
	if m.addurl_limit != nil {
		*m.addurl_limit += i
	} else {
		m.addurl_limit = &i
	}
}

// AddedURLLimit returns the value that was added to the "url_limit" field in this mutation.
func (m *AccountMutation) AddedURLLimit() (r int, exists bool) {
	v := m.addurl_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetURLLimit resets all changes to the "url_limit" field.
func (m *AccountMutation) ResetURLLimit() {
	m.url_limit = nil
	m.addurl_limit = nil
}

// SetMemberType sets the "member_type" field.
func (m *AccountMutation) SetMemberType(s string) {
	m.member_type = &s
}

// MemberType returns the value of the "member_type" field in the mutation.
func (m *AccountMutation) MemberType() (r string, exists bool) {
	v := m.member_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberType returns the old "member_type" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldMemberType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberType: %w", err)
	}
	return oldValue.MemberType, nil
}

// ResetMemberType resets all changes to the "member_type" field.
func (m *AccountMutation) ResetMemberType() {
	m.member_type = nil
}

// SetMemberExpired sets the "member_expired" field.
func (m *AccountMutation) SetMemberExpired(t time.Time) {
	m.member_expired = &t
}

// MemberExpired returns the value of the "member_expired" field in the mutation.
func (m *AccountMutation) MemberExpired() (r time.Time, exists bool) {
	v := m.member_expired
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberExpired returns the old "member_expired" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldMemberExpired(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberExpired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberExpired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberExpired: %w", err)
	}
	return oldValue.MemberExpired, nil
}

// ClearMemberExpired clears the value of the "member_expired" field.
func (m *AccountMutation) ClearMemberExpired() {
	m.member_expired = nil
	m.clearedFields[account.FieldMemberExpired] = struct{}{}
}

// MemberExpiredCleared returns if the "member_expired" field was cleared in this mutation.
func (m *AccountMutation) MemberExpiredCleared() bool {
	_, ok := m.clearedFields[account.FieldMemberExpired]
	return ok
}

// ResetMemberExpired resets all changes to the "member_expired" field.
func (m *AccountMutation) ResetMemberExpired() {
	m.member_expired = nil
	delete(m.clearedFields, account.FieldMemberExpired)
}

// SetHasEntire sets the "has_entire" field.
func (m *AccountMutation) SetHasEntire(b bool) {
	m.has_entire = &b
}

// HasEntire returns the value of the "has_entire" field in the mutation.
func (m *AccountMutation) HasEntire() (r bool, exists bool) {
	v := m.has_entire
	if v == nil {
		return
	}
	return *v, true
}

// OldHasEntire returns the old "has_entire" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldHasEntire(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasEntire is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasEntire requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasEntire: %w", err)
	}
	return oldValue.HasEntire, nil
}

// ResetHasEntire resets all changes to the "has_entire" field.
func (m *AccountMutation) ResetHasEntire() {
	m.has_entire = nil
}

// SetHasNew sets the "has_new" field.
func (m *AccountMutation) SetHasNew(b bool) {
	m.has_new = &b
}

// HasNew returns the value of the "has_new" field in the mutation.
func (m *AccountMutation) HasNew() (r bool, exists bool) {
	v := m.has_new
	if v == nil {
		return
	}
	return *v, true
}

// OldHasNew returns the old "has_new" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldHasNew(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasNew is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasNew requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasNew: %w", err)
	}
	return oldValue.HasNew, nil
}

// ResetHasNew resets all changes to the "has_new" field.
func (m *AccountMutation) ResetHasNew() {
	m.has_new = nil
}

// SetHasAdmin sets the "has_admin" field.
func (m *AccountMutation) SetHasAdmin(b bool) {
	m.has_admin = &b
}

// HasAdmin returns the value of the "has_admin" field in the mutation.
func (m *AccountMutation) HasAdmin() (r bool, exists bool) {
	v := m.has_admin
	if v == nil {
		return
	}
	return *v, true
}

// OldHasAdmin returns the old "has_admin" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldHasAdmin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasAdmin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasAdmin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasAdmin: %w", err)
	}
	return oldValue.HasAdmin, nil
}

// ResetHasAdmin resets all changes to the "has_admin" field.
func (m *AccountMutation) ResetHasAdmin() {
	m.has_admin = nil
}

// SetFans sets the "fans" field.
func (m *AccountMutation) SetFans(i int) {
	m.fans = &i
	m.addfans = nil
}

// Fans returns the value of the "fans" field in the mutation.
func (m *AccountMutation) Fans() (r int, exists bool) {
	v := m.fans
	if v == nil {
		return
	}
	return *v, true
}

// OldFans returns the old "fans" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldFans(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFans is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFans requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFans: %w", err)
	}
	return oldValue.Fans, nil
}

// AddFans adds i to the "fans" field.
func (m *AccountMutation) AddFans(i int) {
	if m.addfans != nil {
		*m.addfans += i
	} else {
		m.addfans = &i
	}
}

// AddedFans returns the value that was added to the "fans" field in this mutation.
func (m *AccountMutation) AddedFans() (r int, exists bool) {
	v := m.addfans
	if v == nil {
		return
	}
	return *v, true
}

// ResetFans resets all changes to the "fans" field.
func (m *AccountMutation) ResetFans() {
	m.fans = nil
	m.addfans = nil
}

// SetFocus sets the "focus" field.
func (m *AccountMutation) SetFocus(i int) {
	m.focus = &i
	m.addfocus = nil
}

// Focus returns the value of the "focus" field in the mutation.
func (m *AccountMutation) Focus() (r int, exists bool) {
	v := m.focus
	if v == nil {
		return
	}
	return *v, true
}

// OldFocus returns the old "focus" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldFocus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFocus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFocus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFocus: %w", err)
	}
	return oldValue.Focus, nil
}

// AddFocus adds i to the "focus" field.
func (m *AccountMutation) AddFocus(i int) {
	if m.addfocus != nil {
		*m.addfocus += i
	} else {
		m.addfocus = &i
	}
}

// AddedFocus returns the value that was added to the "focus" field in this mutation.
func (m *AccountMutation) AddedFocus() (r int, exists bool) {
	v := m.addfocus
	if v == nil {
		return
	}
	return *v, true
}

// ResetFocus resets all changes to the "focus" field.
func (m *AccountMutation) ResetFocus() {
	m.focus = nil
	m.addfocus = nil
}

// Where appends a list predicates to the AccountMutation builder.
func (m *AccountMutation) Where(ps ...predicate.Account) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AccountMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Account).
func (m *AccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountMutation) Fields() []string {
	fields := make([]string, 0, 25)
	if m.uid != nil {
		fields = append(fields, account.FieldUID)
	}
	if m.created_at != nil {
		fields = append(fields, account.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, account.FieldUpdatedAt)
	}
	if m.deactivated_at != nil {
		fields = append(fields, account.FieldDeactivatedAt)
	}
	if m.phone != nil {
		fields = append(fields, account.FieldPhone)
	}
	if m.email != nil {
		fields = append(fields, account.FieldEmail)
	}
	if m.nickname != nil {
		fields = append(fields, account.FieldNickname)
	}
	if m.sex != nil {
		fields = append(fields, account.FieldSex)
	}
	if m.password != nil {
		fields = append(fields, account.FieldPassword)
	}
	if m.wx_openid != nil {
		fields = append(fields, account.FieldWxOpenid)
	}
	if m.image != nil {
		fields = append(fields, account.FieldImage)
	}
	if m.industry != nil {
		fields = append(fields, account.FieldIndustry)
	}
	if m.description != nil {
		fields = append(fields, account.FieldDescription)
	}
	if m.address != nil {
		fields = append(fields, account.FieldAddress)
	}
	if m.auth_code != nil {
		fields = append(fields, account.FieldAuthCode)
	}
	if m.auth_expired != nil {
		fields = append(fields, account.FieldAuthExpired)
	}
	if m.url_count != nil {
		fields = append(fields, account.FieldURLCount)
	}
	if m.url_limit != nil {
		fields = append(fields, account.FieldURLLimit)
	}
	if m.member_type != nil {
		fields = append(fields, account.FieldMemberType)
	}
	if m.member_expired != nil {
		fields = append(fields, account.FieldMemberExpired)
	}
	if m.has_entire != nil {
		fields = append(fields, account.FieldHasEntire)
	}
	if m.has_new != nil {
		fields = append(fields, account.FieldHasNew)
	}
	if m.has_admin != nil {
		fields = append(fields, account.FieldHasAdmin)
	}
	if m.fans != nil {
		fields = append(fields, account.FieldFans)
	}
	if m.focus != nil {
		fields = append(fields, account.FieldFocus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case account.FieldUID:
		return m.UID()
	case account.FieldCreatedAt:
		return m.CreatedAt()
	case account.FieldUpdatedAt:
		return m.UpdatedAt()
	case account.FieldDeactivatedAt:
		return m.DeactivatedAt()
	case account.FieldPhone:
		return m.Phone()
	case account.FieldEmail:
		return m.Email()
	case account.FieldNickname:
		return m.Nickname()
	case account.FieldSex:
		return m.Sex()
	case account.FieldPassword:
		return m.Password()
	case account.FieldWxOpenid:
		return m.WxOpenid()
	case account.FieldImage:
		return m.Image()
	case account.FieldIndustry:
		return m.Industry()
	case account.FieldDescription:
		return m.Description()
	case account.FieldAddress:
		return m.Address()
	case account.FieldAuthCode:
		return m.AuthCode()
	case account.FieldAuthExpired:
		return m.AuthExpired()
	case account.FieldURLCount:
		return m.URLCount()
	case account.FieldURLLimit:
		return m.URLLimit()
	case account.FieldMemberType:
		return m.MemberType()
	case account.FieldMemberExpired:
		return m.MemberExpired()
	case account.FieldHasEntire:
		return m.HasEntire()
	case account.FieldHasNew:
		return m.HasNew()
	case account.FieldHasAdmin:
		return m.HasAdmin()
	case account.FieldFans:
		return m.Fans()
	case account.FieldFocus:
		return m.Focus()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case account.FieldUID:
		return m.OldUID(ctx)
	case account.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case account.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case account.FieldDeactivatedAt:
		return m.OldDeactivatedAt(ctx)
	case account.FieldPhone:
		return m.OldPhone(ctx)
	case account.FieldEmail:
		return m.OldEmail(ctx)
	case account.FieldNickname:
		return m.OldNickname(ctx)
	case account.FieldSex:
		return m.OldSex(ctx)
	case account.FieldPassword:
		return m.OldPassword(ctx)
	case account.FieldWxOpenid:
		return m.OldWxOpenid(ctx)
	case account.FieldImage:
		return m.OldImage(ctx)
	case account.FieldIndustry:
		return m.OldIndustry(ctx)
	case account.FieldDescription:
		return m.OldDescription(ctx)
	case account.FieldAddress:
		return m.OldAddress(ctx)
	case account.FieldAuthCode:
		return m.OldAuthCode(ctx)
	case account.FieldAuthExpired:
		return m.OldAuthExpired(ctx)
	case account.FieldURLCount:
		return m.OldURLCount(ctx)
	case account.FieldURLLimit:
		return m.OldURLLimit(ctx)
	case account.FieldMemberType:
		return m.OldMemberType(ctx)
	case account.FieldMemberExpired:
		return m.OldMemberExpired(ctx)
	case account.FieldHasEntire:
		return m.OldHasEntire(ctx)
	case account.FieldHasNew:
		return m.OldHasNew(ctx)
	case account.FieldHasAdmin:
		return m.OldHasAdmin(ctx)
	case account.FieldFans:
		return m.OldFans(ctx)
	case account.FieldFocus:
		return m.OldFocus(ctx)
	}
	return nil, fmt.Errorf("unknown Account field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case account.FieldUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case account.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case account.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case account.FieldDeactivatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeactivatedAt(v)
		return nil
	case account.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case account.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case account.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case account.FieldSex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSex(v)
		return nil
	case account.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case account.FieldWxOpenid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWxOpenid(v)
		return nil
	case account.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	case account.FieldIndustry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndustry(v)
		return nil
	case account.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case account.FieldAddress:
		v, ok := value.(schema.Address)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case account.FieldAuthCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthCode(v)
		return nil
	case account.FieldAuthExpired:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthExpired(v)
		return nil
	case account.FieldURLCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURLCount(v)
		return nil
	case account.FieldURLLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURLLimit(v)
		return nil
	case account.FieldMemberType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberType(v)
		return nil
	case account.FieldMemberExpired:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberExpired(v)
		return nil
	case account.FieldHasEntire:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasEntire(v)
		return nil
	case account.FieldHasNew:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasNew(v)
		return nil
	case account.FieldHasAdmin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasAdmin(v)
		return nil
	case account.FieldFans:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFans(v)
		return nil
	case account.FieldFocus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFocus(v)
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountMutation) AddedFields() []string {
	var fields []string
	if m.addsex != nil {
		fields = append(fields, account.FieldSex)
	}
	if m.addurl_count != nil {
		fields = append(fields, account.FieldURLCount)
	}
	if m.addurl_limit != nil {
		fields = append(fields, account.FieldURLLimit)
	}
	if m.addfans != nil {
		fields = append(fields, account.FieldFans)
	}
	if m.addfocus != nil {
		fields = append(fields, account.FieldFocus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case account.FieldSex:
		return m.AddedSex()
	case account.FieldURLCount:
		return m.AddedURLCount()
	case account.FieldURLLimit:
		return m.AddedURLLimit()
	case account.FieldFans:
		return m.AddedFans()
	case account.FieldFocus:
		return m.AddedFocus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case account.FieldSex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSex(v)
		return nil
	case account.FieldURLCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddURLCount(v)
		return nil
	case account.FieldURLLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddURLLimit(v)
		return nil
	case account.FieldFans:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFans(v)
		return nil
	case account.FieldFocus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFocus(v)
		return nil
	}
	return fmt.Errorf("unknown Account numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(account.FieldDeactivatedAt) {
		fields = append(fields, account.FieldDeactivatedAt)
	}
	if m.FieldCleared(account.FieldPhone) {
		fields = append(fields, account.FieldPhone)
	}
	if m.FieldCleared(account.FieldEmail) {
		fields = append(fields, account.FieldEmail)
	}
	if m.FieldCleared(account.FieldNickname) {
		fields = append(fields, account.FieldNickname)
	}
	if m.FieldCleared(account.FieldPassword) {
		fields = append(fields, account.FieldPassword)
	}
	if m.FieldCleared(account.FieldWxOpenid) {
		fields = append(fields, account.FieldWxOpenid)
	}
	if m.FieldCleared(account.FieldImage) {
		fields = append(fields, account.FieldImage)
	}
	if m.FieldCleared(account.FieldIndustry) {
		fields = append(fields, account.FieldIndustry)
	}
	if m.FieldCleared(account.FieldDescription) {
		fields = append(fields, account.FieldDescription)
	}
	if m.FieldCleared(account.FieldAddress) {
		fields = append(fields, account.FieldAddress)
	}
	if m.FieldCleared(account.FieldMemberExpired) {
		fields = append(fields, account.FieldMemberExpired)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountMutation) ClearField(name string) error {
	switch name {
	case account.FieldDeactivatedAt:
		m.ClearDeactivatedAt()
		return nil
	case account.FieldPhone:
		m.ClearPhone()
		return nil
	case account.FieldEmail:
		m.ClearEmail()
		return nil
	case account.FieldNickname:
		m.ClearNickname()
		return nil
	case account.FieldPassword:
		m.ClearPassword()
		return nil
	case account.FieldWxOpenid:
		m.ClearWxOpenid()
		return nil
	case account.FieldImage:
		m.ClearImage()
		return nil
	case account.FieldIndustry:
		m.ClearIndustry()
		return nil
	case account.FieldDescription:
		m.ClearDescription()
		return nil
	case account.FieldAddress:
		m.ClearAddress()
		return nil
	case account.FieldMemberExpired:
		m.ClearMemberExpired()
		return nil
	}
	return fmt.Errorf("unknown Account nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountMutation) ResetField(name string) error {
	switch name {
	case account.FieldUID:
		m.ResetUID()
		return nil
	case account.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case account.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case account.FieldDeactivatedAt:
		m.ResetDeactivatedAt()
		return nil
	case account.FieldPhone:
		m.ResetPhone()
		return nil
	case account.FieldEmail:
		m.ResetEmail()
		return nil
	case account.FieldNickname:
		m.ResetNickname()
		return nil
	case account.FieldSex:
		m.ResetSex()
		return nil
	case account.FieldPassword:
		m.ResetPassword()
		return nil
	case account.FieldWxOpenid:
		m.ResetWxOpenid()
		return nil
	case account.FieldImage:
		m.ResetImage()
		return nil
	case account.FieldIndustry:
		m.ResetIndustry()
		return nil
	case account.FieldDescription:
		m.ResetDescription()
		return nil
	case account.FieldAddress:
		m.ResetAddress()
		return nil
	case account.FieldAuthCode:
		m.ResetAuthCode()
		return nil
	case account.FieldAuthExpired:
		m.ResetAuthExpired()
		return nil
	case account.FieldURLCount:
		m.ResetURLCount()
		return nil
	case account.FieldURLLimit:
		m.ResetURLLimit()
		return nil
	case account.FieldMemberType:
		m.ResetMemberType()
		return nil
	case account.FieldMemberExpired:
		m.ResetMemberExpired()
		return nil
	case account.FieldHasEntire:
		m.ResetHasEntire()
		return nil
	case account.FieldHasNew:
		m.ResetHasNew()
		return nil
	case account.FieldHasAdmin:
		m.ResetHasAdmin()
		return nil
	case account.FieldFans:
		m.ResetFans()
		return nil
	case account.FieldFocus:
		m.ResetFocus()
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Account unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Account edge %s", name)
}

// AdminMutation represents an operation that mutates the Admin nodes in the graph.
type AdminMutation struct {
	config
	op             Op
	typ            string
	id             *int
	uid            *string
	created_at     *time.Time
	updated_at     *time.Time
	deactivated_at *time.Time
	user_uid       *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Admin, error)
	predicates     []predicate.Admin
}

var _ ent.Mutation = (*AdminMutation)(nil)

// adminOption allows management of the mutation configuration using functional options.
type adminOption func(*AdminMutation)

// newAdminMutation creates new mutation for the Admin entity.
func newAdminMutation(c config, op Op, opts ...adminOption) *AdminMutation {
	m := &AdminMutation{
		config:        c,
		op:            op,
		typ:           TypeAdmin,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdminID sets the ID field of the mutation.
func withAdminID(id int) adminOption {
	return func(m *AdminMutation) {
		var (
			err   error
			once  sync.Once
			value *Admin
		)
		m.oldValue = func(ctx context.Context) (*Admin, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Admin.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdmin sets the old Admin of the mutation.
func withAdmin(node *Admin) adminOption {
	return func(m *AdminMutation) {
		m.oldValue = func(context.Context) (*Admin, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdminMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdminMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entschema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AdminMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AdminMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Admin.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUID sets the "uid" field.
func (m *AdminMutation) SetUID(s string) {
	m.uid = &s
}

// UID returns the value of the "uid" field in the mutation.
func (m *AdminMutation) UID() (r string, exists bool) {
	v := m.uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old "uid" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// ResetUID resets all changes to the "uid" field.
func (m *AdminMutation) ResetUID() {
	m.uid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AdminMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AdminMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AdminMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AdminMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AdminMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AdminMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeactivatedAt sets the "deactivated_at" field.
func (m *AdminMutation) SetDeactivatedAt(t time.Time) {
	m.deactivated_at = &t
}

// DeactivatedAt returns the value of the "deactivated_at" field in the mutation.
func (m *AdminMutation) DeactivatedAt() (r time.Time, exists bool) {
	v := m.deactivated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeactivatedAt returns the old "deactivated_at" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldDeactivatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeactivatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeactivatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeactivatedAt: %w", err)
	}
	return oldValue.DeactivatedAt, nil
}

// ClearDeactivatedAt clears the value of the "deactivated_at" field.
func (m *AdminMutation) ClearDeactivatedAt() {
	m.deactivated_at = nil
	m.clearedFields[admin.FieldDeactivatedAt] = struct{}{}
}

// DeactivatedAtCleared returns if the "deactivated_at" field was cleared in this mutation.
func (m *AdminMutation) DeactivatedAtCleared() bool {
	_, ok := m.clearedFields[admin.FieldDeactivatedAt]
	return ok
}

// ResetDeactivatedAt resets all changes to the "deactivated_at" field.
func (m *AdminMutation) ResetDeactivatedAt() {
	m.deactivated_at = nil
	delete(m.clearedFields, admin.FieldDeactivatedAt)
}

// SetUserUID sets the "user_uid" field.
func (m *AdminMutation) SetUserUID(s string) {
	m.user_uid = &s
}

// UserUID returns the value of the "user_uid" field in the mutation.
func (m *AdminMutation) UserUID() (r string, exists bool) {
	v := m.user_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUserUID returns the old "user_uid" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldUserUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserUID: %w", err)
	}
	return oldValue.UserUID, nil
}

// ResetUserUID resets all changes to the "user_uid" field.
func (m *AdminMutation) ResetUserUID() {
	m.user_uid = nil
}

// Where appends a list predicates to the AdminMutation builder.
func (m *AdminMutation) Where(ps ...predicate.Admin) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AdminMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Admin).
func (m *AdminMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AdminMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.uid != nil {
		fields = append(fields, admin.FieldUID)
	}
	if m.created_at != nil {
		fields = append(fields, admin.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, admin.FieldUpdatedAt)
	}
	if m.deactivated_at != nil {
		fields = append(fields, admin.FieldDeactivatedAt)
	}
	if m.user_uid != nil {
		fields = append(fields, admin.FieldUserUID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AdminMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case admin.FieldUID:
		return m.UID()
	case admin.FieldCreatedAt:
		return m.CreatedAt()
	case admin.FieldUpdatedAt:
		return m.UpdatedAt()
	case admin.FieldDeactivatedAt:
		return m.DeactivatedAt()
	case admin.FieldUserUID:
		return m.UserUID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AdminMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case admin.FieldUID:
		return m.OldUID(ctx)
	case admin.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case admin.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case admin.FieldDeactivatedAt:
		return m.OldDeactivatedAt(ctx)
	case admin.FieldUserUID:
		return m.OldUserUID(ctx)
	}
	return nil, fmt.Errorf("unknown Admin field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminMutation) SetField(name string, value ent.Value) error {
	switch name {
	case admin.FieldUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case admin.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case admin.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case admin.FieldDeactivatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeactivatedAt(v)
		return nil
	case admin.FieldUserUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserUID(v)
		return nil
	}
	return fmt.Errorf("unknown Admin field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AdminMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AdminMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Admin numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AdminMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(admin.FieldDeactivatedAt) {
		fields = append(fields, admin.FieldDeactivatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AdminMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdminMutation) ClearField(name string) error {
	switch name {
	case admin.FieldDeactivatedAt:
		m.ClearDeactivatedAt()
		return nil
	}
	return fmt.Errorf("unknown Admin nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AdminMutation) ResetField(name string) error {
	switch name {
	case admin.FieldUID:
		m.ResetUID()
		return nil
	case admin.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case admin.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case admin.FieldDeactivatedAt:
		m.ResetDeactivatedAt()
		return nil
	case admin.FieldUserUID:
		m.ResetUserUID()
		return nil
	}
	return fmt.Errorf("unknown Admin field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AdminMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AdminMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AdminMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AdminMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AdminMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AdminMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AdminMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Admin unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AdminMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Admin edge %s", name)
}

// CollaborationMutation represents an operation that mutates the Collaboration nodes in the graph.
type CollaborationMutation struct {
	config
	op             Op
	typ            string
	id             *uint64
	uid            *string
	created_at     *time.Time
	updated_at     *time.Time
	deactivated_at *time.Time
	shard_uid      *string
	folder_uid     *string
	user_uid       *string
	authority      *string
	folder_number  *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Collaboration, error)
	predicates     []predicate.Collaboration
}

var _ ent.Mutation = (*CollaborationMutation)(nil)

// collaborationOption allows management of the mutation configuration using functional options.
type collaborationOption func(*CollaborationMutation)

// newCollaborationMutation creates new mutation for the Collaboration entity.
func newCollaborationMutation(c config, op Op, opts ...collaborationOption) *CollaborationMutation {
	m := &CollaborationMutation{
		config:        c,
		op:            op,
		typ:           TypeCollaboration,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCollaborationID sets the ID field of the mutation.
func withCollaborationID(id uint64) collaborationOption {
	return func(m *CollaborationMutation) {
		var (
			err   error
			once  sync.Once
			value *Collaboration
		)
		m.oldValue = func(ctx context.Context) (*Collaboration, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Collaboration.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCollaboration sets the old Collaboration of the mutation.
func withCollaboration(node *Collaboration) collaborationOption {
	return func(m *CollaborationMutation) {
		m.oldValue = func(context.Context) (*Collaboration, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CollaborationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CollaborationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entschema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Collaboration entities.
func (m *CollaborationMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CollaborationMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CollaborationMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Collaboration.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUID sets the "uid" field.
func (m *CollaborationMutation) SetUID(s string) {
	m.uid = &s
}

// UID returns the value of the "uid" field in the mutation.
func (m *CollaborationMutation) UID() (r string, exists bool) {
	v := m.uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old "uid" field's value of the Collaboration entity.
// If the Collaboration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollaborationMutation) OldUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// ResetUID resets all changes to the "uid" field.
func (m *CollaborationMutation) ResetUID() {
	m.uid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CollaborationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CollaborationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Collaboration entity.
// If the Collaboration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollaborationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CollaborationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CollaborationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CollaborationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Collaboration entity.
// If the Collaboration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollaborationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CollaborationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeactivatedAt sets the "deactivated_at" field.
func (m *CollaborationMutation) SetDeactivatedAt(t time.Time) {
	m.deactivated_at = &t
}

// DeactivatedAt returns the value of the "deactivated_at" field in the mutation.
func (m *CollaborationMutation) DeactivatedAt() (r time.Time, exists bool) {
	v := m.deactivated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeactivatedAt returns the old "deactivated_at" field's value of the Collaboration entity.
// If the Collaboration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollaborationMutation) OldDeactivatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeactivatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeactivatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeactivatedAt: %w", err)
	}
	return oldValue.DeactivatedAt, nil
}

// ClearDeactivatedAt clears the value of the "deactivated_at" field.
func (m *CollaborationMutation) ClearDeactivatedAt() {
	m.deactivated_at = nil
	m.clearedFields[collaboration.FieldDeactivatedAt] = struct{}{}
}

// DeactivatedAtCleared returns if the "deactivated_at" field was cleared in this mutation.
func (m *CollaborationMutation) DeactivatedAtCleared() bool {
	_, ok := m.clearedFields[collaboration.FieldDeactivatedAt]
	return ok
}

// ResetDeactivatedAt resets all changes to the "deactivated_at" field.
func (m *CollaborationMutation) ResetDeactivatedAt() {
	m.deactivated_at = nil
	delete(m.clearedFields, collaboration.FieldDeactivatedAt)
}

// SetShardUID sets the "shard_uid" field.
func (m *CollaborationMutation) SetShardUID(s string) {
	m.shard_uid = &s
}

// ShardUID returns the value of the "shard_uid" field in the mutation.
func (m *CollaborationMutation) ShardUID() (r string, exists bool) {
	v := m.shard_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldShardUID returns the old "shard_uid" field's value of the Collaboration entity.
// If the Collaboration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollaborationMutation) OldShardUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShardUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShardUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShardUID: %w", err)
	}
	return oldValue.ShardUID, nil
}

// ResetShardUID resets all changes to the "shard_uid" field.
func (m *CollaborationMutation) ResetShardUID() {
	m.shard_uid = nil
}

// SetFolderUID sets the "folder_uid" field.
func (m *CollaborationMutation) SetFolderUID(s string) {
	m.folder_uid = &s
}

// FolderUID returns the value of the "folder_uid" field in the mutation.
func (m *CollaborationMutation) FolderUID() (r string, exists bool) {
	v := m.folder_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldFolderUID returns the old "folder_uid" field's value of the Collaboration entity.
// If the Collaboration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollaborationMutation) OldFolderUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFolderUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFolderUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFolderUID: %w", err)
	}
	return oldValue.FolderUID, nil
}

// ResetFolderUID resets all changes to the "folder_uid" field.
func (m *CollaborationMutation) ResetFolderUID() {
	m.folder_uid = nil
}

// SetUserUID sets the "user_uid" field.
func (m *CollaborationMutation) SetUserUID(s string) {
	m.user_uid = &s
}

// UserUID returns the value of the "user_uid" field in the mutation.
func (m *CollaborationMutation) UserUID() (r string, exists bool) {
	v := m.user_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUserUID returns the old "user_uid" field's value of the Collaboration entity.
// If the Collaboration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollaborationMutation) OldUserUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserUID: %w", err)
	}
	return oldValue.UserUID, nil
}

// ResetUserUID resets all changes to the "user_uid" field.
func (m *CollaborationMutation) ResetUserUID() {
	m.user_uid = nil
}

// SetAuthority sets the "authority" field.
func (m *CollaborationMutation) SetAuthority(s string) {
	m.authority = &s
}

// Authority returns the value of the "authority" field in the mutation.
func (m *CollaborationMutation) Authority() (r string, exists bool) {
	v := m.authority
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthority returns the old "authority" field's value of the Collaboration entity.
// If the Collaboration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollaborationMutation) OldAuthority(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthority: %w", err)
	}
	return oldValue.Authority, nil
}

// ResetAuthority resets all changes to the "authority" field.
func (m *CollaborationMutation) ResetAuthority() {
	m.authority = nil
}

// SetFolderNumber sets the "folder_number" field.
func (m *CollaborationMutation) SetFolderNumber(s string) {
	m.folder_number = &s
}

// FolderNumber returns the value of the "folder_number" field in the mutation.
func (m *CollaborationMutation) FolderNumber() (r string, exists bool) {
	v := m.folder_number
	if v == nil {
		return
	}
	return *v, true
}

// OldFolderNumber returns the old "folder_number" field's value of the Collaboration entity.
// If the Collaboration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollaborationMutation) OldFolderNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFolderNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFolderNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFolderNumber: %w", err)
	}
	return oldValue.FolderNumber, nil
}

// ResetFolderNumber resets all changes to the "folder_number" field.
func (m *CollaborationMutation) ResetFolderNumber() {
	m.folder_number = nil
}

// Where appends a list predicates to the CollaborationMutation builder.
func (m *CollaborationMutation) Where(ps ...predicate.Collaboration) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CollaborationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Collaboration).
func (m *CollaborationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CollaborationMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.uid != nil {
		fields = append(fields, collaboration.FieldUID)
	}
	if m.created_at != nil {
		fields = append(fields, collaboration.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, collaboration.FieldUpdatedAt)
	}
	if m.deactivated_at != nil {
		fields = append(fields, collaboration.FieldDeactivatedAt)
	}
	if m.shard_uid != nil {
		fields = append(fields, collaboration.FieldShardUID)
	}
	if m.folder_uid != nil {
		fields = append(fields, collaboration.FieldFolderUID)
	}
	if m.user_uid != nil {
		fields = append(fields, collaboration.FieldUserUID)
	}
	if m.authority != nil {
		fields = append(fields, collaboration.FieldAuthority)
	}
	if m.folder_number != nil {
		fields = append(fields, collaboration.FieldFolderNumber)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CollaborationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case collaboration.FieldUID:
		return m.UID()
	case collaboration.FieldCreatedAt:
		return m.CreatedAt()
	case collaboration.FieldUpdatedAt:
		return m.UpdatedAt()
	case collaboration.FieldDeactivatedAt:
		return m.DeactivatedAt()
	case collaboration.FieldShardUID:
		return m.ShardUID()
	case collaboration.FieldFolderUID:
		return m.FolderUID()
	case collaboration.FieldUserUID:
		return m.UserUID()
	case collaboration.FieldAuthority:
		return m.Authority()
	case collaboration.FieldFolderNumber:
		return m.FolderNumber()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CollaborationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case collaboration.FieldUID:
		return m.OldUID(ctx)
	case collaboration.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case collaboration.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case collaboration.FieldDeactivatedAt:
		return m.OldDeactivatedAt(ctx)
	case collaboration.FieldShardUID:
		return m.OldShardUID(ctx)
	case collaboration.FieldFolderUID:
		return m.OldFolderUID(ctx)
	case collaboration.FieldUserUID:
		return m.OldUserUID(ctx)
	case collaboration.FieldAuthority:
		return m.OldAuthority(ctx)
	case collaboration.FieldFolderNumber:
		return m.OldFolderNumber(ctx)
	}
	return nil, fmt.Errorf("unknown Collaboration field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CollaborationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case collaboration.FieldUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case collaboration.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case collaboration.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case collaboration.FieldDeactivatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeactivatedAt(v)
		return nil
	case collaboration.FieldShardUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShardUID(v)
		return nil
	case collaboration.FieldFolderUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFolderUID(v)
		return nil
	case collaboration.FieldUserUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserUID(v)
		return nil
	case collaboration.FieldAuthority:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthority(v)
		return nil
	case collaboration.FieldFolderNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFolderNumber(v)
		return nil
	}
	return fmt.Errorf("unknown Collaboration field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CollaborationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CollaborationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CollaborationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Collaboration numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CollaborationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(collaboration.FieldDeactivatedAt) {
		fields = append(fields, collaboration.FieldDeactivatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CollaborationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CollaborationMutation) ClearField(name string) error {
	switch name {
	case collaboration.FieldDeactivatedAt:
		m.ClearDeactivatedAt()
		return nil
	}
	return fmt.Errorf("unknown Collaboration nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CollaborationMutation) ResetField(name string) error {
	switch name {
	case collaboration.FieldUID:
		m.ResetUID()
		return nil
	case collaboration.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case collaboration.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case collaboration.FieldDeactivatedAt:
		m.ResetDeactivatedAt()
		return nil
	case collaboration.FieldShardUID:
		m.ResetShardUID()
		return nil
	case collaboration.FieldFolderUID:
		m.ResetFolderUID()
		return nil
	case collaboration.FieldUserUID:
		m.ResetUserUID()
		return nil
	case collaboration.FieldAuthority:
		m.ResetAuthority()
		return nil
	case collaboration.FieldFolderNumber:
		m.ResetFolderNumber()
		return nil
	}
	return fmt.Errorf("unknown Collaboration field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CollaborationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CollaborationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CollaborationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CollaborationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CollaborationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CollaborationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CollaborationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Collaboration unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CollaborationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Collaboration edge %s", name)
}

// CommunityMutation represents an operation that mutates the Community nodes in the graph.
type CommunityMutation struct {
	config
	op             Op
	typ            string
	id             *uint64
	uid            *string
	created_at     *time.Time
	updated_at     *time.Time
	deactivated_at *time.Time
	title          *string
	description    *string
	image          *string
	tags           *[]string
	praise         *int
	addpraise      *int
	star           *int
	addstar        *int
	view           *int
	addview        *int
	used           *int
	addused        *int
	folder_uid     *string
	user_uid       *string
	status         *string
	remark         *string
	category_uid   *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Community, error)
	predicates     []predicate.Community
}

var _ ent.Mutation = (*CommunityMutation)(nil)

// communityOption allows management of the mutation configuration using functional options.
type communityOption func(*CommunityMutation)

// newCommunityMutation creates new mutation for the Community entity.
func newCommunityMutation(c config, op Op, opts ...communityOption) *CommunityMutation {
	m := &CommunityMutation{
		config:        c,
		op:            op,
		typ:           TypeCommunity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommunityID sets the ID field of the mutation.
func withCommunityID(id uint64) communityOption {
	return func(m *CommunityMutation) {
		var (
			err   error
			once  sync.Once
			value *Community
		)
		m.oldValue = func(ctx context.Context) (*Community, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Community.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCommunity sets the old Community of the mutation.
func withCommunity(node *Community) communityOption {
	return func(m *CommunityMutation) {
		m.oldValue = func(context.Context) (*Community, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommunityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommunityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entschema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Community entities.
func (m *CommunityMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommunityMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommunityMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Community.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUID sets the "uid" field.
func (m *CommunityMutation) SetUID(s string) {
	m.uid = &s
}

// UID returns the value of the "uid" field in the mutation.
func (m *CommunityMutation) UID() (r string, exists bool) {
	v := m.uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old "uid" field's value of the Community entity.
// If the Community object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMutation) OldUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// ResetUID resets all changes to the "uid" field.
func (m *CommunityMutation) ResetUID() {
	m.uid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CommunityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CommunityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Community entity.
// If the Community object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CommunityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CommunityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CommunityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Community entity.
// If the Community object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CommunityMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeactivatedAt sets the "deactivated_at" field.
func (m *CommunityMutation) SetDeactivatedAt(t time.Time) {
	m.deactivated_at = &t
}

// DeactivatedAt returns the value of the "deactivated_at" field in the mutation.
func (m *CommunityMutation) DeactivatedAt() (r time.Time, exists bool) {
	v := m.deactivated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeactivatedAt returns the old "deactivated_at" field's value of the Community entity.
// If the Community object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMutation) OldDeactivatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeactivatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeactivatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeactivatedAt: %w", err)
	}
	return oldValue.DeactivatedAt, nil
}

// ClearDeactivatedAt clears the value of the "deactivated_at" field.
func (m *CommunityMutation) ClearDeactivatedAt() {
	m.deactivated_at = nil
	m.clearedFields[community.FieldDeactivatedAt] = struct{}{}
}

// DeactivatedAtCleared returns if the "deactivated_at" field was cleared in this mutation.
func (m *CommunityMutation) DeactivatedAtCleared() bool {
	_, ok := m.clearedFields[community.FieldDeactivatedAt]
	return ok
}

// ResetDeactivatedAt resets all changes to the "deactivated_at" field.
func (m *CommunityMutation) ResetDeactivatedAt() {
	m.deactivated_at = nil
	delete(m.clearedFields, community.FieldDeactivatedAt)
}

// SetTitle sets the "title" field.
func (m *CommunityMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *CommunityMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Community entity.
// If the Community object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *CommunityMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *CommunityMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CommunityMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Community entity.
// If the Community object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CommunityMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[community.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CommunityMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[community.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CommunityMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, community.FieldDescription)
}

// SetImage sets the "image" field.
func (m *CommunityMutation) SetImage(s string) {
	m.image = &s
}

// Image returns the value of the "image" field in the mutation.
func (m *CommunityMutation) Image() (r string, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the Community entity.
// If the Community object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMutation) OldImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ResetImage resets all changes to the "image" field.
func (m *CommunityMutation) ResetImage() {
	m.image = nil
}

// SetTags sets the "tags" field.
func (m *CommunityMutation) SetTags(s []string) {
	m.tags = &s
}

// Tags returns the value of the "tags" field in the mutation.
func (m *CommunityMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Community entity.
// If the Community object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ClearTags clears the value of the "tags" field.
func (m *CommunityMutation) ClearTags() {
	m.tags = nil
	m.clearedFields[community.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *CommunityMutation) TagsCleared() bool {
	_, ok := m.clearedFields[community.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *CommunityMutation) ResetTags() {
	m.tags = nil
	delete(m.clearedFields, community.FieldTags)
}

// SetPraise sets the "praise" field.
func (m *CommunityMutation) SetPraise(i int) {
	m.praise = &i
	m.addpraise = nil
}

// Praise returns the value of the "praise" field in the mutation.
func (m *CommunityMutation) Praise() (r int, exists bool) {
	v := m.praise
	if v == nil {
		return
	}
	return *v, true
}

// OldPraise returns the old "praise" field's value of the Community entity.
// If the Community object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMutation) OldPraise(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPraise is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPraise requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPraise: %w", err)
	}
	return oldValue.Praise, nil
}

// AddPraise adds i to the "praise" field.
func (m *CommunityMutation) AddPraise(i int) {
	if m.addpraise != nil {
		*m.addpraise += i
	} else {
		m.addpraise = &i
	}
}

// AddedPraise returns the value that was added to the "praise" field in this mutation.
func (m *CommunityMutation) AddedPraise() (r int, exists bool) {
	v := m.addpraise
	if v == nil {
		return
	}
	return *v, true
}

// ResetPraise resets all changes to the "praise" field.
func (m *CommunityMutation) ResetPraise() {
	m.praise = nil
	m.addpraise = nil
}

// SetStar sets the "star" field.
func (m *CommunityMutation) SetStar(i int) {
	m.star = &i
	m.addstar = nil
}

// Star returns the value of the "star" field in the mutation.
func (m *CommunityMutation) Star() (r int, exists bool) {
	v := m.star
	if v == nil {
		return
	}
	return *v, true
}

// OldStar returns the old "star" field's value of the Community entity.
// If the Community object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMutation) OldStar(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStar: %w", err)
	}
	return oldValue.Star, nil
}

// AddStar adds i to the "star" field.
func (m *CommunityMutation) AddStar(i int) {
	if m.addstar != nil {
		*m.addstar += i
	} else {
		m.addstar = &i
	}
}

// AddedStar returns the value that was added to the "star" field in this mutation.
func (m *CommunityMutation) AddedStar() (r int, exists bool) {
	v := m.addstar
	if v == nil {
		return
	}
	return *v, true
}

// ResetStar resets all changes to the "star" field.
func (m *CommunityMutation) ResetStar() {
	m.star = nil
	m.addstar = nil
}

// SetView sets the "view" field.
func (m *CommunityMutation) SetView(i int) {
	m.view = &i
	m.addview = nil
}

// View returns the value of the "view" field in the mutation.
func (m *CommunityMutation) View() (r int, exists bool) {
	v := m.view
	if v == nil {
		return
	}
	return *v, true
}

// OldView returns the old "view" field's value of the Community entity.
// If the Community object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMutation) OldView(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldView is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldView requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldView: %w", err)
	}
	return oldValue.View, nil
}

// AddView adds i to the "view" field.
func (m *CommunityMutation) AddView(i int) {
	if m.addview != nil {
		*m.addview += i
	} else {
		m.addview = &i
	}
}

// AddedView returns the value that was added to the "view" field in this mutation.
func (m *CommunityMutation) AddedView() (r int, exists bool) {
	v := m.addview
	if v == nil {
		return
	}
	return *v, true
}

// ResetView resets all changes to the "view" field.
func (m *CommunityMutation) ResetView() {
	m.view = nil
	m.addview = nil
}

// SetUsed sets the "used" field.
func (m *CommunityMutation) SetUsed(i int) {
	m.used = &i
	m.addused = nil
}

// Used returns the value of the "used" field in the mutation.
func (m *CommunityMutation) Used() (r int, exists bool) {
	v := m.used
	if v == nil {
		return
	}
	return *v, true
}

// OldUsed returns the old "used" field's value of the Community entity.
// If the Community object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMutation) OldUsed(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsed: %w", err)
	}
	return oldValue.Used, nil
}

// AddUsed adds i to the "used" field.
func (m *CommunityMutation) AddUsed(i int) {
	if m.addused != nil {
		*m.addused += i
	} else {
		m.addused = &i
	}
}

// AddedUsed returns the value that was added to the "used" field in this mutation.
func (m *CommunityMutation) AddedUsed() (r int, exists bool) {
	v := m.addused
	if v == nil {
		return
	}
	return *v, true
}

// ResetUsed resets all changes to the "used" field.
func (m *CommunityMutation) ResetUsed() {
	m.used = nil
	m.addused = nil
}

// SetFolderUID sets the "folder_uid" field.
func (m *CommunityMutation) SetFolderUID(s string) {
	m.folder_uid = &s
}

// FolderUID returns the value of the "folder_uid" field in the mutation.
func (m *CommunityMutation) FolderUID() (r string, exists bool) {
	v := m.folder_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldFolderUID returns the old "folder_uid" field's value of the Community entity.
// If the Community object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMutation) OldFolderUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFolderUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFolderUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFolderUID: %w", err)
	}
	return oldValue.FolderUID, nil
}

// ResetFolderUID resets all changes to the "folder_uid" field.
func (m *CommunityMutation) ResetFolderUID() {
	m.folder_uid = nil
}

// SetUserUID sets the "user_uid" field.
func (m *CommunityMutation) SetUserUID(s string) {
	m.user_uid = &s
}

// UserUID returns the value of the "user_uid" field in the mutation.
func (m *CommunityMutation) UserUID() (r string, exists bool) {
	v := m.user_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUserUID returns the old "user_uid" field's value of the Community entity.
// If the Community object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMutation) OldUserUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserUID: %w", err)
	}
	return oldValue.UserUID, nil
}

// ResetUserUID resets all changes to the "user_uid" field.
func (m *CommunityMutation) ResetUserUID() {
	m.user_uid = nil
}

// SetStatus sets the "status" field.
func (m *CommunityMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *CommunityMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Community entity.
// If the Community object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CommunityMutation) ResetStatus() {
	m.status = nil
}

// SetRemark sets the "remark" field.
func (m *CommunityMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *CommunityMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Community entity.
// If the Community object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *CommunityMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[community.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *CommunityMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[community.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *CommunityMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, community.FieldRemark)
}

// SetCategoryUID sets the "category_uid" field.
func (m *CommunityMutation) SetCategoryUID(s string) {
	m.category_uid = &s
}

// CategoryUID returns the value of the "category_uid" field in the mutation.
func (m *CommunityMutation) CategoryUID() (r string, exists bool) {
	v := m.category_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryUID returns the old "category_uid" field's value of the Community entity.
// If the Community object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMutation) OldCategoryUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryUID: %w", err)
	}
	return oldValue.CategoryUID, nil
}

// ResetCategoryUID resets all changes to the "category_uid" field.
func (m *CommunityMutation) ResetCategoryUID() {
	m.category_uid = nil
}

// Where appends a list predicates to the CommunityMutation builder.
func (m *CommunityMutation) Where(ps ...predicate.Community) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CommunityMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Community).
func (m *CommunityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommunityMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.uid != nil {
		fields = append(fields, community.FieldUID)
	}
	if m.created_at != nil {
		fields = append(fields, community.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, community.FieldUpdatedAt)
	}
	if m.deactivated_at != nil {
		fields = append(fields, community.FieldDeactivatedAt)
	}
	if m.title != nil {
		fields = append(fields, community.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, community.FieldDescription)
	}
	if m.image != nil {
		fields = append(fields, community.FieldImage)
	}
	if m.tags != nil {
		fields = append(fields, community.FieldTags)
	}
	if m.praise != nil {
		fields = append(fields, community.FieldPraise)
	}
	if m.star != nil {
		fields = append(fields, community.FieldStar)
	}
	if m.view != nil {
		fields = append(fields, community.FieldView)
	}
	if m.used != nil {
		fields = append(fields, community.FieldUsed)
	}
	if m.folder_uid != nil {
		fields = append(fields, community.FieldFolderUID)
	}
	if m.user_uid != nil {
		fields = append(fields, community.FieldUserUID)
	}
	if m.status != nil {
		fields = append(fields, community.FieldStatus)
	}
	if m.remark != nil {
		fields = append(fields, community.FieldRemark)
	}
	if m.category_uid != nil {
		fields = append(fields, community.FieldCategoryUID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommunityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case community.FieldUID:
		return m.UID()
	case community.FieldCreatedAt:
		return m.CreatedAt()
	case community.FieldUpdatedAt:
		return m.UpdatedAt()
	case community.FieldDeactivatedAt:
		return m.DeactivatedAt()
	case community.FieldTitle:
		return m.Title()
	case community.FieldDescription:
		return m.Description()
	case community.FieldImage:
		return m.Image()
	case community.FieldTags:
		return m.Tags()
	case community.FieldPraise:
		return m.Praise()
	case community.FieldStar:
		return m.Star()
	case community.FieldView:
		return m.View()
	case community.FieldUsed:
		return m.Used()
	case community.FieldFolderUID:
		return m.FolderUID()
	case community.FieldUserUID:
		return m.UserUID()
	case community.FieldStatus:
		return m.Status()
	case community.FieldRemark:
		return m.Remark()
	case community.FieldCategoryUID:
		return m.CategoryUID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommunityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case community.FieldUID:
		return m.OldUID(ctx)
	case community.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case community.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case community.FieldDeactivatedAt:
		return m.OldDeactivatedAt(ctx)
	case community.FieldTitle:
		return m.OldTitle(ctx)
	case community.FieldDescription:
		return m.OldDescription(ctx)
	case community.FieldImage:
		return m.OldImage(ctx)
	case community.FieldTags:
		return m.OldTags(ctx)
	case community.FieldPraise:
		return m.OldPraise(ctx)
	case community.FieldStar:
		return m.OldStar(ctx)
	case community.FieldView:
		return m.OldView(ctx)
	case community.FieldUsed:
		return m.OldUsed(ctx)
	case community.FieldFolderUID:
		return m.OldFolderUID(ctx)
	case community.FieldUserUID:
		return m.OldUserUID(ctx)
	case community.FieldStatus:
		return m.OldStatus(ctx)
	case community.FieldRemark:
		return m.OldRemark(ctx)
	case community.FieldCategoryUID:
		return m.OldCategoryUID(ctx)
	}
	return nil, fmt.Errorf("unknown Community field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommunityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case community.FieldUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case community.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case community.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case community.FieldDeactivatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeactivatedAt(v)
		return nil
	case community.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case community.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case community.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	case community.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case community.FieldPraise:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPraise(v)
		return nil
	case community.FieldStar:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStar(v)
		return nil
	case community.FieldView:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetView(v)
		return nil
	case community.FieldUsed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsed(v)
		return nil
	case community.FieldFolderUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFolderUID(v)
		return nil
	case community.FieldUserUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserUID(v)
		return nil
	case community.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case community.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case community.FieldCategoryUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryUID(v)
		return nil
	}
	return fmt.Errorf("unknown Community field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommunityMutation) AddedFields() []string {
	var fields []string
	if m.addpraise != nil {
		fields = append(fields, community.FieldPraise)
	}
	if m.addstar != nil {
		fields = append(fields, community.FieldStar)
	}
	if m.addview != nil {
		fields = append(fields, community.FieldView)
	}
	if m.addused != nil {
		fields = append(fields, community.FieldUsed)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommunityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case community.FieldPraise:
		return m.AddedPraise()
	case community.FieldStar:
		return m.AddedStar()
	case community.FieldView:
		return m.AddedView()
	case community.FieldUsed:
		return m.AddedUsed()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommunityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case community.FieldPraise:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPraise(v)
		return nil
	case community.FieldStar:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStar(v)
		return nil
	case community.FieldView:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddView(v)
		return nil
	case community.FieldUsed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsed(v)
		return nil
	}
	return fmt.Errorf("unknown Community numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommunityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(community.FieldDeactivatedAt) {
		fields = append(fields, community.FieldDeactivatedAt)
	}
	if m.FieldCleared(community.FieldDescription) {
		fields = append(fields, community.FieldDescription)
	}
	if m.FieldCleared(community.FieldTags) {
		fields = append(fields, community.FieldTags)
	}
	if m.FieldCleared(community.FieldRemark) {
		fields = append(fields, community.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommunityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommunityMutation) ClearField(name string) error {
	switch name {
	case community.FieldDeactivatedAt:
		m.ClearDeactivatedAt()
		return nil
	case community.FieldDescription:
		m.ClearDescription()
		return nil
	case community.FieldTags:
		m.ClearTags()
		return nil
	case community.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown Community nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommunityMutation) ResetField(name string) error {
	switch name {
	case community.FieldUID:
		m.ResetUID()
		return nil
	case community.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case community.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case community.FieldDeactivatedAt:
		m.ResetDeactivatedAt()
		return nil
	case community.FieldTitle:
		m.ResetTitle()
		return nil
	case community.FieldDescription:
		m.ResetDescription()
		return nil
	case community.FieldImage:
		m.ResetImage()
		return nil
	case community.FieldTags:
		m.ResetTags()
		return nil
	case community.FieldPraise:
		m.ResetPraise()
		return nil
	case community.FieldStar:
		m.ResetStar()
		return nil
	case community.FieldView:
		m.ResetView()
		return nil
	case community.FieldUsed:
		m.ResetUsed()
		return nil
	case community.FieldFolderUID:
		m.ResetFolderUID()
		return nil
	case community.FieldUserUID:
		m.ResetUserUID()
		return nil
	case community.FieldStatus:
		m.ResetStatus()
		return nil
	case community.FieldRemark:
		m.ResetRemark()
		return nil
	case community.FieldCategoryUID:
		m.ResetCategoryUID()
		return nil
	}
	return fmt.Errorf("unknown Community field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommunityMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommunityMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommunityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommunityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommunityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommunityMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommunityMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Community unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommunityMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Community edge %s", name)
}

// CommunityCategoryMutation represents an operation that mutates the CommunityCategory nodes in the graph.
type CommunityCategoryMutation struct {
	config
	op             Op
	typ            string
	id             *uint64
	uid            *string
	created_at     *time.Time
	updated_at     *time.Time
	deactivated_at *time.Time
	name           *string
	status         *bool
	sequence       *int
	addsequence    *int
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*CommunityCategory, error)
	predicates     []predicate.CommunityCategory
}

var _ ent.Mutation = (*CommunityCategoryMutation)(nil)

// communitycategoryOption allows management of the mutation configuration using functional options.
type communitycategoryOption func(*CommunityCategoryMutation)

// newCommunityCategoryMutation creates new mutation for the CommunityCategory entity.
func newCommunityCategoryMutation(c config, op Op, opts ...communitycategoryOption) *CommunityCategoryMutation {
	m := &CommunityCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeCommunityCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommunityCategoryID sets the ID field of the mutation.
func withCommunityCategoryID(id uint64) communitycategoryOption {
	return func(m *CommunityCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *CommunityCategory
		)
		m.oldValue = func(ctx context.Context) (*CommunityCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CommunityCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCommunityCategory sets the old CommunityCategory of the mutation.
func withCommunityCategory(node *CommunityCategory) communitycategoryOption {
	return func(m *CommunityCategoryMutation) {
		m.oldValue = func(context.Context) (*CommunityCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommunityCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommunityCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entschema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CommunityCategory entities.
func (m *CommunityCategoryMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommunityCategoryMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommunityCategoryMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CommunityCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUID sets the "uid" field.
func (m *CommunityCategoryMutation) SetUID(s string) {
	m.uid = &s
}

// UID returns the value of the "uid" field in the mutation.
func (m *CommunityCategoryMutation) UID() (r string, exists bool) {
	v := m.uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old "uid" field's value of the CommunityCategory entity.
// If the CommunityCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityCategoryMutation) OldUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// ResetUID resets all changes to the "uid" field.
func (m *CommunityCategoryMutation) ResetUID() {
	m.uid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CommunityCategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CommunityCategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CommunityCategory entity.
// If the CommunityCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityCategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CommunityCategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CommunityCategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CommunityCategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CommunityCategory entity.
// If the CommunityCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityCategoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CommunityCategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeactivatedAt sets the "deactivated_at" field.
func (m *CommunityCategoryMutation) SetDeactivatedAt(t time.Time) {
	m.deactivated_at = &t
}

// DeactivatedAt returns the value of the "deactivated_at" field in the mutation.
func (m *CommunityCategoryMutation) DeactivatedAt() (r time.Time, exists bool) {
	v := m.deactivated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeactivatedAt returns the old "deactivated_at" field's value of the CommunityCategory entity.
// If the CommunityCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityCategoryMutation) OldDeactivatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeactivatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeactivatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeactivatedAt: %w", err)
	}
	return oldValue.DeactivatedAt, nil
}

// ClearDeactivatedAt clears the value of the "deactivated_at" field.
func (m *CommunityCategoryMutation) ClearDeactivatedAt() {
	m.deactivated_at = nil
	m.clearedFields[communitycategory.FieldDeactivatedAt] = struct{}{}
}

// DeactivatedAtCleared returns if the "deactivated_at" field was cleared in this mutation.
func (m *CommunityCategoryMutation) DeactivatedAtCleared() bool {
	_, ok := m.clearedFields[communitycategory.FieldDeactivatedAt]
	return ok
}

// ResetDeactivatedAt resets all changes to the "deactivated_at" field.
func (m *CommunityCategoryMutation) ResetDeactivatedAt() {
	m.deactivated_at = nil
	delete(m.clearedFields, communitycategory.FieldDeactivatedAt)
}

// SetName sets the "name" field.
func (m *CommunityCategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CommunityCategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CommunityCategory entity.
// If the CommunityCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityCategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CommunityCategoryMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the "status" field.
func (m *CommunityCategoryMutation) SetStatus(b bool) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *CommunityCategoryMutation) Status() (r bool, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the CommunityCategory entity.
// If the CommunityCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityCategoryMutation) OldStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CommunityCategoryMutation) ResetStatus() {
	m.status = nil
}

// SetSequence sets the "sequence" field.
func (m *CommunityCategoryMutation) SetSequence(i int) {
	m.sequence = &i
	m.addsequence = nil
}

// Sequence returns the value of the "sequence" field in the mutation.
func (m *CommunityCategoryMutation) Sequence() (r int, exists bool) {
	v := m.sequence
	if v == nil {
		return
	}
	return *v, true
}

// OldSequence returns the old "sequence" field's value of the CommunityCategory entity.
// If the CommunityCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityCategoryMutation) OldSequence(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSequence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSequence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSequence: %w", err)
	}
	return oldValue.Sequence, nil
}

// AddSequence adds i to the "sequence" field.
func (m *CommunityCategoryMutation) AddSequence(i int) {
	if m.addsequence != nil {
		*m.addsequence += i
	} else {
		m.addsequence = &i
	}
}

// AddedSequence returns the value that was added to the "sequence" field in this mutation.
func (m *CommunityCategoryMutation) AddedSequence() (r int, exists bool) {
	v := m.addsequence
	if v == nil {
		return
	}
	return *v, true
}

// ResetSequence resets all changes to the "sequence" field.
func (m *CommunityCategoryMutation) ResetSequence() {
	m.sequence = nil
	m.addsequence = nil
}

// Where appends a list predicates to the CommunityCategoryMutation builder.
func (m *CommunityCategoryMutation) Where(ps ...predicate.CommunityCategory) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CommunityCategoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CommunityCategory).
func (m *CommunityCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommunityCategoryMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.uid != nil {
		fields = append(fields, communitycategory.FieldUID)
	}
	if m.created_at != nil {
		fields = append(fields, communitycategory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, communitycategory.FieldUpdatedAt)
	}
	if m.deactivated_at != nil {
		fields = append(fields, communitycategory.FieldDeactivatedAt)
	}
	if m.name != nil {
		fields = append(fields, communitycategory.FieldName)
	}
	if m.status != nil {
		fields = append(fields, communitycategory.FieldStatus)
	}
	if m.sequence != nil {
		fields = append(fields, communitycategory.FieldSequence)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommunityCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case communitycategory.FieldUID:
		return m.UID()
	case communitycategory.FieldCreatedAt:
		return m.CreatedAt()
	case communitycategory.FieldUpdatedAt:
		return m.UpdatedAt()
	case communitycategory.FieldDeactivatedAt:
		return m.DeactivatedAt()
	case communitycategory.FieldName:
		return m.Name()
	case communitycategory.FieldStatus:
		return m.Status()
	case communitycategory.FieldSequence:
		return m.Sequence()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommunityCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case communitycategory.FieldUID:
		return m.OldUID(ctx)
	case communitycategory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case communitycategory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case communitycategory.FieldDeactivatedAt:
		return m.OldDeactivatedAt(ctx)
	case communitycategory.FieldName:
		return m.OldName(ctx)
	case communitycategory.FieldStatus:
		return m.OldStatus(ctx)
	case communitycategory.FieldSequence:
		return m.OldSequence(ctx)
	}
	return nil, fmt.Errorf("unknown CommunityCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommunityCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case communitycategory.FieldUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case communitycategory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case communitycategory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case communitycategory.FieldDeactivatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeactivatedAt(v)
		return nil
	case communitycategory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case communitycategory.FieldStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case communitycategory.FieldSequence:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSequence(v)
		return nil
	}
	return fmt.Errorf("unknown CommunityCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommunityCategoryMutation) AddedFields() []string {
	var fields []string
	if m.addsequence != nil {
		fields = append(fields, communitycategory.FieldSequence)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommunityCategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case communitycategory.FieldSequence:
		return m.AddedSequence()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommunityCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case communitycategory.FieldSequence:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSequence(v)
		return nil
	}
	return fmt.Errorf("unknown CommunityCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommunityCategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(communitycategory.FieldDeactivatedAt) {
		fields = append(fields, communitycategory.FieldDeactivatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommunityCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommunityCategoryMutation) ClearField(name string) error {
	switch name {
	case communitycategory.FieldDeactivatedAt:
		m.ClearDeactivatedAt()
		return nil
	}
	return fmt.Errorf("unknown CommunityCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommunityCategoryMutation) ResetField(name string) error {
	switch name {
	case communitycategory.FieldUID:
		m.ResetUID()
		return nil
	case communitycategory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case communitycategory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case communitycategory.FieldDeactivatedAt:
		m.ResetDeactivatedAt()
		return nil
	case communitycategory.FieldName:
		m.ResetName()
		return nil
	case communitycategory.FieldStatus:
		m.ResetStatus()
		return nil
	case communitycategory.FieldSequence:
		m.ResetSequence()
		return nil
	}
	return fmt.Errorf("unknown CommunityCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommunityCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommunityCategoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommunityCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommunityCategoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommunityCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommunityCategoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommunityCategoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CommunityCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommunityCategoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CommunityCategory edge %s", name)
}

// CommunityMetaMutation represents an operation that mutates the CommunityMeta nodes in the graph.
type CommunityMetaMutation struct {
	config
	op             Op
	typ            string
	id             *uint64
	uid            *string
	created_at     *time.Time
	updated_at     *time.Time
	deactivated_at *time.Time
	community_uid  *string
	user_uid       *string
	has_praise     *bool
	has_star       *bool
	has_view       *bool
	has_used       *bool
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*CommunityMeta, error)
	predicates     []predicate.CommunityMeta
}

var _ ent.Mutation = (*CommunityMetaMutation)(nil)

// communitymetaOption allows management of the mutation configuration using functional options.
type communitymetaOption func(*CommunityMetaMutation)

// newCommunityMetaMutation creates new mutation for the CommunityMeta entity.
func newCommunityMetaMutation(c config, op Op, opts ...communitymetaOption) *CommunityMetaMutation {
	m := &CommunityMetaMutation{
		config:        c,
		op:            op,
		typ:           TypeCommunityMeta,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommunityMetaID sets the ID field of the mutation.
func withCommunityMetaID(id uint64) communitymetaOption {
	return func(m *CommunityMetaMutation) {
		var (
			err   error
			once  sync.Once
			value *CommunityMeta
		)
		m.oldValue = func(ctx context.Context) (*CommunityMeta, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CommunityMeta.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCommunityMeta sets the old CommunityMeta of the mutation.
func withCommunityMeta(node *CommunityMeta) communitymetaOption {
	return func(m *CommunityMetaMutation) {
		m.oldValue = func(context.Context) (*CommunityMeta, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommunityMetaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommunityMetaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entschema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CommunityMeta entities.
func (m *CommunityMetaMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommunityMetaMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommunityMetaMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CommunityMeta.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUID sets the "uid" field.
func (m *CommunityMetaMutation) SetUID(s string) {
	m.uid = &s
}

// UID returns the value of the "uid" field in the mutation.
func (m *CommunityMetaMutation) UID() (r string, exists bool) {
	v := m.uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old "uid" field's value of the CommunityMeta entity.
// If the CommunityMeta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMetaMutation) OldUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// ResetUID resets all changes to the "uid" field.
func (m *CommunityMetaMutation) ResetUID() {
	m.uid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CommunityMetaMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CommunityMetaMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CommunityMeta entity.
// If the CommunityMeta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMetaMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CommunityMetaMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CommunityMetaMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CommunityMetaMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CommunityMeta entity.
// If the CommunityMeta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMetaMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CommunityMetaMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeactivatedAt sets the "deactivated_at" field.
func (m *CommunityMetaMutation) SetDeactivatedAt(t time.Time) {
	m.deactivated_at = &t
}

// DeactivatedAt returns the value of the "deactivated_at" field in the mutation.
func (m *CommunityMetaMutation) DeactivatedAt() (r time.Time, exists bool) {
	v := m.deactivated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeactivatedAt returns the old "deactivated_at" field's value of the CommunityMeta entity.
// If the CommunityMeta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMetaMutation) OldDeactivatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeactivatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeactivatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeactivatedAt: %w", err)
	}
	return oldValue.DeactivatedAt, nil
}

// ClearDeactivatedAt clears the value of the "deactivated_at" field.
func (m *CommunityMetaMutation) ClearDeactivatedAt() {
	m.deactivated_at = nil
	m.clearedFields[communitymeta.FieldDeactivatedAt] = struct{}{}
}

// DeactivatedAtCleared returns if the "deactivated_at" field was cleared in this mutation.
func (m *CommunityMetaMutation) DeactivatedAtCleared() bool {
	_, ok := m.clearedFields[communitymeta.FieldDeactivatedAt]
	return ok
}

// ResetDeactivatedAt resets all changes to the "deactivated_at" field.
func (m *CommunityMetaMutation) ResetDeactivatedAt() {
	m.deactivated_at = nil
	delete(m.clearedFields, communitymeta.FieldDeactivatedAt)
}

// SetCommunityUID sets the "community_uid" field.
func (m *CommunityMetaMutation) SetCommunityUID(s string) {
	m.community_uid = &s
}

// CommunityUID returns the value of the "community_uid" field in the mutation.
func (m *CommunityMetaMutation) CommunityUID() (r string, exists bool) {
	v := m.community_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldCommunityUID returns the old "community_uid" field's value of the CommunityMeta entity.
// If the CommunityMeta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMetaMutation) OldCommunityUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommunityUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommunityUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommunityUID: %w", err)
	}
	return oldValue.CommunityUID, nil
}

// ResetCommunityUID resets all changes to the "community_uid" field.
func (m *CommunityMetaMutation) ResetCommunityUID() {
	m.community_uid = nil
}

// SetUserUID sets the "user_uid" field.
func (m *CommunityMetaMutation) SetUserUID(s string) {
	m.user_uid = &s
}

// UserUID returns the value of the "user_uid" field in the mutation.
func (m *CommunityMetaMutation) UserUID() (r string, exists bool) {
	v := m.user_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUserUID returns the old "user_uid" field's value of the CommunityMeta entity.
// If the CommunityMeta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMetaMutation) OldUserUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserUID: %w", err)
	}
	return oldValue.UserUID, nil
}

// ResetUserUID resets all changes to the "user_uid" field.
func (m *CommunityMetaMutation) ResetUserUID() {
	m.user_uid = nil
}

// SetHasPraise sets the "has_praise" field.
func (m *CommunityMetaMutation) SetHasPraise(b bool) {
	m.has_praise = &b
}

// HasPraise returns the value of the "has_praise" field in the mutation.
func (m *CommunityMetaMutation) HasPraise() (r bool, exists bool) {
	v := m.has_praise
	if v == nil {
		return
	}
	return *v, true
}

// OldHasPraise returns the old "has_praise" field's value of the CommunityMeta entity.
// If the CommunityMeta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMetaMutation) OldHasPraise(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasPraise is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasPraise requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasPraise: %w", err)
	}
	return oldValue.HasPraise, nil
}

// ResetHasPraise resets all changes to the "has_praise" field.
func (m *CommunityMetaMutation) ResetHasPraise() {
	m.has_praise = nil
}

// SetHasStar sets the "has_star" field.
func (m *CommunityMetaMutation) SetHasStar(b bool) {
	m.has_star = &b
}

// HasStar returns the value of the "has_star" field in the mutation.
func (m *CommunityMetaMutation) HasStar() (r bool, exists bool) {
	v := m.has_star
	if v == nil {
		return
	}
	return *v, true
}

// OldHasStar returns the old "has_star" field's value of the CommunityMeta entity.
// If the CommunityMeta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMetaMutation) OldHasStar(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasStar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasStar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasStar: %w", err)
	}
	return oldValue.HasStar, nil
}

// ResetHasStar resets all changes to the "has_star" field.
func (m *CommunityMetaMutation) ResetHasStar() {
	m.has_star = nil
}

// SetHasView sets the "has_view" field.
func (m *CommunityMetaMutation) SetHasView(b bool) {
	m.has_view = &b
}

// HasView returns the value of the "has_view" field in the mutation.
func (m *CommunityMetaMutation) HasView() (r bool, exists bool) {
	v := m.has_view
	if v == nil {
		return
	}
	return *v, true
}

// OldHasView returns the old "has_view" field's value of the CommunityMeta entity.
// If the CommunityMeta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMetaMutation) OldHasView(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasView is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasView requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasView: %w", err)
	}
	return oldValue.HasView, nil
}

// ResetHasView resets all changes to the "has_view" field.
func (m *CommunityMetaMutation) ResetHasView() {
	m.has_view = nil
}

// SetHasUsed sets the "has_used" field.
func (m *CommunityMetaMutation) SetHasUsed(b bool) {
	m.has_used = &b
}

// HasUsed returns the value of the "has_used" field in the mutation.
func (m *CommunityMetaMutation) HasUsed() (r bool, exists bool) {
	v := m.has_used
	if v == nil {
		return
	}
	return *v, true
}

// OldHasUsed returns the old "has_used" field's value of the CommunityMeta entity.
// If the CommunityMeta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMetaMutation) OldHasUsed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasUsed: %w", err)
	}
	return oldValue.HasUsed, nil
}

// ResetHasUsed resets all changes to the "has_used" field.
func (m *CommunityMetaMutation) ResetHasUsed() {
	m.has_used = nil
}

// Where appends a list predicates to the CommunityMetaMutation builder.
func (m *CommunityMetaMutation) Where(ps ...predicate.CommunityMeta) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CommunityMetaMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CommunityMeta).
func (m *CommunityMetaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommunityMetaMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.uid != nil {
		fields = append(fields, communitymeta.FieldUID)
	}
	if m.created_at != nil {
		fields = append(fields, communitymeta.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, communitymeta.FieldUpdatedAt)
	}
	if m.deactivated_at != nil {
		fields = append(fields, communitymeta.FieldDeactivatedAt)
	}
	if m.community_uid != nil {
		fields = append(fields, communitymeta.FieldCommunityUID)
	}
	if m.user_uid != nil {
		fields = append(fields, communitymeta.FieldUserUID)
	}
	if m.has_praise != nil {
		fields = append(fields, communitymeta.FieldHasPraise)
	}
	if m.has_star != nil {
		fields = append(fields, communitymeta.FieldHasStar)
	}
	if m.has_view != nil {
		fields = append(fields, communitymeta.FieldHasView)
	}
	if m.has_used != nil {
		fields = append(fields, communitymeta.FieldHasUsed)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommunityMetaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case communitymeta.FieldUID:
		return m.UID()
	case communitymeta.FieldCreatedAt:
		return m.CreatedAt()
	case communitymeta.FieldUpdatedAt:
		return m.UpdatedAt()
	case communitymeta.FieldDeactivatedAt:
		return m.DeactivatedAt()
	case communitymeta.FieldCommunityUID:
		return m.CommunityUID()
	case communitymeta.FieldUserUID:
		return m.UserUID()
	case communitymeta.FieldHasPraise:
		return m.HasPraise()
	case communitymeta.FieldHasStar:
		return m.HasStar()
	case communitymeta.FieldHasView:
		return m.HasView()
	case communitymeta.FieldHasUsed:
		return m.HasUsed()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommunityMetaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case communitymeta.FieldUID:
		return m.OldUID(ctx)
	case communitymeta.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case communitymeta.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case communitymeta.FieldDeactivatedAt:
		return m.OldDeactivatedAt(ctx)
	case communitymeta.FieldCommunityUID:
		return m.OldCommunityUID(ctx)
	case communitymeta.FieldUserUID:
		return m.OldUserUID(ctx)
	case communitymeta.FieldHasPraise:
		return m.OldHasPraise(ctx)
	case communitymeta.FieldHasStar:
		return m.OldHasStar(ctx)
	case communitymeta.FieldHasView:
		return m.OldHasView(ctx)
	case communitymeta.FieldHasUsed:
		return m.OldHasUsed(ctx)
	}
	return nil, fmt.Errorf("unknown CommunityMeta field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommunityMetaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case communitymeta.FieldUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case communitymeta.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case communitymeta.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case communitymeta.FieldDeactivatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeactivatedAt(v)
		return nil
	case communitymeta.FieldCommunityUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommunityUID(v)
		return nil
	case communitymeta.FieldUserUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserUID(v)
		return nil
	case communitymeta.FieldHasPraise:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasPraise(v)
		return nil
	case communitymeta.FieldHasStar:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasStar(v)
		return nil
	case communitymeta.FieldHasView:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasView(v)
		return nil
	case communitymeta.FieldHasUsed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasUsed(v)
		return nil
	}
	return fmt.Errorf("unknown CommunityMeta field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommunityMetaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommunityMetaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommunityMetaMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CommunityMeta numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommunityMetaMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(communitymeta.FieldDeactivatedAt) {
		fields = append(fields, communitymeta.FieldDeactivatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommunityMetaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommunityMetaMutation) ClearField(name string) error {
	switch name {
	case communitymeta.FieldDeactivatedAt:
		m.ClearDeactivatedAt()
		return nil
	}
	return fmt.Errorf("unknown CommunityMeta nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommunityMetaMutation) ResetField(name string) error {
	switch name {
	case communitymeta.FieldUID:
		m.ResetUID()
		return nil
	case communitymeta.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case communitymeta.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case communitymeta.FieldDeactivatedAt:
		m.ResetDeactivatedAt()
		return nil
	case communitymeta.FieldCommunityUID:
		m.ResetCommunityUID()
		return nil
	case communitymeta.FieldUserUID:
		m.ResetUserUID()
		return nil
	case communitymeta.FieldHasPraise:
		m.ResetHasPraise()
		return nil
	case communitymeta.FieldHasStar:
		m.ResetHasStar()
		return nil
	case communitymeta.FieldHasView:
		m.ResetHasView()
		return nil
	case communitymeta.FieldHasUsed:
		m.ResetHasUsed()
		return nil
	}
	return fmt.Errorf("unknown CommunityMeta field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommunityMetaMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommunityMetaMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommunityMetaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommunityMetaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommunityMetaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommunityMetaMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommunityMetaMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CommunityMeta unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommunityMetaMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CommunityMeta edge %s", name)
}

// FeedbackMutation represents an operation that mutates the Feedback nodes in the graph.
type FeedbackMutation struct {
	config
	op             Op
	typ            string
	id             *uint64
	uid            *string
	created_at     *time.Time
	updated_at     *time.Time
	deactivated_at *time.Time
	user_uid       *string
	category       *string
	description    *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Feedback, error)
	predicates     []predicate.Feedback
}

var _ ent.Mutation = (*FeedbackMutation)(nil)

// feedbackOption allows management of the mutation configuration using functional options.
type feedbackOption func(*FeedbackMutation)

// newFeedbackMutation creates new mutation for the Feedback entity.
func newFeedbackMutation(c config, op Op, opts ...feedbackOption) *FeedbackMutation {
	m := &FeedbackMutation{
		config:        c,
		op:            op,
		typ:           TypeFeedback,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeedbackID sets the ID field of the mutation.
func withFeedbackID(id uint64) feedbackOption {
	return func(m *FeedbackMutation) {
		var (
			err   error
			once  sync.Once
			value *Feedback
		)
		m.oldValue = func(ctx context.Context) (*Feedback, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Feedback.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeedback sets the old Feedback of the mutation.
func withFeedback(node *Feedback) feedbackOption {
	return func(m *FeedbackMutation) {
		m.oldValue = func(context.Context) (*Feedback, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeedbackMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeedbackMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entschema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Feedback entities.
func (m *FeedbackMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeedbackMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeedbackMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Feedback.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUID sets the "uid" field.
func (m *FeedbackMutation) SetUID(s string) {
	m.uid = &s
}

// UID returns the value of the "uid" field in the mutation.
func (m *FeedbackMutation) UID() (r string, exists bool) {
	v := m.uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old "uid" field's value of the Feedback entity.
// If the Feedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedbackMutation) OldUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// ResetUID resets all changes to the "uid" field.
func (m *FeedbackMutation) ResetUID() {
	m.uid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FeedbackMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FeedbackMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Feedback entity.
// If the Feedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedbackMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FeedbackMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FeedbackMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FeedbackMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Feedback entity.
// If the Feedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedbackMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FeedbackMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeactivatedAt sets the "deactivated_at" field.
func (m *FeedbackMutation) SetDeactivatedAt(t time.Time) {
	m.deactivated_at = &t
}

// DeactivatedAt returns the value of the "deactivated_at" field in the mutation.
func (m *FeedbackMutation) DeactivatedAt() (r time.Time, exists bool) {
	v := m.deactivated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeactivatedAt returns the old "deactivated_at" field's value of the Feedback entity.
// If the Feedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedbackMutation) OldDeactivatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeactivatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeactivatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeactivatedAt: %w", err)
	}
	return oldValue.DeactivatedAt, nil
}

// ClearDeactivatedAt clears the value of the "deactivated_at" field.
func (m *FeedbackMutation) ClearDeactivatedAt() {
	m.deactivated_at = nil
	m.clearedFields[feedback.FieldDeactivatedAt] = struct{}{}
}

// DeactivatedAtCleared returns if the "deactivated_at" field was cleared in this mutation.
func (m *FeedbackMutation) DeactivatedAtCleared() bool {
	_, ok := m.clearedFields[feedback.FieldDeactivatedAt]
	return ok
}

// ResetDeactivatedAt resets all changes to the "deactivated_at" field.
func (m *FeedbackMutation) ResetDeactivatedAt() {
	m.deactivated_at = nil
	delete(m.clearedFields, feedback.FieldDeactivatedAt)
}

// SetUserUID sets the "user_uid" field.
func (m *FeedbackMutation) SetUserUID(s string) {
	m.user_uid = &s
}

// UserUID returns the value of the "user_uid" field in the mutation.
func (m *FeedbackMutation) UserUID() (r string, exists bool) {
	v := m.user_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUserUID returns the old "user_uid" field's value of the Feedback entity.
// If the Feedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedbackMutation) OldUserUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserUID: %w", err)
	}
	return oldValue.UserUID, nil
}

// ResetUserUID resets all changes to the "user_uid" field.
func (m *FeedbackMutation) ResetUserUID() {
	m.user_uid = nil
}

// SetCategory sets the "category" field.
func (m *FeedbackMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *FeedbackMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Feedback entity.
// If the Feedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedbackMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *FeedbackMutation) ResetCategory() {
	m.category = nil
}

// SetDescription sets the "description" field.
func (m *FeedbackMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *FeedbackMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Feedback entity.
// If the Feedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedbackMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *FeedbackMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[feedback.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *FeedbackMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[feedback.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *FeedbackMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, feedback.FieldDescription)
}

// Where appends a list predicates to the FeedbackMutation builder.
func (m *FeedbackMutation) Where(ps ...predicate.Feedback) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FeedbackMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Feedback).
func (m *FeedbackMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeedbackMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.uid != nil {
		fields = append(fields, feedback.FieldUID)
	}
	if m.created_at != nil {
		fields = append(fields, feedback.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, feedback.FieldUpdatedAt)
	}
	if m.deactivated_at != nil {
		fields = append(fields, feedback.FieldDeactivatedAt)
	}
	if m.user_uid != nil {
		fields = append(fields, feedback.FieldUserUID)
	}
	if m.category != nil {
		fields = append(fields, feedback.FieldCategory)
	}
	if m.description != nil {
		fields = append(fields, feedback.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeedbackMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case feedback.FieldUID:
		return m.UID()
	case feedback.FieldCreatedAt:
		return m.CreatedAt()
	case feedback.FieldUpdatedAt:
		return m.UpdatedAt()
	case feedback.FieldDeactivatedAt:
		return m.DeactivatedAt()
	case feedback.FieldUserUID:
		return m.UserUID()
	case feedback.FieldCategory:
		return m.Category()
	case feedback.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeedbackMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case feedback.FieldUID:
		return m.OldUID(ctx)
	case feedback.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case feedback.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case feedback.FieldDeactivatedAt:
		return m.OldDeactivatedAt(ctx)
	case feedback.FieldUserUID:
		return m.OldUserUID(ctx)
	case feedback.FieldCategory:
		return m.OldCategory(ctx)
	case feedback.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Feedback field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeedbackMutation) SetField(name string, value ent.Value) error {
	switch name {
	case feedback.FieldUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case feedback.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case feedback.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case feedback.FieldDeactivatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeactivatedAt(v)
		return nil
	case feedback.FieldUserUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserUID(v)
		return nil
	case feedback.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case feedback.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Feedback field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeedbackMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeedbackMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeedbackMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Feedback numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeedbackMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(feedback.FieldDeactivatedAt) {
		fields = append(fields, feedback.FieldDeactivatedAt)
	}
	if m.FieldCleared(feedback.FieldDescription) {
		fields = append(fields, feedback.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeedbackMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeedbackMutation) ClearField(name string) error {
	switch name {
	case feedback.FieldDeactivatedAt:
		m.ClearDeactivatedAt()
		return nil
	case feedback.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Feedback nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeedbackMutation) ResetField(name string) error {
	switch name {
	case feedback.FieldUID:
		m.ResetUID()
		return nil
	case feedback.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case feedback.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case feedback.FieldDeactivatedAt:
		m.ResetDeactivatedAt()
		return nil
	case feedback.FieldUserUID:
		m.ResetUserUID()
		return nil
	case feedback.FieldCategory:
		m.ResetCategory()
		return nil
	case feedback.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Feedback field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeedbackMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeedbackMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeedbackMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeedbackMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeedbackMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeedbackMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeedbackMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Feedback unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeedbackMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Feedback edge %s", name)
}

// FocusMutation represents an operation that mutates the Focus nodes in the graph.
type FocusMutation struct {
	config
	op             Op
	typ            string
	id             *int
	uid            *string
	created_at     *time.Time
	updated_at     *time.Time
	deactivated_at *time.Time
	follower_uid   *string
	followee_uid   *string
	status         *bool
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Focus, error)
	predicates     []predicate.Focus
}

var _ ent.Mutation = (*FocusMutation)(nil)

// focusOption allows management of the mutation configuration using functional options.
type focusOption func(*FocusMutation)

// newFocusMutation creates new mutation for the Focus entity.
func newFocusMutation(c config, op Op, opts ...focusOption) *FocusMutation {
	m := &FocusMutation{
		config:        c,
		op:            op,
		typ:           TypeFocus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFocusID sets the ID field of the mutation.
func withFocusID(id int) focusOption {
	return func(m *FocusMutation) {
		var (
			err   error
			once  sync.Once
			value *Focus
		)
		m.oldValue = func(ctx context.Context) (*Focus, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Focus.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFocus sets the old Focus of the mutation.
func withFocus(node *Focus) focusOption {
	return func(m *FocusMutation) {
		m.oldValue = func(context.Context) (*Focus, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FocusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FocusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entschema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FocusMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FocusMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Focus.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUID sets the "uid" field.
func (m *FocusMutation) SetUID(s string) {
	m.uid = &s
}

// UID returns the value of the "uid" field in the mutation.
func (m *FocusMutation) UID() (r string, exists bool) {
	v := m.uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old "uid" field's value of the Focus entity.
// If the Focus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FocusMutation) OldUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// ResetUID resets all changes to the "uid" field.
func (m *FocusMutation) ResetUID() {
	m.uid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FocusMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FocusMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Focus entity.
// If the Focus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FocusMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FocusMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FocusMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FocusMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Focus entity.
// If the Focus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FocusMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FocusMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeactivatedAt sets the "deactivated_at" field.
func (m *FocusMutation) SetDeactivatedAt(t time.Time) {
	m.deactivated_at = &t
}

// DeactivatedAt returns the value of the "deactivated_at" field in the mutation.
func (m *FocusMutation) DeactivatedAt() (r time.Time, exists bool) {
	v := m.deactivated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeactivatedAt returns the old "deactivated_at" field's value of the Focus entity.
// If the Focus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FocusMutation) OldDeactivatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeactivatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeactivatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeactivatedAt: %w", err)
	}
	return oldValue.DeactivatedAt, nil
}

// ClearDeactivatedAt clears the value of the "deactivated_at" field.
func (m *FocusMutation) ClearDeactivatedAt() {
	m.deactivated_at = nil
	m.clearedFields[focus.FieldDeactivatedAt] = struct{}{}
}

// DeactivatedAtCleared returns if the "deactivated_at" field was cleared in this mutation.
func (m *FocusMutation) DeactivatedAtCleared() bool {
	_, ok := m.clearedFields[focus.FieldDeactivatedAt]
	return ok
}

// ResetDeactivatedAt resets all changes to the "deactivated_at" field.
func (m *FocusMutation) ResetDeactivatedAt() {
	m.deactivated_at = nil
	delete(m.clearedFields, focus.FieldDeactivatedAt)
}

// SetFollowerUID sets the "follower_uid" field.
func (m *FocusMutation) SetFollowerUID(s string) {
	m.follower_uid = &s
}

// FollowerUID returns the value of the "follower_uid" field in the mutation.
func (m *FocusMutation) FollowerUID() (r string, exists bool) {
	v := m.follower_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldFollowerUID returns the old "follower_uid" field's value of the Focus entity.
// If the Focus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FocusMutation) OldFollowerUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFollowerUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFollowerUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFollowerUID: %w", err)
	}
	return oldValue.FollowerUID, nil
}

// ResetFollowerUID resets all changes to the "follower_uid" field.
func (m *FocusMutation) ResetFollowerUID() {
	m.follower_uid = nil
}

// SetFolloweeUID sets the "followee_uid" field.
func (m *FocusMutation) SetFolloweeUID(s string) {
	m.followee_uid = &s
}

// FolloweeUID returns the value of the "followee_uid" field in the mutation.
func (m *FocusMutation) FolloweeUID() (r string, exists bool) {
	v := m.followee_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldFolloweeUID returns the old "followee_uid" field's value of the Focus entity.
// If the Focus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FocusMutation) OldFolloweeUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFolloweeUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFolloweeUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFolloweeUID: %w", err)
	}
	return oldValue.FolloweeUID, nil
}

// ResetFolloweeUID resets all changes to the "followee_uid" field.
func (m *FocusMutation) ResetFolloweeUID() {
	m.followee_uid = nil
}

// SetStatus sets the "status" field.
func (m *FocusMutation) SetStatus(b bool) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *FocusMutation) Status() (r bool, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Focus entity.
// If the Focus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FocusMutation) OldStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *FocusMutation) ResetStatus() {
	m.status = nil
}

// Where appends a list predicates to the FocusMutation builder.
func (m *FocusMutation) Where(ps ...predicate.Focus) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FocusMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Focus).
func (m *FocusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FocusMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.uid != nil {
		fields = append(fields, focus.FieldUID)
	}
	if m.created_at != nil {
		fields = append(fields, focus.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, focus.FieldUpdatedAt)
	}
	if m.deactivated_at != nil {
		fields = append(fields, focus.FieldDeactivatedAt)
	}
	if m.follower_uid != nil {
		fields = append(fields, focus.FieldFollowerUID)
	}
	if m.followee_uid != nil {
		fields = append(fields, focus.FieldFolloweeUID)
	}
	if m.status != nil {
		fields = append(fields, focus.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FocusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case focus.FieldUID:
		return m.UID()
	case focus.FieldCreatedAt:
		return m.CreatedAt()
	case focus.FieldUpdatedAt:
		return m.UpdatedAt()
	case focus.FieldDeactivatedAt:
		return m.DeactivatedAt()
	case focus.FieldFollowerUID:
		return m.FollowerUID()
	case focus.FieldFolloweeUID:
		return m.FolloweeUID()
	case focus.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FocusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case focus.FieldUID:
		return m.OldUID(ctx)
	case focus.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case focus.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case focus.FieldDeactivatedAt:
		return m.OldDeactivatedAt(ctx)
	case focus.FieldFollowerUID:
		return m.OldFollowerUID(ctx)
	case focus.FieldFolloweeUID:
		return m.OldFolloweeUID(ctx)
	case focus.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Focus field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FocusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case focus.FieldUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case focus.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case focus.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case focus.FieldDeactivatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeactivatedAt(v)
		return nil
	case focus.FieldFollowerUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFollowerUID(v)
		return nil
	case focus.FieldFolloweeUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFolloweeUID(v)
		return nil
	case focus.FieldStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Focus field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FocusMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FocusMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FocusMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Focus numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FocusMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(focus.FieldDeactivatedAt) {
		fields = append(fields, focus.FieldDeactivatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FocusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FocusMutation) ClearField(name string) error {
	switch name {
	case focus.FieldDeactivatedAt:
		m.ClearDeactivatedAt()
		return nil
	}
	return fmt.Errorf("unknown Focus nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FocusMutation) ResetField(name string) error {
	switch name {
	case focus.FieldUID:
		m.ResetUID()
		return nil
	case focus.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case focus.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case focus.FieldDeactivatedAt:
		m.ResetDeactivatedAt()
		return nil
	case focus.FieldFollowerUID:
		m.ResetFollowerUID()
		return nil
	case focus.FieldFolloweeUID:
		m.ResetFolloweeUID()
		return nil
	case focus.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Focus field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FocusMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FocusMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FocusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FocusMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FocusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FocusMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FocusMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Focus unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FocusMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Focus edge %s", name)
}

// GoodArticleMutation represents an operation that mutates the GoodArticle nodes in the graph.
type GoodArticleMutation struct {
	config
	op             Op
	typ            string
	id             *uint64
	uid            *string
	created_at     *time.Time
	updated_at     *time.Time
	deactivated_at *time.Time
	title          *string
	description    *string
	image          *string
	source         *string
	icon           *string
	link           *string
	star           *int
	addstar        *int
	view           *int
	addview        *int
	used           *int
	addused        *int
	user_uid       *string
	status         *string
	category_uid   *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*GoodArticle, error)
	predicates     []predicate.GoodArticle
}

var _ ent.Mutation = (*GoodArticleMutation)(nil)

// goodarticleOption allows management of the mutation configuration using functional options.
type goodarticleOption func(*GoodArticleMutation)

// newGoodArticleMutation creates new mutation for the GoodArticle entity.
func newGoodArticleMutation(c config, op Op, opts ...goodarticleOption) *GoodArticleMutation {
	m := &GoodArticleMutation{
		config:        c,
		op:            op,
		typ:           TypeGoodArticle,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGoodArticleID sets the ID field of the mutation.
func withGoodArticleID(id uint64) goodarticleOption {
	return func(m *GoodArticleMutation) {
		var (
			err   error
			once  sync.Once
			value *GoodArticle
		)
		m.oldValue = func(ctx context.Context) (*GoodArticle, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GoodArticle.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGoodArticle sets the old GoodArticle of the mutation.
func withGoodArticle(node *GoodArticle) goodarticleOption {
	return func(m *GoodArticleMutation) {
		m.oldValue = func(context.Context) (*GoodArticle, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GoodArticleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GoodArticleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entschema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GoodArticle entities.
func (m *GoodArticleMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GoodArticleMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GoodArticleMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GoodArticle.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUID sets the "uid" field.
func (m *GoodArticleMutation) SetUID(s string) {
	m.uid = &s
}

// UID returns the value of the "uid" field in the mutation.
func (m *GoodArticleMutation) UID() (r string, exists bool) {
	v := m.uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old "uid" field's value of the GoodArticle entity.
// If the GoodArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodArticleMutation) OldUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// ResetUID resets all changes to the "uid" field.
func (m *GoodArticleMutation) ResetUID() {
	m.uid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GoodArticleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GoodArticleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GoodArticle entity.
// If the GoodArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodArticleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GoodArticleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GoodArticleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GoodArticleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GoodArticle entity.
// If the GoodArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodArticleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GoodArticleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeactivatedAt sets the "deactivated_at" field.
func (m *GoodArticleMutation) SetDeactivatedAt(t time.Time) {
	m.deactivated_at = &t
}

// DeactivatedAt returns the value of the "deactivated_at" field in the mutation.
func (m *GoodArticleMutation) DeactivatedAt() (r time.Time, exists bool) {
	v := m.deactivated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeactivatedAt returns the old "deactivated_at" field's value of the GoodArticle entity.
// If the GoodArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodArticleMutation) OldDeactivatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeactivatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeactivatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeactivatedAt: %w", err)
	}
	return oldValue.DeactivatedAt, nil
}

// ClearDeactivatedAt clears the value of the "deactivated_at" field.
func (m *GoodArticleMutation) ClearDeactivatedAt() {
	m.deactivated_at = nil
	m.clearedFields[goodarticle.FieldDeactivatedAt] = struct{}{}
}

// DeactivatedAtCleared returns if the "deactivated_at" field was cleared in this mutation.
func (m *GoodArticleMutation) DeactivatedAtCleared() bool {
	_, ok := m.clearedFields[goodarticle.FieldDeactivatedAt]
	return ok
}

// ResetDeactivatedAt resets all changes to the "deactivated_at" field.
func (m *GoodArticleMutation) ResetDeactivatedAt() {
	m.deactivated_at = nil
	delete(m.clearedFields, goodarticle.FieldDeactivatedAt)
}

// SetTitle sets the "title" field.
func (m *GoodArticleMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *GoodArticleMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the GoodArticle entity.
// If the GoodArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodArticleMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *GoodArticleMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *GoodArticleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *GoodArticleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the GoodArticle entity.
// If the GoodArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodArticleMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *GoodArticleMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[goodarticle.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *GoodArticleMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[goodarticle.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *GoodArticleMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, goodarticle.FieldDescription)
}

// SetImage sets the "image" field.
func (m *GoodArticleMutation) SetImage(s string) {
	m.image = &s
}

// Image returns the value of the "image" field in the mutation.
func (m *GoodArticleMutation) Image() (r string, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the GoodArticle entity.
// If the GoodArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodArticleMutation) OldImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ClearImage clears the value of the "image" field.
func (m *GoodArticleMutation) ClearImage() {
	m.image = nil
	m.clearedFields[goodarticle.FieldImage] = struct{}{}
}

// ImageCleared returns if the "image" field was cleared in this mutation.
func (m *GoodArticleMutation) ImageCleared() bool {
	_, ok := m.clearedFields[goodarticle.FieldImage]
	return ok
}

// ResetImage resets all changes to the "image" field.
func (m *GoodArticleMutation) ResetImage() {
	m.image = nil
	delete(m.clearedFields, goodarticle.FieldImage)
}

// SetSource sets the "source" field.
func (m *GoodArticleMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *GoodArticleMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the GoodArticle entity.
// If the GoodArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodArticleMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *GoodArticleMutation) ResetSource() {
	m.source = nil
}

// SetIcon sets the "icon" field.
func (m *GoodArticleMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *GoodArticleMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the GoodArticle entity.
// If the GoodArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodArticleMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *GoodArticleMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[goodarticle.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *GoodArticleMutation) IconCleared() bool {
	_, ok := m.clearedFields[goodarticle.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *GoodArticleMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, goodarticle.FieldIcon)
}

// SetLink sets the "link" field.
func (m *GoodArticleMutation) SetLink(s string) {
	m.link = &s
}

// Link returns the value of the "link" field in the mutation.
func (m *GoodArticleMutation) Link() (r string, exists bool) {
	v := m.link
	if v == nil {
		return
	}
	return *v, true
}

// OldLink returns the old "link" field's value of the GoodArticle entity.
// If the GoodArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodArticleMutation) OldLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLink: %w", err)
	}
	return oldValue.Link, nil
}

// ResetLink resets all changes to the "link" field.
func (m *GoodArticleMutation) ResetLink() {
	m.link = nil
}

// SetStar sets the "star" field.
func (m *GoodArticleMutation) SetStar(i int) {
	m.star = &i
	m.addstar = nil
}

// Star returns the value of the "star" field in the mutation.
func (m *GoodArticleMutation) Star() (r int, exists bool) {
	v := m.star
	if v == nil {
		return
	}
	return *v, true
}

// OldStar returns the old "star" field's value of the GoodArticle entity.
// If the GoodArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodArticleMutation) OldStar(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStar: %w", err)
	}
	return oldValue.Star, nil
}

// AddStar adds i to the "star" field.
func (m *GoodArticleMutation) AddStar(i int) {
	if m.addstar != nil {
		*m.addstar += i
	} else {
		m.addstar = &i
	}
}

// AddedStar returns the value that was added to the "star" field in this mutation.
func (m *GoodArticleMutation) AddedStar() (r int, exists bool) {
	v := m.addstar
	if v == nil {
		return
	}
	return *v, true
}

// ResetStar resets all changes to the "star" field.
func (m *GoodArticleMutation) ResetStar() {
	m.star = nil
	m.addstar = nil
}

// SetView sets the "view" field.
func (m *GoodArticleMutation) SetView(i int) {
	m.view = &i
	m.addview = nil
}

// View returns the value of the "view" field in the mutation.
func (m *GoodArticleMutation) View() (r int, exists bool) {
	v := m.view
	if v == nil {
		return
	}
	return *v, true
}

// OldView returns the old "view" field's value of the GoodArticle entity.
// If the GoodArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodArticleMutation) OldView(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldView is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldView requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldView: %w", err)
	}
	return oldValue.View, nil
}

// AddView adds i to the "view" field.
func (m *GoodArticleMutation) AddView(i int) {
	if m.addview != nil {
		*m.addview += i
	} else {
		m.addview = &i
	}
}

// AddedView returns the value that was added to the "view" field in this mutation.
func (m *GoodArticleMutation) AddedView() (r int, exists bool) {
	v := m.addview
	if v == nil {
		return
	}
	return *v, true
}

// ResetView resets all changes to the "view" field.
func (m *GoodArticleMutation) ResetView() {
	m.view = nil
	m.addview = nil
}

// SetUsed sets the "used" field.
func (m *GoodArticleMutation) SetUsed(i int) {
	m.used = &i
	m.addused = nil
}

// Used returns the value of the "used" field in the mutation.
func (m *GoodArticleMutation) Used() (r int, exists bool) {
	v := m.used
	if v == nil {
		return
	}
	return *v, true
}

// OldUsed returns the old "used" field's value of the GoodArticle entity.
// If the GoodArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodArticleMutation) OldUsed(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsed: %w", err)
	}
	return oldValue.Used, nil
}

// AddUsed adds i to the "used" field.
func (m *GoodArticleMutation) AddUsed(i int) {
	if m.addused != nil {
		*m.addused += i
	} else {
		m.addused = &i
	}
}

// AddedUsed returns the value that was added to the "used" field in this mutation.
func (m *GoodArticleMutation) AddedUsed() (r int, exists bool) {
	v := m.addused
	if v == nil {
		return
	}
	return *v, true
}

// ResetUsed resets all changes to the "used" field.
func (m *GoodArticleMutation) ResetUsed() {
	m.used = nil
	m.addused = nil
}

// SetUserUID sets the "user_uid" field.
func (m *GoodArticleMutation) SetUserUID(s string) {
	m.user_uid = &s
}

// UserUID returns the value of the "user_uid" field in the mutation.
func (m *GoodArticleMutation) UserUID() (r string, exists bool) {
	v := m.user_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUserUID returns the old "user_uid" field's value of the GoodArticle entity.
// If the GoodArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodArticleMutation) OldUserUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserUID: %w", err)
	}
	return oldValue.UserUID, nil
}

// ResetUserUID resets all changes to the "user_uid" field.
func (m *GoodArticleMutation) ResetUserUID() {
	m.user_uid = nil
}

// SetStatus sets the "status" field.
func (m *GoodArticleMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *GoodArticleMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the GoodArticle entity.
// If the GoodArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodArticleMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *GoodArticleMutation) ResetStatus() {
	m.status = nil
}

// SetCategoryUID sets the "category_uid" field.
func (m *GoodArticleMutation) SetCategoryUID(s string) {
	m.category_uid = &s
}

// CategoryUID returns the value of the "category_uid" field in the mutation.
func (m *GoodArticleMutation) CategoryUID() (r string, exists bool) {
	v := m.category_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryUID returns the old "category_uid" field's value of the GoodArticle entity.
// If the GoodArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodArticleMutation) OldCategoryUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryUID: %w", err)
	}
	return oldValue.CategoryUID, nil
}

// ResetCategoryUID resets all changes to the "category_uid" field.
func (m *GoodArticleMutation) ResetCategoryUID() {
	m.category_uid = nil
}

// Where appends a list predicates to the GoodArticleMutation builder.
func (m *GoodArticleMutation) Where(ps ...predicate.GoodArticle) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GoodArticleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GoodArticle).
func (m *GoodArticleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GoodArticleMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.uid != nil {
		fields = append(fields, goodarticle.FieldUID)
	}
	if m.created_at != nil {
		fields = append(fields, goodarticle.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, goodarticle.FieldUpdatedAt)
	}
	if m.deactivated_at != nil {
		fields = append(fields, goodarticle.FieldDeactivatedAt)
	}
	if m.title != nil {
		fields = append(fields, goodarticle.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, goodarticle.FieldDescription)
	}
	if m.image != nil {
		fields = append(fields, goodarticle.FieldImage)
	}
	if m.source != nil {
		fields = append(fields, goodarticle.FieldSource)
	}
	if m.icon != nil {
		fields = append(fields, goodarticle.FieldIcon)
	}
	if m.link != nil {
		fields = append(fields, goodarticle.FieldLink)
	}
	if m.star != nil {
		fields = append(fields, goodarticle.FieldStar)
	}
	if m.view != nil {
		fields = append(fields, goodarticle.FieldView)
	}
	if m.used != nil {
		fields = append(fields, goodarticle.FieldUsed)
	}
	if m.user_uid != nil {
		fields = append(fields, goodarticle.FieldUserUID)
	}
	if m.status != nil {
		fields = append(fields, goodarticle.FieldStatus)
	}
	if m.category_uid != nil {
		fields = append(fields, goodarticle.FieldCategoryUID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GoodArticleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case goodarticle.FieldUID:
		return m.UID()
	case goodarticle.FieldCreatedAt:
		return m.CreatedAt()
	case goodarticle.FieldUpdatedAt:
		return m.UpdatedAt()
	case goodarticle.FieldDeactivatedAt:
		return m.DeactivatedAt()
	case goodarticle.FieldTitle:
		return m.Title()
	case goodarticle.FieldDescription:
		return m.Description()
	case goodarticle.FieldImage:
		return m.Image()
	case goodarticle.FieldSource:
		return m.Source()
	case goodarticle.FieldIcon:
		return m.Icon()
	case goodarticle.FieldLink:
		return m.Link()
	case goodarticle.FieldStar:
		return m.Star()
	case goodarticle.FieldView:
		return m.View()
	case goodarticle.FieldUsed:
		return m.Used()
	case goodarticle.FieldUserUID:
		return m.UserUID()
	case goodarticle.FieldStatus:
		return m.Status()
	case goodarticle.FieldCategoryUID:
		return m.CategoryUID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GoodArticleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case goodarticle.FieldUID:
		return m.OldUID(ctx)
	case goodarticle.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case goodarticle.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case goodarticle.FieldDeactivatedAt:
		return m.OldDeactivatedAt(ctx)
	case goodarticle.FieldTitle:
		return m.OldTitle(ctx)
	case goodarticle.FieldDescription:
		return m.OldDescription(ctx)
	case goodarticle.FieldImage:
		return m.OldImage(ctx)
	case goodarticle.FieldSource:
		return m.OldSource(ctx)
	case goodarticle.FieldIcon:
		return m.OldIcon(ctx)
	case goodarticle.FieldLink:
		return m.OldLink(ctx)
	case goodarticle.FieldStar:
		return m.OldStar(ctx)
	case goodarticle.FieldView:
		return m.OldView(ctx)
	case goodarticle.FieldUsed:
		return m.OldUsed(ctx)
	case goodarticle.FieldUserUID:
		return m.OldUserUID(ctx)
	case goodarticle.FieldStatus:
		return m.OldStatus(ctx)
	case goodarticle.FieldCategoryUID:
		return m.OldCategoryUID(ctx)
	}
	return nil, fmt.Errorf("unknown GoodArticle field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodArticleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case goodarticle.FieldUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case goodarticle.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case goodarticle.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case goodarticle.FieldDeactivatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeactivatedAt(v)
		return nil
	case goodarticle.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case goodarticle.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case goodarticle.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	case goodarticle.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case goodarticle.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case goodarticle.FieldLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLink(v)
		return nil
	case goodarticle.FieldStar:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStar(v)
		return nil
	case goodarticle.FieldView:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetView(v)
		return nil
	case goodarticle.FieldUsed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsed(v)
		return nil
	case goodarticle.FieldUserUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserUID(v)
		return nil
	case goodarticle.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case goodarticle.FieldCategoryUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryUID(v)
		return nil
	}
	return fmt.Errorf("unknown GoodArticle field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GoodArticleMutation) AddedFields() []string {
	var fields []string
	if m.addstar != nil {
		fields = append(fields, goodarticle.FieldStar)
	}
	if m.addview != nil {
		fields = append(fields, goodarticle.FieldView)
	}
	if m.addused != nil {
		fields = append(fields, goodarticle.FieldUsed)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GoodArticleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case goodarticle.FieldStar:
		return m.AddedStar()
	case goodarticle.FieldView:
		return m.AddedView()
	case goodarticle.FieldUsed:
		return m.AddedUsed()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodArticleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case goodarticle.FieldStar:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStar(v)
		return nil
	case goodarticle.FieldView:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddView(v)
		return nil
	case goodarticle.FieldUsed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsed(v)
		return nil
	}
	return fmt.Errorf("unknown GoodArticle numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GoodArticleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(goodarticle.FieldDeactivatedAt) {
		fields = append(fields, goodarticle.FieldDeactivatedAt)
	}
	if m.FieldCleared(goodarticle.FieldDescription) {
		fields = append(fields, goodarticle.FieldDescription)
	}
	if m.FieldCleared(goodarticle.FieldImage) {
		fields = append(fields, goodarticle.FieldImage)
	}
	if m.FieldCleared(goodarticle.FieldIcon) {
		fields = append(fields, goodarticle.FieldIcon)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GoodArticleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GoodArticleMutation) ClearField(name string) error {
	switch name {
	case goodarticle.FieldDeactivatedAt:
		m.ClearDeactivatedAt()
		return nil
	case goodarticle.FieldDescription:
		m.ClearDescription()
		return nil
	case goodarticle.FieldImage:
		m.ClearImage()
		return nil
	case goodarticle.FieldIcon:
		m.ClearIcon()
		return nil
	}
	return fmt.Errorf("unknown GoodArticle nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GoodArticleMutation) ResetField(name string) error {
	switch name {
	case goodarticle.FieldUID:
		m.ResetUID()
		return nil
	case goodarticle.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case goodarticle.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case goodarticle.FieldDeactivatedAt:
		m.ResetDeactivatedAt()
		return nil
	case goodarticle.FieldTitle:
		m.ResetTitle()
		return nil
	case goodarticle.FieldDescription:
		m.ResetDescription()
		return nil
	case goodarticle.FieldImage:
		m.ResetImage()
		return nil
	case goodarticle.FieldSource:
		m.ResetSource()
		return nil
	case goodarticle.FieldIcon:
		m.ResetIcon()
		return nil
	case goodarticle.FieldLink:
		m.ResetLink()
		return nil
	case goodarticle.FieldStar:
		m.ResetStar()
		return nil
	case goodarticle.FieldView:
		m.ResetView()
		return nil
	case goodarticle.FieldUsed:
		m.ResetUsed()
		return nil
	case goodarticle.FieldUserUID:
		m.ResetUserUID()
		return nil
	case goodarticle.FieldStatus:
		m.ResetStatus()
		return nil
	case goodarticle.FieldCategoryUID:
		m.ResetCategoryUID()
		return nil
	}
	return fmt.Errorf("unknown GoodArticle field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GoodArticleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GoodArticleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GoodArticleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GoodArticleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GoodArticleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GoodArticleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GoodArticleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GoodArticle unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GoodArticleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GoodArticle edge %s", name)
}

// GoodArticleCategoryMutation represents an operation that mutates the GoodArticleCategory nodes in the graph.
type GoodArticleCategoryMutation struct {
	config
	op             Op
	typ            string
	id             *uint64
	uid            *string
	created_at     *time.Time
	updated_at     *time.Time
	deactivated_at *time.Time
	name           *string
	status         *bool
	sequence       *int
	addsequence    *int
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*GoodArticleCategory, error)
	predicates     []predicate.GoodArticleCategory
}

var _ ent.Mutation = (*GoodArticleCategoryMutation)(nil)

// goodarticlecategoryOption allows management of the mutation configuration using functional options.
type goodarticlecategoryOption func(*GoodArticleCategoryMutation)

// newGoodArticleCategoryMutation creates new mutation for the GoodArticleCategory entity.
func newGoodArticleCategoryMutation(c config, op Op, opts ...goodarticlecategoryOption) *GoodArticleCategoryMutation {
	m := &GoodArticleCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeGoodArticleCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGoodArticleCategoryID sets the ID field of the mutation.
func withGoodArticleCategoryID(id uint64) goodarticlecategoryOption {
	return func(m *GoodArticleCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *GoodArticleCategory
		)
		m.oldValue = func(ctx context.Context) (*GoodArticleCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GoodArticleCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGoodArticleCategory sets the old GoodArticleCategory of the mutation.
func withGoodArticleCategory(node *GoodArticleCategory) goodarticlecategoryOption {
	return func(m *GoodArticleCategoryMutation) {
		m.oldValue = func(context.Context) (*GoodArticleCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GoodArticleCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GoodArticleCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entschema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GoodArticleCategory entities.
func (m *GoodArticleCategoryMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GoodArticleCategoryMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GoodArticleCategoryMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GoodArticleCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUID sets the "uid" field.
func (m *GoodArticleCategoryMutation) SetUID(s string) {
	m.uid = &s
}

// UID returns the value of the "uid" field in the mutation.
func (m *GoodArticleCategoryMutation) UID() (r string, exists bool) {
	v := m.uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old "uid" field's value of the GoodArticleCategory entity.
// If the GoodArticleCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodArticleCategoryMutation) OldUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// ResetUID resets all changes to the "uid" field.
func (m *GoodArticleCategoryMutation) ResetUID() {
	m.uid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GoodArticleCategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GoodArticleCategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GoodArticleCategory entity.
// If the GoodArticleCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodArticleCategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GoodArticleCategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GoodArticleCategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GoodArticleCategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GoodArticleCategory entity.
// If the GoodArticleCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodArticleCategoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GoodArticleCategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeactivatedAt sets the "deactivated_at" field.
func (m *GoodArticleCategoryMutation) SetDeactivatedAt(t time.Time) {
	m.deactivated_at = &t
}

// DeactivatedAt returns the value of the "deactivated_at" field in the mutation.
func (m *GoodArticleCategoryMutation) DeactivatedAt() (r time.Time, exists bool) {
	v := m.deactivated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeactivatedAt returns the old "deactivated_at" field's value of the GoodArticleCategory entity.
// If the GoodArticleCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodArticleCategoryMutation) OldDeactivatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeactivatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeactivatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeactivatedAt: %w", err)
	}
	return oldValue.DeactivatedAt, nil
}

// ClearDeactivatedAt clears the value of the "deactivated_at" field.
func (m *GoodArticleCategoryMutation) ClearDeactivatedAt() {
	m.deactivated_at = nil
	m.clearedFields[goodarticlecategory.FieldDeactivatedAt] = struct{}{}
}

// DeactivatedAtCleared returns if the "deactivated_at" field was cleared in this mutation.
func (m *GoodArticleCategoryMutation) DeactivatedAtCleared() bool {
	_, ok := m.clearedFields[goodarticlecategory.FieldDeactivatedAt]
	return ok
}

// ResetDeactivatedAt resets all changes to the "deactivated_at" field.
func (m *GoodArticleCategoryMutation) ResetDeactivatedAt() {
	m.deactivated_at = nil
	delete(m.clearedFields, goodarticlecategory.FieldDeactivatedAt)
}

// SetName sets the "name" field.
func (m *GoodArticleCategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GoodArticleCategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the GoodArticleCategory entity.
// If the GoodArticleCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodArticleCategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *GoodArticleCategoryMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the "status" field.
func (m *GoodArticleCategoryMutation) SetStatus(b bool) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *GoodArticleCategoryMutation) Status() (r bool, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the GoodArticleCategory entity.
// If the GoodArticleCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodArticleCategoryMutation) OldStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *GoodArticleCategoryMutation) ResetStatus() {
	m.status = nil
}

// SetSequence sets the "sequence" field.
func (m *GoodArticleCategoryMutation) SetSequence(i int) {
	m.sequence = &i
	m.addsequence = nil
}

// Sequence returns the value of the "sequence" field in the mutation.
func (m *GoodArticleCategoryMutation) Sequence() (r int, exists bool) {
	v := m.sequence
	if v == nil {
		return
	}
	return *v, true
}

// OldSequence returns the old "sequence" field's value of the GoodArticleCategory entity.
// If the GoodArticleCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodArticleCategoryMutation) OldSequence(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSequence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSequence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSequence: %w", err)
	}
	return oldValue.Sequence, nil
}

// AddSequence adds i to the "sequence" field.
func (m *GoodArticleCategoryMutation) AddSequence(i int) {
	if m.addsequence != nil {
		*m.addsequence += i
	} else {
		m.addsequence = &i
	}
}

// AddedSequence returns the value that was added to the "sequence" field in this mutation.
func (m *GoodArticleCategoryMutation) AddedSequence() (r int, exists bool) {
	v := m.addsequence
	if v == nil {
		return
	}
	return *v, true
}

// ResetSequence resets all changes to the "sequence" field.
func (m *GoodArticleCategoryMutation) ResetSequence() {
	m.sequence = nil
	m.addsequence = nil
}

// Where appends a list predicates to the GoodArticleCategoryMutation builder.
func (m *GoodArticleCategoryMutation) Where(ps ...predicate.GoodArticleCategory) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GoodArticleCategoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GoodArticleCategory).
func (m *GoodArticleCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GoodArticleCategoryMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.uid != nil {
		fields = append(fields, goodarticlecategory.FieldUID)
	}
	if m.created_at != nil {
		fields = append(fields, goodarticlecategory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, goodarticlecategory.FieldUpdatedAt)
	}
	if m.deactivated_at != nil {
		fields = append(fields, goodarticlecategory.FieldDeactivatedAt)
	}
	if m.name != nil {
		fields = append(fields, goodarticlecategory.FieldName)
	}
	if m.status != nil {
		fields = append(fields, goodarticlecategory.FieldStatus)
	}
	if m.sequence != nil {
		fields = append(fields, goodarticlecategory.FieldSequence)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GoodArticleCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case goodarticlecategory.FieldUID:
		return m.UID()
	case goodarticlecategory.FieldCreatedAt:
		return m.CreatedAt()
	case goodarticlecategory.FieldUpdatedAt:
		return m.UpdatedAt()
	case goodarticlecategory.FieldDeactivatedAt:
		return m.DeactivatedAt()
	case goodarticlecategory.FieldName:
		return m.Name()
	case goodarticlecategory.FieldStatus:
		return m.Status()
	case goodarticlecategory.FieldSequence:
		return m.Sequence()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GoodArticleCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case goodarticlecategory.FieldUID:
		return m.OldUID(ctx)
	case goodarticlecategory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case goodarticlecategory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case goodarticlecategory.FieldDeactivatedAt:
		return m.OldDeactivatedAt(ctx)
	case goodarticlecategory.FieldName:
		return m.OldName(ctx)
	case goodarticlecategory.FieldStatus:
		return m.OldStatus(ctx)
	case goodarticlecategory.FieldSequence:
		return m.OldSequence(ctx)
	}
	return nil, fmt.Errorf("unknown GoodArticleCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodArticleCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case goodarticlecategory.FieldUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case goodarticlecategory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case goodarticlecategory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case goodarticlecategory.FieldDeactivatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeactivatedAt(v)
		return nil
	case goodarticlecategory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case goodarticlecategory.FieldStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case goodarticlecategory.FieldSequence:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSequence(v)
		return nil
	}
	return fmt.Errorf("unknown GoodArticleCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GoodArticleCategoryMutation) AddedFields() []string {
	var fields []string
	if m.addsequence != nil {
		fields = append(fields, goodarticlecategory.FieldSequence)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GoodArticleCategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case goodarticlecategory.FieldSequence:
		return m.AddedSequence()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodArticleCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case goodarticlecategory.FieldSequence:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSequence(v)
		return nil
	}
	return fmt.Errorf("unknown GoodArticleCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GoodArticleCategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(goodarticlecategory.FieldDeactivatedAt) {
		fields = append(fields, goodarticlecategory.FieldDeactivatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GoodArticleCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GoodArticleCategoryMutation) ClearField(name string) error {
	switch name {
	case goodarticlecategory.FieldDeactivatedAt:
		m.ClearDeactivatedAt()
		return nil
	}
	return fmt.Errorf("unknown GoodArticleCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GoodArticleCategoryMutation) ResetField(name string) error {
	switch name {
	case goodarticlecategory.FieldUID:
		m.ResetUID()
		return nil
	case goodarticlecategory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case goodarticlecategory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case goodarticlecategory.FieldDeactivatedAt:
		m.ResetDeactivatedAt()
		return nil
	case goodarticlecategory.FieldName:
		m.ResetName()
		return nil
	case goodarticlecategory.FieldStatus:
		m.ResetStatus()
		return nil
	case goodarticlecategory.FieldSequence:
		m.ResetSequence()
		return nil
	}
	return fmt.Errorf("unknown GoodArticleCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GoodArticleCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GoodArticleCategoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GoodArticleCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GoodArticleCategoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GoodArticleCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GoodArticleCategoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GoodArticleCategoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GoodArticleCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GoodArticleCategoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GoodArticleCategory edge %s", name)
}

// GoodArticleHotMutation represents an operation that mutates the GoodArticleHot nodes in the graph.
type GoodArticleHotMutation struct {
	config
	op             Op
	typ            string
	id             *uint64
	uid            *string
	created_at     *time.Time
	updated_at     *time.Time
	deactivated_at *time.Time
	article_uid    *string
	has_expired    *bool
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*GoodArticleHot, error)
	predicates     []predicate.GoodArticleHot
}

var _ ent.Mutation = (*GoodArticleHotMutation)(nil)

// goodarticlehotOption allows management of the mutation configuration using functional options.
type goodarticlehotOption func(*GoodArticleHotMutation)

// newGoodArticleHotMutation creates new mutation for the GoodArticleHot entity.
func newGoodArticleHotMutation(c config, op Op, opts ...goodarticlehotOption) *GoodArticleHotMutation {
	m := &GoodArticleHotMutation{
		config:        c,
		op:            op,
		typ:           TypeGoodArticleHot,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGoodArticleHotID sets the ID field of the mutation.
func withGoodArticleHotID(id uint64) goodarticlehotOption {
	return func(m *GoodArticleHotMutation) {
		var (
			err   error
			once  sync.Once
			value *GoodArticleHot
		)
		m.oldValue = func(ctx context.Context) (*GoodArticleHot, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GoodArticleHot.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGoodArticleHot sets the old GoodArticleHot of the mutation.
func withGoodArticleHot(node *GoodArticleHot) goodarticlehotOption {
	return func(m *GoodArticleHotMutation) {
		m.oldValue = func(context.Context) (*GoodArticleHot, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GoodArticleHotMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GoodArticleHotMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entschema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GoodArticleHot entities.
func (m *GoodArticleHotMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GoodArticleHotMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GoodArticleHotMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GoodArticleHot.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUID sets the "uid" field.
func (m *GoodArticleHotMutation) SetUID(s string) {
	m.uid = &s
}

// UID returns the value of the "uid" field in the mutation.
func (m *GoodArticleHotMutation) UID() (r string, exists bool) {
	v := m.uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old "uid" field's value of the GoodArticleHot entity.
// If the GoodArticleHot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodArticleHotMutation) OldUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// ResetUID resets all changes to the "uid" field.
func (m *GoodArticleHotMutation) ResetUID() {
	m.uid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GoodArticleHotMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GoodArticleHotMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GoodArticleHot entity.
// If the GoodArticleHot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodArticleHotMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GoodArticleHotMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GoodArticleHotMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GoodArticleHotMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GoodArticleHot entity.
// If the GoodArticleHot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodArticleHotMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GoodArticleHotMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeactivatedAt sets the "deactivated_at" field.
func (m *GoodArticleHotMutation) SetDeactivatedAt(t time.Time) {
	m.deactivated_at = &t
}

// DeactivatedAt returns the value of the "deactivated_at" field in the mutation.
func (m *GoodArticleHotMutation) DeactivatedAt() (r time.Time, exists bool) {
	v := m.deactivated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeactivatedAt returns the old "deactivated_at" field's value of the GoodArticleHot entity.
// If the GoodArticleHot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodArticleHotMutation) OldDeactivatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeactivatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeactivatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeactivatedAt: %w", err)
	}
	return oldValue.DeactivatedAt, nil
}

// ClearDeactivatedAt clears the value of the "deactivated_at" field.
func (m *GoodArticleHotMutation) ClearDeactivatedAt() {
	m.deactivated_at = nil
	m.clearedFields[goodarticlehot.FieldDeactivatedAt] = struct{}{}
}

// DeactivatedAtCleared returns if the "deactivated_at" field was cleared in this mutation.
func (m *GoodArticleHotMutation) DeactivatedAtCleared() bool {
	_, ok := m.clearedFields[goodarticlehot.FieldDeactivatedAt]
	return ok
}

// ResetDeactivatedAt resets all changes to the "deactivated_at" field.
func (m *GoodArticleHotMutation) ResetDeactivatedAt() {
	m.deactivated_at = nil
	delete(m.clearedFields, goodarticlehot.FieldDeactivatedAt)
}

// SetArticleUID sets the "article_uid" field.
func (m *GoodArticleHotMutation) SetArticleUID(s string) {
	m.article_uid = &s
}

// ArticleUID returns the value of the "article_uid" field in the mutation.
func (m *GoodArticleHotMutation) ArticleUID() (r string, exists bool) {
	v := m.article_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldArticleUID returns the old "article_uid" field's value of the GoodArticleHot entity.
// If the GoodArticleHot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodArticleHotMutation) OldArticleUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArticleUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArticleUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArticleUID: %w", err)
	}
	return oldValue.ArticleUID, nil
}

// ResetArticleUID resets all changes to the "article_uid" field.
func (m *GoodArticleHotMutation) ResetArticleUID() {
	m.article_uid = nil
}

// SetHasExpired sets the "has_expired" field.
func (m *GoodArticleHotMutation) SetHasExpired(b bool) {
	m.has_expired = &b
}

// HasExpired returns the value of the "has_expired" field in the mutation.
func (m *GoodArticleHotMutation) HasExpired() (r bool, exists bool) {
	v := m.has_expired
	if v == nil {
		return
	}
	return *v, true
}

// OldHasExpired returns the old "has_expired" field's value of the GoodArticleHot entity.
// If the GoodArticleHot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodArticleHotMutation) OldHasExpired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasExpired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasExpired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasExpired: %w", err)
	}
	return oldValue.HasExpired, nil
}

// ResetHasExpired resets all changes to the "has_expired" field.
func (m *GoodArticleHotMutation) ResetHasExpired() {
	m.has_expired = nil
}

// Where appends a list predicates to the GoodArticleHotMutation builder.
func (m *GoodArticleHotMutation) Where(ps ...predicate.GoodArticleHot) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GoodArticleHotMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GoodArticleHot).
func (m *GoodArticleHotMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GoodArticleHotMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.uid != nil {
		fields = append(fields, goodarticlehot.FieldUID)
	}
	if m.created_at != nil {
		fields = append(fields, goodarticlehot.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, goodarticlehot.FieldUpdatedAt)
	}
	if m.deactivated_at != nil {
		fields = append(fields, goodarticlehot.FieldDeactivatedAt)
	}
	if m.article_uid != nil {
		fields = append(fields, goodarticlehot.FieldArticleUID)
	}
	if m.has_expired != nil {
		fields = append(fields, goodarticlehot.FieldHasExpired)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GoodArticleHotMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case goodarticlehot.FieldUID:
		return m.UID()
	case goodarticlehot.FieldCreatedAt:
		return m.CreatedAt()
	case goodarticlehot.FieldUpdatedAt:
		return m.UpdatedAt()
	case goodarticlehot.FieldDeactivatedAt:
		return m.DeactivatedAt()
	case goodarticlehot.FieldArticleUID:
		return m.ArticleUID()
	case goodarticlehot.FieldHasExpired:
		return m.HasExpired()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GoodArticleHotMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case goodarticlehot.FieldUID:
		return m.OldUID(ctx)
	case goodarticlehot.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case goodarticlehot.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case goodarticlehot.FieldDeactivatedAt:
		return m.OldDeactivatedAt(ctx)
	case goodarticlehot.FieldArticleUID:
		return m.OldArticleUID(ctx)
	case goodarticlehot.FieldHasExpired:
		return m.OldHasExpired(ctx)
	}
	return nil, fmt.Errorf("unknown GoodArticleHot field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodArticleHotMutation) SetField(name string, value ent.Value) error {
	switch name {
	case goodarticlehot.FieldUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case goodarticlehot.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case goodarticlehot.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case goodarticlehot.FieldDeactivatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeactivatedAt(v)
		return nil
	case goodarticlehot.FieldArticleUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArticleUID(v)
		return nil
	case goodarticlehot.FieldHasExpired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasExpired(v)
		return nil
	}
	return fmt.Errorf("unknown GoodArticleHot field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GoodArticleHotMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GoodArticleHotMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodArticleHotMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GoodArticleHot numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GoodArticleHotMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(goodarticlehot.FieldDeactivatedAt) {
		fields = append(fields, goodarticlehot.FieldDeactivatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GoodArticleHotMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GoodArticleHotMutation) ClearField(name string) error {
	switch name {
	case goodarticlehot.FieldDeactivatedAt:
		m.ClearDeactivatedAt()
		return nil
	}
	return fmt.Errorf("unknown GoodArticleHot nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GoodArticleHotMutation) ResetField(name string) error {
	switch name {
	case goodarticlehot.FieldUID:
		m.ResetUID()
		return nil
	case goodarticlehot.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case goodarticlehot.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case goodarticlehot.FieldDeactivatedAt:
		m.ResetDeactivatedAt()
		return nil
	case goodarticlehot.FieldArticleUID:
		m.ResetArticleUID()
		return nil
	case goodarticlehot.FieldHasExpired:
		m.ResetHasExpired()
		return nil
	}
	return fmt.Errorf("unknown GoodArticleHot field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GoodArticleHotMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GoodArticleHotMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GoodArticleHotMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GoodArticleHotMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GoodArticleHotMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GoodArticleHotMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GoodArticleHotMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GoodArticleHot unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GoodArticleHotMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GoodArticleHot edge %s", name)
}

// GoodArticleMetaMutation represents an operation that mutates the GoodArticleMeta nodes in the graph.
type GoodArticleMetaMutation struct {
	config
	op             Op
	typ            string
	id             *uint64
	uid            *string
	created_at     *time.Time
	updated_at     *time.Time
	deactivated_at *time.Time
	article_uid    *string
	user_uid       *string
	has_star       *bool
	has_view       *bool
	has_used       *bool
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*GoodArticleMeta, error)
	predicates     []predicate.GoodArticleMeta
}

var _ ent.Mutation = (*GoodArticleMetaMutation)(nil)

// goodarticlemetaOption allows management of the mutation configuration using functional options.
type goodarticlemetaOption func(*GoodArticleMetaMutation)

// newGoodArticleMetaMutation creates new mutation for the GoodArticleMeta entity.
func newGoodArticleMetaMutation(c config, op Op, opts ...goodarticlemetaOption) *GoodArticleMetaMutation {
	m := &GoodArticleMetaMutation{
		config:        c,
		op:            op,
		typ:           TypeGoodArticleMeta,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGoodArticleMetaID sets the ID field of the mutation.
func withGoodArticleMetaID(id uint64) goodarticlemetaOption {
	return func(m *GoodArticleMetaMutation) {
		var (
			err   error
			once  sync.Once
			value *GoodArticleMeta
		)
		m.oldValue = func(ctx context.Context) (*GoodArticleMeta, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GoodArticleMeta.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGoodArticleMeta sets the old GoodArticleMeta of the mutation.
func withGoodArticleMeta(node *GoodArticleMeta) goodarticlemetaOption {
	return func(m *GoodArticleMetaMutation) {
		m.oldValue = func(context.Context) (*GoodArticleMeta, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GoodArticleMetaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GoodArticleMetaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entschema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GoodArticleMeta entities.
func (m *GoodArticleMetaMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GoodArticleMetaMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GoodArticleMetaMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GoodArticleMeta.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUID sets the "uid" field.
func (m *GoodArticleMetaMutation) SetUID(s string) {
	m.uid = &s
}

// UID returns the value of the "uid" field in the mutation.
func (m *GoodArticleMetaMutation) UID() (r string, exists bool) {
	v := m.uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old "uid" field's value of the GoodArticleMeta entity.
// If the GoodArticleMeta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodArticleMetaMutation) OldUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// ResetUID resets all changes to the "uid" field.
func (m *GoodArticleMetaMutation) ResetUID() {
	m.uid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GoodArticleMetaMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GoodArticleMetaMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GoodArticleMeta entity.
// If the GoodArticleMeta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodArticleMetaMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GoodArticleMetaMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GoodArticleMetaMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GoodArticleMetaMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GoodArticleMeta entity.
// If the GoodArticleMeta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodArticleMetaMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GoodArticleMetaMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeactivatedAt sets the "deactivated_at" field.
func (m *GoodArticleMetaMutation) SetDeactivatedAt(t time.Time) {
	m.deactivated_at = &t
}

// DeactivatedAt returns the value of the "deactivated_at" field in the mutation.
func (m *GoodArticleMetaMutation) DeactivatedAt() (r time.Time, exists bool) {
	v := m.deactivated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeactivatedAt returns the old "deactivated_at" field's value of the GoodArticleMeta entity.
// If the GoodArticleMeta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodArticleMetaMutation) OldDeactivatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeactivatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeactivatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeactivatedAt: %w", err)
	}
	return oldValue.DeactivatedAt, nil
}

// ClearDeactivatedAt clears the value of the "deactivated_at" field.
func (m *GoodArticleMetaMutation) ClearDeactivatedAt() {
	m.deactivated_at = nil
	m.clearedFields[goodarticlemeta.FieldDeactivatedAt] = struct{}{}
}

// DeactivatedAtCleared returns if the "deactivated_at" field was cleared in this mutation.
func (m *GoodArticleMetaMutation) DeactivatedAtCleared() bool {
	_, ok := m.clearedFields[goodarticlemeta.FieldDeactivatedAt]
	return ok
}

// ResetDeactivatedAt resets all changes to the "deactivated_at" field.
func (m *GoodArticleMetaMutation) ResetDeactivatedAt() {
	m.deactivated_at = nil
	delete(m.clearedFields, goodarticlemeta.FieldDeactivatedAt)
}

// SetArticleUID sets the "article_uid" field.
func (m *GoodArticleMetaMutation) SetArticleUID(s string) {
	m.article_uid = &s
}

// ArticleUID returns the value of the "article_uid" field in the mutation.
func (m *GoodArticleMetaMutation) ArticleUID() (r string, exists bool) {
	v := m.article_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldArticleUID returns the old "article_uid" field's value of the GoodArticleMeta entity.
// If the GoodArticleMeta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodArticleMetaMutation) OldArticleUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArticleUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArticleUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArticleUID: %w", err)
	}
	return oldValue.ArticleUID, nil
}

// ResetArticleUID resets all changes to the "article_uid" field.
func (m *GoodArticleMetaMutation) ResetArticleUID() {
	m.article_uid = nil
}

// SetUserUID sets the "user_uid" field.
func (m *GoodArticleMetaMutation) SetUserUID(s string) {
	m.user_uid = &s
}

// UserUID returns the value of the "user_uid" field in the mutation.
func (m *GoodArticleMetaMutation) UserUID() (r string, exists bool) {
	v := m.user_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUserUID returns the old "user_uid" field's value of the GoodArticleMeta entity.
// If the GoodArticleMeta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodArticleMetaMutation) OldUserUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserUID: %w", err)
	}
	return oldValue.UserUID, nil
}

// ResetUserUID resets all changes to the "user_uid" field.
func (m *GoodArticleMetaMutation) ResetUserUID() {
	m.user_uid = nil
}

// SetHasStar sets the "has_star" field.
func (m *GoodArticleMetaMutation) SetHasStar(b bool) {
	m.has_star = &b
}

// HasStar returns the value of the "has_star" field in the mutation.
func (m *GoodArticleMetaMutation) HasStar() (r bool, exists bool) {
	v := m.has_star
	if v == nil {
		return
	}
	return *v, true
}

// OldHasStar returns the old "has_star" field's value of the GoodArticleMeta entity.
// If the GoodArticleMeta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodArticleMetaMutation) OldHasStar(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasStar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasStar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasStar: %w", err)
	}
	return oldValue.HasStar, nil
}

// ResetHasStar resets all changes to the "has_star" field.
func (m *GoodArticleMetaMutation) ResetHasStar() {
	m.has_star = nil
}

// SetHasView sets the "has_view" field.
func (m *GoodArticleMetaMutation) SetHasView(b bool) {
	m.has_view = &b
}

// HasView returns the value of the "has_view" field in the mutation.
func (m *GoodArticleMetaMutation) HasView() (r bool, exists bool) {
	v := m.has_view
	if v == nil {
		return
	}
	return *v, true
}

// OldHasView returns the old "has_view" field's value of the GoodArticleMeta entity.
// If the GoodArticleMeta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodArticleMetaMutation) OldHasView(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasView is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasView requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasView: %w", err)
	}
	return oldValue.HasView, nil
}

// ResetHasView resets all changes to the "has_view" field.
func (m *GoodArticleMetaMutation) ResetHasView() {
	m.has_view = nil
}

// SetHasUsed sets the "has_used" field.
func (m *GoodArticleMetaMutation) SetHasUsed(b bool) {
	m.has_used = &b
}

// HasUsed returns the value of the "has_used" field in the mutation.
func (m *GoodArticleMetaMutation) HasUsed() (r bool, exists bool) {
	v := m.has_used
	if v == nil {
		return
	}
	return *v, true
}

// OldHasUsed returns the old "has_used" field's value of the GoodArticleMeta entity.
// If the GoodArticleMeta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodArticleMetaMutation) OldHasUsed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasUsed: %w", err)
	}
	return oldValue.HasUsed, nil
}

// ResetHasUsed resets all changes to the "has_used" field.
func (m *GoodArticleMetaMutation) ResetHasUsed() {
	m.has_used = nil
}

// Where appends a list predicates to the GoodArticleMetaMutation builder.
func (m *GoodArticleMetaMutation) Where(ps ...predicate.GoodArticleMeta) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GoodArticleMetaMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GoodArticleMeta).
func (m *GoodArticleMetaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GoodArticleMetaMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.uid != nil {
		fields = append(fields, goodarticlemeta.FieldUID)
	}
	if m.created_at != nil {
		fields = append(fields, goodarticlemeta.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, goodarticlemeta.FieldUpdatedAt)
	}
	if m.deactivated_at != nil {
		fields = append(fields, goodarticlemeta.FieldDeactivatedAt)
	}
	if m.article_uid != nil {
		fields = append(fields, goodarticlemeta.FieldArticleUID)
	}
	if m.user_uid != nil {
		fields = append(fields, goodarticlemeta.FieldUserUID)
	}
	if m.has_star != nil {
		fields = append(fields, goodarticlemeta.FieldHasStar)
	}
	if m.has_view != nil {
		fields = append(fields, goodarticlemeta.FieldHasView)
	}
	if m.has_used != nil {
		fields = append(fields, goodarticlemeta.FieldHasUsed)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GoodArticleMetaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case goodarticlemeta.FieldUID:
		return m.UID()
	case goodarticlemeta.FieldCreatedAt:
		return m.CreatedAt()
	case goodarticlemeta.FieldUpdatedAt:
		return m.UpdatedAt()
	case goodarticlemeta.FieldDeactivatedAt:
		return m.DeactivatedAt()
	case goodarticlemeta.FieldArticleUID:
		return m.ArticleUID()
	case goodarticlemeta.FieldUserUID:
		return m.UserUID()
	case goodarticlemeta.FieldHasStar:
		return m.HasStar()
	case goodarticlemeta.FieldHasView:
		return m.HasView()
	case goodarticlemeta.FieldHasUsed:
		return m.HasUsed()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GoodArticleMetaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case goodarticlemeta.FieldUID:
		return m.OldUID(ctx)
	case goodarticlemeta.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case goodarticlemeta.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case goodarticlemeta.FieldDeactivatedAt:
		return m.OldDeactivatedAt(ctx)
	case goodarticlemeta.FieldArticleUID:
		return m.OldArticleUID(ctx)
	case goodarticlemeta.FieldUserUID:
		return m.OldUserUID(ctx)
	case goodarticlemeta.FieldHasStar:
		return m.OldHasStar(ctx)
	case goodarticlemeta.FieldHasView:
		return m.OldHasView(ctx)
	case goodarticlemeta.FieldHasUsed:
		return m.OldHasUsed(ctx)
	}
	return nil, fmt.Errorf("unknown GoodArticleMeta field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodArticleMetaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case goodarticlemeta.FieldUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case goodarticlemeta.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case goodarticlemeta.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case goodarticlemeta.FieldDeactivatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeactivatedAt(v)
		return nil
	case goodarticlemeta.FieldArticleUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArticleUID(v)
		return nil
	case goodarticlemeta.FieldUserUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserUID(v)
		return nil
	case goodarticlemeta.FieldHasStar:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasStar(v)
		return nil
	case goodarticlemeta.FieldHasView:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasView(v)
		return nil
	case goodarticlemeta.FieldHasUsed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasUsed(v)
		return nil
	}
	return fmt.Errorf("unknown GoodArticleMeta field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GoodArticleMetaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GoodArticleMetaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodArticleMetaMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GoodArticleMeta numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GoodArticleMetaMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(goodarticlemeta.FieldDeactivatedAt) {
		fields = append(fields, goodarticlemeta.FieldDeactivatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GoodArticleMetaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GoodArticleMetaMutation) ClearField(name string) error {
	switch name {
	case goodarticlemeta.FieldDeactivatedAt:
		m.ClearDeactivatedAt()
		return nil
	}
	return fmt.Errorf("unknown GoodArticleMeta nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GoodArticleMetaMutation) ResetField(name string) error {
	switch name {
	case goodarticlemeta.FieldUID:
		m.ResetUID()
		return nil
	case goodarticlemeta.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case goodarticlemeta.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case goodarticlemeta.FieldDeactivatedAt:
		m.ResetDeactivatedAt()
		return nil
	case goodarticlemeta.FieldArticleUID:
		m.ResetArticleUID()
		return nil
	case goodarticlemeta.FieldUserUID:
		m.ResetUserUID()
		return nil
	case goodarticlemeta.FieldHasStar:
		m.ResetHasStar()
		return nil
	case goodarticlemeta.FieldHasView:
		m.ResetHasView()
		return nil
	case goodarticlemeta.FieldHasUsed:
		m.ResetHasUsed()
		return nil
	}
	return fmt.Errorf("unknown GoodArticleMeta field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GoodArticleMetaMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GoodArticleMetaMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GoodArticleMetaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GoodArticleMetaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GoodArticleMetaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GoodArticleMetaMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GoodArticleMetaMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GoodArticleMeta unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GoodArticleMetaMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GoodArticleMeta edge %s", name)
}

// InviteMutation represents an operation that mutates the Invite nodes in the graph.
type InviteMutation struct {
	config
	op             Op
	typ            string
	id             *uint64
	uid            *string
	created_at     *time.Time
	updated_at     *time.Time
	deactivated_at *time.Time
	referral_uid   *string
	referee_uid    *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Invite, error)
	predicates     []predicate.Invite
}

var _ ent.Mutation = (*InviteMutation)(nil)

// inviteOption allows management of the mutation configuration using functional options.
type inviteOption func(*InviteMutation)

// newInviteMutation creates new mutation for the Invite entity.
func newInviteMutation(c config, op Op, opts ...inviteOption) *InviteMutation {
	m := &InviteMutation{
		config:        c,
		op:            op,
		typ:           TypeInvite,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInviteID sets the ID field of the mutation.
func withInviteID(id uint64) inviteOption {
	return func(m *InviteMutation) {
		var (
			err   error
			once  sync.Once
			value *Invite
		)
		m.oldValue = func(ctx context.Context) (*Invite, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Invite.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvite sets the old Invite of the mutation.
func withInvite(node *Invite) inviteOption {
	return func(m *InviteMutation) {
		m.oldValue = func(context.Context) (*Invite, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InviteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InviteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entschema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Invite entities.
func (m *InviteMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InviteMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InviteMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Invite.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUID sets the "uid" field.
func (m *InviteMutation) SetUID(s string) {
	m.uid = &s
}

// UID returns the value of the "uid" field in the mutation.
func (m *InviteMutation) UID() (r string, exists bool) {
	v := m.uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old "uid" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// ResetUID resets all changes to the "uid" field.
func (m *InviteMutation) ResetUID() {
	m.uid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *InviteMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InviteMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InviteMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InviteMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InviteMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InviteMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeactivatedAt sets the "deactivated_at" field.
func (m *InviteMutation) SetDeactivatedAt(t time.Time) {
	m.deactivated_at = &t
}

// DeactivatedAt returns the value of the "deactivated_at" field in the mutation.
func (m *InviteMutation) DeactivatedAt() (r time.Time, exists bool) {
	v := m.deactivated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeactivatedAt returns the old "deactivated_at" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldDeactivatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeactivatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeactivatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeactivatedAt: %w", err)
	}
	return oldValue.DeactivatedAt, nil
}

// ClearDeactivatedAt clears the value of the "deactivated_at" field.
func (m *InviteMutation) ClearDeactivatedAt() {
	m.deactivated_at = nil
	m.clearedFields[invite.FieldDeactivatedAt] = struct{}{}
}

// DeactivatedAtCleared returns if the "deactivated_at" field was cleared in this mutation.
func (m *InviteMutation) DeactivatedAtCleared() bool {
	_, ok := m.clearedFields[invite.FieldDeactivatedAt]
	return ok
}

// ResetDeactivatedAt resets all changes to the "deactivated_at" field.
func (m *InviteMutation) ResetDeactivatedAt() {
	m.deactivated_at = nil
	delete(m.clearedFields, invite.FieldDeactivatedAt)
}

// SetReferralUID sets the "referral_uid" field.
func (m *InviteMutation) SetReferralUID(s string) {
	m.referral_uid = &s
}

// ReferralUID returns the value of the "referral_uid" field in the mutation.
func (m *InviteMutation) ReferralUID() (r string, exists bool) {
	v := m.referral_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldReferralUID returns the old "referral_uid" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldReferralUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferralUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferralUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferralUID: %w", err)
	}
	return oldValue.ReferralUID, nil
}

// ResetReferralUID resets all changes to the "referral_uid" field.
func (m *InviteMutation) ResetReferralUID() {
	m.referral_uid = nil
}

// SetRefereeUID sets the "referee_uid" field.
func (m *InviteMutation) SetRefereeUID(s string) {
	m.referee_uid = &s
}

// RefereeUID returns the value of the "referee_uid" field in the mutation.
func (m *InviteMutation) RefereeUID() (r string, exists bool) {
	v := m.referee_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldRefereeUID returns the old "referee_uid" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldRefereeUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefereeUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefereeUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefereeUID: %w", err)
	}
	return oldValue.RefereeUID, nil
}

// ResetRefereeUID resets all changes to the "referee_uid" field.
func (m *InviteMutation) ResetRefereeUID() {
	m.referee_uid = nil
}

// Where appends a list predicates to the InviteMutation builder.
func (m *InviteMutation) Where(ps ...predicate.Invite) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *InviteMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Invite).
func (m *InviteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InviteMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.uid != nil {
		fields = append(fields, invite.FieldUID)
	}
	if m.created_at != nil {
		fields = append(fields, invite.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, invite.FieldUpdatedAt)
	}
	if m.deactivated_at != nil {
		fields = append(fields, invite.FieldDeactivatedAt)
	}
	if m.referral_uid != nil {
		fields = append(fields, invite.FieldReferralUID)
	}
	if m.referee_uid != nil {
		fields = append(fields, invite.FieldRefereeUID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InviteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case invite.FieldUID:
		return m.UID()
	case invite.FieldCreatedAt:
		return m.CreatedAt()
	case invite.FieldUpdatedAt:
		return m.UpdatedAt()
	case invite.FieldDeactivatedAt:
		return m.DeactivatedAt()
	case invite.FieldReferralUID:
		return m.ReferralUID()
	case invite.FieldRefereeUID:
		return m.RefereeUID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InviteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case invite.FieldUID:
		return m.OldUID(ctx)
	case invite.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case invite.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case invite.FieldDeactivatedAt:
		return m.OldDeactivatedAt(ctx)
	case invite.FieldReferralUID:
		return m.OldReferralUID(ctx)
	case invite.FieldRefereeUID:
		return m.OldRefereeUID(ctx)
	}
	return nil, fmt.Errorf("unknown Invite field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InviteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case invite.FieldUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case invite.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case invite.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case invite.FieldDeactivatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeactivatedAt(v)
		return nil
	case invite.FieldReferralUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferralUID(v)
		return nil
	case invite.FieldRefereeUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefereeUID(v)
		return nil
	}
	return fmt.Errorf("unknown Invite field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InviteMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InviteMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InviteMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Invite numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InviteMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(invite.FieldDeactivatedAt) {
		fields = append(fields, invite.FieldDeactivatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InviteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InviteMutation) ClearField(name string) error {
	switch name {
	case invite.FieldDeactivatedAt:
		m.ClearDeactivatedAt()
		return nil
	}
	return fmt.Errorf("unknown Invite nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InviteMutation) ResetField(name string) error {
	switch name {
	case invite.FieldUID:
		m.ResetUID()
		return nil
	case invite.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case invite.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case invite.FieldDeactivatedAt:
		m.ResetDeactivatedAt()
		return nil
	case invite.FieldReferralUID:
		m.ResetReferralUID()
		return nil
	case invite.FieldRefereeUID:
		m.ResetRefereeUID()
		return nil
	}
	return fmt.Errorf("unknown Invite field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InviteMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InviteMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InviteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InviteMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InviteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InviteMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InviteMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Invite unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InviteMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Invite edge %s", name)
}

// MessageMutation represents an operation that mutates the Message nodes in the graph.
type MessageMutation struct {
	config
	op             Op
	typ            string
	id             *uint64
	uid            *string
	created_at     *time.Time
	updated_at     *time.Time
	deactivated_at *time.Time
	user_uid       *string
	promoter_uid   *string
	category       *string
	description    *string
	has_read       *bool
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Message, error)
	predicates     []predicate.Message
}

var _ ent.Mutation = (*MessageMutation)(nil)

// messageOption allows management of the mutation configuration using functional options.
type messageOption func(*MessageMutation)

// newMessageMutation creates new mutation for the Message entity.
func newMessageMutation(c config, op Op, opts ...messageOption) *MessageMutation {
	m := &MessageMutation{
		config:        c,
		op:            op,
		typ:           TypeMessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMessageID sets the ID field of the mutation.
func withMessageID(id uint64) messageOption {
	return func(m *MessageMutation) {
		var (
			err   error
			once  sync.Once
			value *Message
		)
		m.oldValue = func(ctx context.Context) (*Message, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Message.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMessage sets the old Message of the mutation.
func withMessage(node *Message) messageOption {
	return func(m *MessageMutation) {
		m.oldValue = func(context.Context) (*Message, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entschema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Message entities.
func (m *MessageMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MessageMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MessageMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Message.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUID sets the "uid" field.
func (m *MessageMutation) SetUID(s string) {
	m.uid = &s
}

// UID returns the value of the "uid" field in the mutation.
func (m *MessageMutation) UID() (r string, exists bool) {
	v := m.uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old "uid" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// ResetUID resets all changes to the "uid" field.
func (m *MessageMutation) ResetUID() {
	m.uid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MessageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MessageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MessageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MessageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MessageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MessageMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeactivatedAt sets the "deactivated_at" field.
func (m *MessageMutation) SetDeactivatedAt(t time.Time) {
	m.deactivated_at = &t
}

// DeactivatedAt returns the value of the "deactivated_at" field in the mutation.
func (m *MessageMutation) DeactivatedAt() (r time.Time, exists bool) {
	v := m.deactivated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeactivatedAt returns the old "deactivated_at" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldDeactivatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeactivatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeactivatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeactivatedAt: %w", err)
	}
	return oldValue.DeactivatedAt, nil
}

// ClearDeactivatedAt clears the value of the "deactivated_at" field.
func (m *MessageMutation) ClearDeactivatedAt() {
	m.deactivated_at = nil
	m.clearedFields[message.FieldDeactivatedAt] = struct{}{}
}

// DeactivatedAtCleared returns if the "deactivated_at" field was cleared in this mutation.
func (m *MessageMutation) DeactivatedAtCleared() bool {
	_, ok := m.clearedFields[message.FieldDeactivatedAt]
	return ok
}

// ResetDeactivatedAt resets all changes to the "deactivated_at" field.
func (m *MessageMutation) ResetDeactivatedAt() {
	m.deactivated_at = nil
	delete(m.clearedFields, message.FieldDeactivatedAt)
}

// SetUserUID sets the "user_uid" field.
func (m *MessageMutation) SetUserUID(s string) {
	m.user_uid = &s
}

// UserUID returns the value of the "user_uid" field in the mutation.
func (m *MessageMutation) UserUID() (r string, exists bool) {
	v := m.user_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUserUID returns the old "user_uid" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldUserUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserUID: %w", err)
	}
	return oldValue.UserUID, nil
}

// ResetUserUID resets all changes to the "user_uid" field.
func (m *MessageMutation) ResetUserUID() {
	m.user_uid = nil
}

// SetPromoterUID sets the "promoter_uid" field.
func (m *MessageMutation) SetPromoterUID(s string) {
	m.promoter_uid = &s
}

// PromoterUID returns the value of the "promoter_uid" field in the mutation.
func (m *MessageMutation) PromoterUID() (r string, exists bool) {
	v := m.promoter_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldPromoterUID returns the old "promoter_uid" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldPromoterUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromoterUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromoterUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromoterUID: %w", err)
	}
	return oldValue.PromoterUID, nil
}

// ResetPromoterUID resets all changes to the "promoter_uid" field.
func (m *MessageMutation) ResetPromoterUID() {
	m.promoter_uid = nil
}

// SetCategory sets the "category" field.
func (m *MessageMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *MessageMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *MessageMutation) ResetCategory() {
	m.category = nil
}

// SetDescription sets the "description" field.
func (m *MessageMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *MessageMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *MessageMutation) ResetDescription() {
	m.description = nil
}

// SetHasRead sets the "has_read" field.
func (m *MessageMutation) SetHasRead(b bool) {
	m.has_read = &b
}

// HasRead returns the value of the "has_read" field in the mutation.
func (m *MessageMutation) HasRead() (r bool, exists bool) {
	v := m.has_read
	if v == nil {
		return
	}
	return *v, true
}

// OldHasRead returns the old "has_read" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldHasRead(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasRead is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasRead requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasRead: %w", err)
	}
	return oldValue.HasRead, nil
}

// ResetHasRead resets all changes to the "has_read" field.
func (m *MessageMutation) ResetHasRead() {
	m.has_read = nil
}

// Where appends a list predicates to the MessageMutation builder.
func (m *MessageMutation) Where(ps ...predicate.Message) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *MessageMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Message).
func (m *MessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MessageMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.uid != nil {
		fields = append(fields, message.FieldUID)
	}
	if m.created_at != nil {
		fields = append(fields, message.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, message.FieldUpdatedAt)
	}
	if m.deactivated_at != nil {
		fields = append(fields, message.FieldDeactivatedAt)
	}
	if m.user_uid != nil {
		fields = append(fields, message.FieldUserUID)
	}
	if m.promoter_uid != nil {
		fields = append(fields, message.FieldPromoterUID)
	}
	if m.category != nil {
		fields = append(fields, message.FieldCategory)
	}
	if m.description != nil {
		fields = append(fields, message.FieldDescription)
	}
	if m.has_read != nil {
		fields = append(fields, message.FieldHasRead)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case message.FieldUID:
		return m.UID()
	case message.FieldCreatedAt:
		return m.CreatedAt()
	case message.FieldUpdatedAt:
		return m.UpdatedAt()
	case message.FieldDeactivatedAt:
		return m.DeactivatedAt()
	case message.FieldUserUID:
		return m.UserUID()
	case message.FieldPromoterUID:
		return m.PromoterUID()
	case message.FieldCategory:
		return m.Category()
	case message.FieldDescription:
		return m.Description()
	case message.FieldHasRead:
		return m.HasRead()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case message.FieldUID:
		return m.OldUID(ctx)
	case message.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case message.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case message.FieldDeactivatedAt:
		return m.OldDeactivatedAt(ctx)
	case message.FieldUserUID:
		return m.OldUserUID(ctx)
	case message.FieldPromoterUID:
		return m.OldPromoterUID(ctx)
	case message.FieldCategory:
		return m.OldCategory(ctx)
	case message.FieldDescription:
		return m.OldDescription(ctx)
	case message.FieldHasRead:
		return m.OldHasRead(ctx)
	}
	return nil, fmt.Errorf("unknown Message field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case message.FieldUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case message.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case message.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case message.FieldDeactivatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeactivatedAt(v)
		return nil
	case message.FieldUserUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserUID(v)
		return nil
	case message.FieldPromoterUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromoterUID(v)
		return nil
	case message.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case message.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case message.FieldHasRead:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasRead(v)
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MessageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MessageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Message numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MessageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(message.FieldDeactivatedAt) {
		fields = append(fields, message.FieldDeactivatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MessageMutation) ClearField(name string) error {
	switch name {
	case message.FieldDeactivatedAt:
		m.ClearDeactivatedAt()
		return nil
	}
	return fmt.Errorf("unknown Message nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MessageMutation) ResetField(name string) error {
	switch name {
	case message.FieldUID:
		m.ResetUID()
		return nil
	case message.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case message.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case message.FieldDeactivatedAt:
		m.ResetDeactivatedAt()
		return nil
	case message.FieldUserUID:
		m.ResetUserUID()
		return nil
	case message.FieldPromoterUID:
		m.ResetPromoterUID()
		return nil
	case message.FieldCategory:
		m.ResetCategory()
		return nil
	case message.FieldDescription:
		m.ResetDescription()
		return nil
	case message.FieldHasRead:
		m.ResetHasRead()
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MessageMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MessageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MessageMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MessageMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Message unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MessageMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Message edge %s", name)
}

// NoticeMutation represents an operation that mutates the Notice nodes in the graph.
type NoticeMutation struct {
	config
	op             Op
	typ            string
	id             *int
	uid            *string
	created_at     *time.Time
	updated_at     *time.Time
	deactivated_at *time.Time
	content        *string
	process        *bool
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Notice, error)
	predicates     []predicate.Notice
}

var _ ent.Mutation = (*NoticeMutation)(nil)

// noticeOption allows management of the mutation configuration using functional options.
type noticeOption func(*NoticeMutation)

// newNoticeMutation creates new mutation for the Notice entity.
func newNoticeMutation(c config, op Op, opts ...noticeOption) *NoticeMutation {
	m := &NoticeMutation{
		config:        c,
		op:            op,
		typ:           TypeNotice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNoticeID sets the ID field of the mutation.
func withNoticeID(id int) noticeOption {
	return func(m *NoticeMutation) {
		var (
			err   error
			once  sync.Once
			value *Notice
		)
		m.oldValue = func(ctx context.Context) (*Notice, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Notice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotice sets the old Notice of the mutation.
func withNotice(node *Notice) noticeOption {
	return func(m *NoticeMutation) {
		m.oldValue = func(context.Context) (*Notice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NoticeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NoticeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entschema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NoticeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NoticeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Notice.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUID sets the "uid" field.
func (m *NoticeMutation) SetUID(s string) {
	m.uid = &s
}

// UID returns the value of the "uid" field in the mutation.
func (m *NoticeMutation) UID() (r string, exists bool) {
	v := m.uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old "uid" field's value of the Notice entity.
// If the Notice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoticeMutation) OldUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// ResetUID resets all changes to the "uid" field.
func (m *NoticeMutation) ResetUID() {
	m.uid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NoticeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NoticeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Notice entity.
// If the Notice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoticeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NoticeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NoticeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NoticeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Notice entity.
// If the Notice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoticeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NoticeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeactivatedAt sets the "deactivated_at" field.
func (m *NoticeMutation) SetDeactivatedAt(t time.Time) {
	m.deactivated_at = &t
}

// DeactivatedAt returns the value of the "deactivated_at" field in the mutation.
func (m *NoticeMutation) DeactivatedAt() (r time.Time, exists bool) {
	v := m.deactivated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeactivatedAt returns the old "deactivated_at" field's value of the Notice entity.
// If the Notice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoticeMutation) OldDeactivatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeactivatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeactivatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeactivatedAt: %w", err)
	}
	return oldValue.DeactivatedAt, nil
}

// ClearDeactivatedAt clears the value of the "deactivated_at" field.
func (m *NoticeMutation) ClearDeactivatedAt() {
	m.deactivated_at = nil
	m.clearedFields[notice.FieldDeactivatedAt] = struct{}{}
}

// DeactivatedAtCleared returns if the "deactivated_at" field was cleared in this mutation.
func (m *NoticeMutation) DeactivatedAtCleared() bool {
	_, ok := m.clearedFields[notice.FieldDeactivatedAt]
	return ok
}

// ResetDeactivatedAt resets all changes to the "deactivated_at" field.
func (m *NoticeMutation) ResetDeactivatedAt() {
	m.deactivated_at = nil
	delete(m.clearedFields, notice.FieldDeactivatedAt)
}

// SetContent sets the "content" field.
func (m *NoticeMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *NoticeMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Notice entity.
// If the Notice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoticeMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *NoticeMutation) ResetContent() {
	m.content = nil
}

// SetProcess sets the "process" field.
func (m *NoticeMutation) SetProcess(b bool) {
	m.process = &b
}

// Process returns the value of the "process" field in the mutation.
func (m *NoticeMutation) Process() (r bool, exists bool) {
	v := m.process
	if v == nil {
		return
	}
	return *v, true
}

// OldProcess returns the old "process" field's value of the Notice entity.
// If the Notice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoticeMutation) OldProcess(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcess: %w", err)
	}
	return oldValue.Process, nil
}

// ResetProcess resets all changes to the "process" field.
func (m *NoticeMutation) ResetProcess() {
	m.process = nil
}

// Where appends a list predicates to the NoticeMutation builder.
func (m *NoticeMutation) Where(ps ...predicate.Notice) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *NoticeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Notice).
func (m *NoticeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NoticeMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.uid != nil {
		fields = append(fields, notice.FieldUID)
	}
	if m.created_at != nil {
		fields = append(fields, notice.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, notice.FieldUpdatedAt)
	}
	if m.deactivated_at != nil {
		fields = append(fields, notice.FieldDeactivatedAt)
	}
	if m.content != nil {
		fields = append(fields, notice.FieldContent)
	}
	if m.process != nil {
		fields = append(fields, notice.FieldProcess)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NoticeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notice.FieldUID:
		return m.UID()
	case notice.FieldCreatedAt:
		return m.CreatedAt()
	case notice.FieldUpdatedAt:
		return m.UpdatedAt()
	case notice.FieldDeactivatedAt:
		return m.DeactivatedAt()
	case notice.FieldContent:
		return m.Content()
	case notice.FieldProcess:
		return m.Process()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NoticeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notice.FieldUID:
		return m.OldUID(ctx)
	case notice.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notice.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case notice.FieldDeactivatedAt:
		return m.OldDeactivatedAt(ctx)
	case notice.FieldContent:
		return m.OldContent(ctx)
	case notice.FieldProcess:
		return m.OldProcess(ctx)
	}
	return nil, fmt.Errorf("unknown Notice field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NoticeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notice.FieldUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case notice.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notice.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case notice.FieldDeactivatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeactivatedAt(v)
		return nil
	case notice.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case notice.FieldProcess:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcess(v)
		return nil
	}
	return fmt.Errorf("unknown Notice field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NoticeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NoticeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NoticeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Notice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NoticeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notice.FieldDeactivatedAt) {
		fields = append(fields, notice.FieldDeactivatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NoticeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NoticeMutation) ClearField(name string) error {
	switch name {
	case notice.FieldDeactivatedAt:
		m.ClearDeactivatedAt()
		return nil
	}
	return fmt.Errorf("unknown Notice nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NoticeMutation) ResetField(name string) error {
	switch name {
	case notice.FieldUID:
		m.ResetUID()
		return nil
	case notice.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notice.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case notice.FieldDeactivatedAt:
		m.ResetDeactivatedAt()
		return nil
	case notice.FieldContent:
		m.ResetContent()
		return nil
	case notice.FieldProcess:
		m.ResetProcess()
		return nil
	}
	return fmt.Errorf("unknown Notice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NoticeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NoticeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NoticeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NoticeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NoticeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NoticeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NoticeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Notice unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NoticeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Notice edge %s", name)
}

// PayOrderMutation represents an operation that mutates the PayOrder nodes in the graph.
type PayOrderMutation struct {
	config
	op                 Op
	typ                string
	id                 *uint64
	uid                *string
	created_at         *time.Time
	updated_at         *time.Time
	deactivated_at     *time.Time
	order_number       *string
	order_type         *string
	user_uid           *string
	pay_method         *string
	payment_amount     *string
	total_price        *string
	recharge_record    *schema.RechargeRecord
	status             *string
	transaction_number *string
	thirdparty_number  *string
	mch_id             *string
	open_id            *string
	member_expired     *time.Time
	cancel_event       *string
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*PayOrder, error)
	predicates         []predicate.PayOrder
}

var _ ent.Mutation = (*PayOrderMutation)(nil)

// payorderOption allows management of the mutation configuration using functional options.
type payorderOption func(*PayOrderMutation)

// newPayOrderMutation creates new mutation for the PayOrder entity.
func newPayOrderMutation(c config, op Op, opts ...payorderOption) *PayOrderMutation {
	m := &PayOrderMutation{
		config:        c,
		op:            op,
		typ:           TypePayOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPayOrderID sets the ID field of the mutation.
func withPayOrderID(id uint64) payorderOption {
	return func(m *PayOrderMutation) {
		var (
			err   error
			once  sync.Once
			value *PayOrder
		)
		m.oldValue = func(ctx context.Context) (*PayOrder, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PayOrder.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPayOrder sets the old PayOrder of the mutation.
func withPayOrder(node *PayOrder) payorderOption {
	return func(m *PayOrderMutation) {
		m.oldValue = func(context.Context) (*PayOrder, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PayOrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PayOrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entschema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PayOrder entities.
func (m *PayOrderMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PayOrderMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PayOrderMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PayOrder.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUID sets the "uid" field.
func (m *PayOrderMutation) SetUID(s string) {
	m.uid = &s
}

// UID returns the value of the "uid" field in the mutation.
func (m *PayOrderMutation) UID() (r string, exists bool) {
	v := m.uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old "uid" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// ResetUID resets all changes to the "uid" field.
func (m *PayOrderMutation) ResetUID() {
	m.uid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PayOrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PayOrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PayOrderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PayOrderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PayOrderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PayOrderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeactivatedAt sets the "deactivated_at" field.
func (m *PayOrderMutation) SetDeactivatedAt(t time.Time) {
	m.deactivated_at = &t
}

// DeactivatedAt returns the value of the "deactivated_at" field in the mutation.
func (m *PayOrderMutation) DeactivatedAt() (r time.Time, exists bool) {
	v := m.deactivated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeactivatedAt returns the old "deactivated_at" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldDeactivatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeactivatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeactivatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeactivatedAt: %w", err)
	}
	return oldValue.DeactivatedAt, nil
}

// ClearDeactivatedAt clears the value of the "deactivated_at" field.
func (m *PayOrderMutation) ClearDeactivatedAt() {
	m.deactivated_at = nil
	m.clearedFields[payorder.FieldDeactivatedAt] = struct{}{}
}

// DeactivatedAtCleared returns if the "deactivated_at" field was cleared in this mutation.
func (m *PayOrderMutation) DeactivatedAtCleared() bool {
	_, ok := m.clearedFields[payorder.FieldDeactivatedAt]
	return ok
}

// ResetDeactivatedAt resets all changes to the "deactivated_at" field.
func (m *PayOrderMutation) ResetDeactivatedAt() {
	m.deactivated_at = nil
	delete(m.clearedFields, payorder.FieldDeactivatedAt)
}

// SetOrderNumber sets the "order_number" field.
func (m *PayOrderMutation) SetOrderNumber(s string) {
	m.order_number = &s
}

// OrderNumber returns the value of the "order_number" field in the mutation.
func (m *PayOrderMutation) OrderNumber() (r string, exists bool) {
	v := m.order_number
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderNumber returns the old "order_number" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldOrderNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderNumber: %w", err)
	}
	return oldValue.OrderNumber, nil
}

// ResetOrderNumber resets all changes to the "order_number" field.
func (m *PayOrderMutation) ResetOrderNumber() {
	m.order_number = nil
}

// SetOrderType sets the "order_type" field.
func (m *PayOrderMutation) SetOrderType(s string) {
	m.order_type = &s
}

// OrderType returns the value of the "order_type" field in the mutation.
func (m *PayOrderMutation) OrderType() (r string, exists bool) {
	v := m.order_type
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderType returns the old "order_type" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldOrderType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderType: %w", err)
	}
	return oldValue.OrderType, nil
}

// ResetOrderType resets all changes to the "order_type" field.
func (m *PayOrderMutation) ResetOrderType() {
	m.order_type = nil
}

// SetUserUID sets the "user_uid" field.
func (m *PayOrderMutation) SetUserUID(s string) {
	m.user_uid = &s
}

// UserUID returns the value of the "user_uid" field in the mutation.
func (m *PayOrderMutation) UserUID() (r string, exists bool) {
	v := m.user_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUserUID returns the old "user_uid" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldUserUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserUID: %w", err)
	}
	return oldValue.UserUID, nil
}

// ResetUserUID resets all changes to the "user_uid" field.
func (m *PayOrderMutation) ResetUserUID() {
	m.user_uid = nil
}

// SetPayMethod sets the "pay_method" field.
func (m *PayOrderMutation) SetPayMethod(s string) {
	m.pay_method = &s
}

// PayMethod returns the value of the "pay_method" field in the mutation.
func (m *PayOrderMutation) PayMethod() (r string, exists bool) {
	v := m.pay_method
	if v == nil {
		return
	}
	return *v, true
}

// OldPayMethod returns the old "pay_method" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldPayMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayMethod: %w", err)
	}
	return oldValue.PayMethod, nil
}

// ResetPayMethod resets all changes to the "pay_method" field.
func (m *PayOrderMutation) ResetPayMethod() {
	m.pay_method = nil
}

// SetPaymentAmount sets the "payment_amount" field.
func (m *PayOrderMutation) SetPaymentAmount(s string) {
	m.payment_amount = &s
}

// PaymentAmount returns the value of the "payment_amount" field in the mutation.
func (m *PayOrderMutation) PaymentAmount() (r string, exists bool) {
	v := m.payment_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentAmount returns the old "payment_amount" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldPaymentAmount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentAmount: %w", err)
	}
	return oldValue.PaymentAmount, nil
}

// ResetPaymentAmount resets all changes to the "payment_amount" field.
func (m *PayOrderMutation) ResetPaymentAmount() {
	m.payment_amount = nil
}

// SetTotalPrice sets the "total_price" field.
func (m *PayOrderMutation) SetTotalPrice(s string) {
	m.total_price = &s
}

// TotalPrice returns the value of the "total_price" field in the mutation.
func (m *PayOrderMutation) TotalPrice() (r string, exists bool) {
	v := m.total_price
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalPrice returns the old "total_price" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldTotalPrice(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalPrice: %w", err)
	}
	return oldValue.TotalPrice, nil
}

// ResetTotalPrice resets all changes to the "total_price" field.
func (m *PayOrderMutation) ResetTotalPrice() {
	m.total_price = nil
}

// SetRechargeRecord sets the "recharge_record" field.
func (m *PayOrderMutation) SetRechargeRecord(sr schema.RechargeRecord) {
	m.recharge_record = &sr
}

// RechargeRecord returns the value of the "recharge_record" field in the mutation.
func (m *PayOrderMutation) RechargeRecord() (r schema.RechargeRecord, exists bool) {
	v := m.recharge_record
	if v == nil {
		return
	}
	return *v, true
}

// OldRechargeRecord returns the old "recharge_record" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldRechargeRecord(ctx context.Context) (v schema.RechargeRecord, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRechargeRecord is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRechargeRecord requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRechargeRecord: %w", err)
	}
	return oldValue.RechargeRecord, nil
}

// ResetRechargeRecord resets all changes to the "recharge_record" field.
func (m *PayOrderMutation) ResetRechargeRecord() {
	m.recharge_record = nil
}

// SetStatus sets the "status" field.
func (m *PayOrderMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *PayOrderMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PayOrderMutation) ResetStatus() {
	m.status = nil
}

// SetTransactionNumber sets the "transaction_number" field.
func (m *PayOrderMutation) SetTransactionNumber(s string) {
	m.transaction_number = &s
}

// TransactionNumber returns the value of the "transaction_number" field in the mutation.
func (m *PayOrderMutation) TransactionNumber() (r string, exists bool) {
	v := m.transaction_number
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionNumber returns the old "transaction_number" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldTransactionNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactionNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactionNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionNumber: %w", err)
	}
	return oldValue.TransactionNumber, nil
}

// ClearTransactionNumber clears the value of the "transaction_number" field.
func (m *PayOrderMutation) ClearTransactionNumber() {
	m.transaction_number = nil
	m.clearedFields[payorder.FieldTransactionNumber] = struct{}{}
}

// TransactionNumberCleared returns if the "transaction_number" field was cleared in this mutation.
func (m *PayOrderMutation) TransactionNumberCleared() bool {
	_, ok := m.clearedFields[payorder.FieldTransactionNumber]
	return ok
}

// ResetTransactionNumber resets all changes to the "transaction_number" field.
func (m *PayOrderMutation) ResetTransactionNumber() {
	m.transaction_number = nil
	delete(m.clearedFields, payorder.FieldTransactionNumber)
}

// SetThirdpartyNumber sets the "thirdparty_number" field.
func (m *PayOrderMutation) SetThirdpartyNumber(s string) {
	m.thirdparty_number = &s
}

// ThirdpartyNumber returns the value of the "thirdparty_number" field in the mutation.
func (m *PayOrderMutation) ThirdpartyNumber() (r string, exists bool) {
	v := m.thirdparty_number
	if v == nil {
		return
	}
	return *v, true
}

// OldThirdpartyNumber returns the old "thirdparty_number" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldThirdpartyNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThirdpartyNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThirdpartyNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThirdpartyNumber: %w", err)
	}
	return oldValue.ThirdpartyNumber, nil
}

// ClearThirdpartyNumber clears the value of the "thirdparty_number" field.
func (m *PayOrderMutation) ClearThirdpartyNumber() {
	m.thirdparty_number = nil
	m.clearedFields[payorder.FieldThirdpartyNumber] = struct{}{}
}

// ThirdpartyNumberCleared returns if the "thirdparty_number" field was cleared in this mutation.
func (m *PayOrderMutation) ThirdpartyNumberCleared() bool {
	_, ok := m.clearedFields[payorder.FieldThirdpartyNumber]
	return ok
}

// ResetThirdpartyNumber resets all changes to the "thirdparty_number" field.
func (m *PayOrderMutation) ResetThirdpartyNumber() {
	m.thirdparty_number = nil
	delete(m.clearedFields, payorder.FieldThirdpartyNumber)
}

// SetMchID sets the "mch_id" field.
func (m *PayOrderMutation) SetMchID(s string) {
	m.mch_id = &s
}

// MchID returns the value of the "mch_id" field in the mutation.
func (m *PayOrderMutation) MchID() (r string, exists bool) {
	v := m.mch_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMchID returns the old "mch_id" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldMchID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMchID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMchID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMchID: %w", err)
	}
	return oldValue.MchID, nil
}

// ClearMchID clears the value of the "mch_id" field.
func (m *PayOrderMutation) ClearMchID() {
	m.mch_id = nil
	m.clearedFields[payorder.FieldMchID] = struct{}{}
}

// MchIDCleared returns if the "mch_id" field was cleared in this mutation.
func (m *PayOrderMutation) MchIDCleared() bool {
	_, ok := m.clearedFields[payorder.FieldMchID]
	return ok
}

// ResetMchID resets all changes to the "mch_id" field.
func (m *PayOrderMutation) ResetMchID() {
	m.mch_id = nil
	delete(m.clearedFields, payorder.FieldMchID)
}

// SetOpenID sets the "open_id" field.
func (m *PayOrderMutation) SetOpenID(s string) {
	m.open_id = &s
}

// OpenID returns the value of the "open_id" field in the mutation.
func (m *PayOrderMutation) OpenID() (r string, exists bool) {
	v := m.open_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOpenID returns the old "open_id" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldOpenID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpenID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpenID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpenID: %w", err)
	}
	return oldValue.OpenID, nil
}

// ClearOpenID clears the value of the "open_id" field.
func (m *PayOrderMutation) ClearOpenID() {
	m.open_id = nil
	m.clearedFields[payorder.FieldOpenID] = struct{}{}
}

// OpenIDCleared returns if the "open_id" field was cleared in this mutation.
func (m *PayOrderMutation) OpenIDCleared() bool {
	_, ok := m.clearedFields[payorder.FieldOpenID]
	return ok
}

// ResetOpenID resets all changes to the "open_id" field.
func (m *PayOrderMutation) ResetOpenID() {
	m.open_id = nil
	delete(m.clearedFields, payorder.FieldOpenID)
}

// SetMemberExpired sets the "member_expired" field.
func (m *PayOrderMutation) SetMemberExpired(t time.Time) {
	m.member_expired = &t
}

// MemberExpired returns the value of the "member_expired" field in the mutation.
func (m *PayOrderMutation) MemberExpired() (r time.Time, exists bool) {
	v := m.member_expired
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberExpired returns the old "member_expired" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldMemberExpired(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberExpired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberExpired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberExpired: %w", err)
	}
	return oldValue.MemberExpired, nil
}

// ClearMemberExpired clears the value of the "member_expired" field.
func (m *PayOrderMutation) ClearMemberExpired() {
	m.member_expired = nil
	m.clearedFields[payorder.FieldMemberExpired] = struct{}{}
}

// MemberExpiredCleared returns if the "member_expired" field was cleared in this mutation.
func (m *PayOrderMutation) MemberExpiredCleared() bool {
	_, ok := m.clearedFields[payorder.FieldMemberExpired]
	return ok
}

// ResetMemberExpired resets all changes to the "member_expired" field.
func (m *PayOrderMutation) ResetMemberExpired() {
	m.member_expired = nil
	delete(m.clearedFields, payorder.FieldMemberExpired)
}

// SetCancelEvent sets the "cancel_event" field.
func (m *PayOrderMutation) SetCancelEvent(s string) {
	m.cancel_event = &s
}

// CancelEvent returns the value of the "cancel_event" field in the mutation.
func (m *PayOrderMutation) CancelEvent() (r string, exists bool) {
	v := m.cancel_event
	if v == nil {
		return
	}
	return *v, true
}

// OldCancelEvent returns the old "cancel_event" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldCancelEvent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCancelEvent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCancelEvent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCancelEvent: %w", err)
	}
	return oldValue.CancelEvent, nil
}

// ClearCancelEvent clears the value of the "cancel_event" field.
func (m *PayOrderMutation) ClearCancelEvent() {
	m.cancel_event = nil
	m.clearedFields[payorder.FieldCancelEvent] = struct{}{}
}

// CancelEventCleared returns if the "cancel_event" field was cleared in this mutation.
func (m *PayOrderMutation) CancelEventCleared() bool {
	_, ok := m.clearedFields[payorder.FieldCancelEvent]
	return ok
}

// ResetCancelEvent resets all changes to the "cancel_event" field.
func (m *PayOrderMutation) ResetCancelEvent() {
	m.cancel_event = nil
	delete(m.clearedFields, payorder.FieldCancelEvent)
}

// Where appends a list predicates to the PayOrderMutation builder.
func (m *PayOrderMutation) Where(ps ...predicate.PayOrder) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PayOrderMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PayOrder).
func (m *PayOrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PayOrderMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.uid != nil {
		fields = append(fields, payorder.FieldUID)
	}
	if m.created_at != nil {
		fields = append(fields, payorder.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, payorder.FieldUpdatedAt)
	}
	if m.deactivated_at != nil {
		fields = append(fields, payorder.FieldDeactivatedAt)
	}
	if m.order_number != nil {
		fields = append(fields, payorder.FieldOrderNumber)
	}
	if m.order_type != nil {
		fields = append(fields, payorder.FieldOrderType)
	}
	if m.user_uid != nil {
		fields = append(fields, payorder.FieldUserUID)
	}
	if m.pay_method != nil {
		fields = append(fields, payorder.FieldPayMethod)
	}
	if m.payment_amount != nil {
		fields = append(fields, payorder.FieldPaymentAmount)
	}
	if m.total_price != nil {
		fields = append(fields, payorder.FieldTotalPrice)
	}
	if m.recharge_record != nil {
		fields = append(fields, payorder.FieldRechargeRecord)
	}
	if m.status != nil {
		fields = append(fields, payorder.FieldStatus)
	}
	if m.transaction_number != nil {
		fields = append(fields, payorder.FieldTransactionNumber)
	}
	if m.thirdparty_number != nil {
		fields = append(fields, payorder.FieldThirdpartyNumber)
	}
	if m.mch_id != nil {
		fields = append(fields, payorder.FieldMchID)
	}
	if m.open_id != nil {
		fields = append(fields, payorder.FieldOpenID)
	}
	if m.member_expired != nil {
		fields = append(fields, payorder.FieldMemberExpired)
	}
	if m.cancel_event != nil {
		fields = append(fields, payorder.FieldCancelEvent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PayOrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case payorder.FieldUID:
		return m.UID()
	case payorder.FieldCreatedAt:
		return m.CreatedAt()
	case payorder.FieldUpdatedAt:
		return m.UpdatedAt()
	case payorder.FieldDeactivatedAt:
		return m.DeactivatedAt()
	case payorder.FieldOrderNumber:
		return m.OrderNumber()
	case payorder.FieldOrderType:
		return m.OrderType()
	case payorder.FieldUserUID:
		return m.UserUID()
	case payorder.FieldPayMethod:
		return m.PayMethod()
	case payorder.FieldPaymentAmount:
		return m.PaymentAmount()
	case payorder.FieldTotalPrice:
		return m.TotalPrice()
	case payorder.FieldRechargeRecord:
		return m.RechargeRecord()
	case payorder.FieldStatus:
		return m.Status()
	case payorder.FieldTransactionNumber:
		return m.TransactionNumber()
	case payorder.FieldThirdpartyNumber:
		return m.ThirdpartyNumber()
	case payorder.FieldMchID:
		return m.MchID()
	case payorder.FieldOpenID:
		return m.OpenID()
	case payorder.FieldMemberExpired:
		return m.MemberExpired()
	case payorder.FieldCancelEvent:
		return m.CancelEvent()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PayOrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case payorder.FieldUID:
		return m.OldUID(ctx)
	case payorder.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case payorder.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case payorder.FieldDeactivatedAt:
		return m.OldDeactivatedAt(ctx)
	case payorder.FieldOrderNumber:
		return m.OldOrderNumber(ctx)
	case payorder.FieldOrderType:
		return m.OldOrderType(ctx)
	case payorder.FieldUserUID:
		return m.OldUserUID(ctx)
	case payorder.FieldPayMethod:
		return m.OldPayMethod(ctx)
	case payorder.FieldPaymentAmount:
		return m.OldPaymentAmount(ctx)
	case payorder.FieldTotalPrice:
		return m.OldTotalPrice(ctx)
	case payorder.FieldRechargeRecord:
		return m.OldRechargeRecord(ctx)
	case payorder.FieldStatus:
		return m.OldStatus(ctx)
	case payorder.FieldTransactionNumber:
		return m.OldTransactionNumber(ctx)
	case payorder.FieldThirdpartyNumber:
		return m.OldThirdpartyNumber(ctx)
	case payorder.FieldMchID:
		return m.OldMchID(ctx)
	case payorder.FieldOpenID:
		return m.OldOpenID(ctx)
	case payorder.FieldMemberExpired:
		return m.OldMemberExpired(ctx)
	case payorder.FieldCancelEvent:
		return m.OldCancelEvent(ctx)
	}
	return nil, fmt.Errorf("unknown PayOrder field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PayOrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case payorder.FieldUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case payorder.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case payorder.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case payorder.FieldDeactivatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeactivatedAt(v)
		return nil
	case payorder.FieldOrderNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderNumber(v)
		return nil
	case payorder.FieldOrderType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderType(v)
		return nil
	case payorder.FieldUserUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserUID(v)
		return nil
	case payorder.FieldPayMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayMethod(v)
		return nil
	case payorder.FieldPaymentAmount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentAmount(v)
		return nil
	case payorder.FieldTotalPrice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalPrice(v)
		return nil
	case payorder.FieldRechargeRecord:
		v, ok := value.(schema.RechargeRecord)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRechargeRecord(v)
		return nil
	case payorder.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case payorder.FieldTransactionNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionNumber(v)
		return nil
	case payorder.FieldThirdpartyNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThirdpartyNumber(v)
		return nil
	case payorder.FieldMchID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMchID(v)
		return nil
	case payorder.FieldOpenID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpenID(v)
		return nil
	case payorder.FieldMemberExpired:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberExpired(v)
		return nil
	case payorder.FieldCancelEvent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCancelEvent(v)
		return nil
	}
	return fmt.Errorf("unknown PayOrder field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PayOrderMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PayOrderMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PayOrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PayOrder numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PayOrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(payorder.FieldDeactivatedAt) {
		fields = append(fields, payorder.FieldDeactivatedAt)
	}
	if m.FieldCleared(payorder.FieldTransactionNumber) {
		fields = append(fields, payorder.FieldTransactionNumber)
	}
	if m.FieldCleared(payorder.FieldThirdpartyNumber) {
		fields = append(fields, payorder.FieldThirdpartyNumber)
	}
	if m.FieldCleared(payorder.FieldMchID) {
		fields = append(fields, payorder.FieldMchID)
	}
	if m.FieldCleared(payorder.FieldOpenID) {
		fields = append(fields, payorder.FieldOpenID)
	}
	if m.FieldCleared(payorder.FieldMemberExpired) {
		fields = append(fields, payorder.FieldMemberExpired)
	}
	if m.FieldCleared(payorder.FieldCancelEvent) {
		fields = append(fields, payorder.FieldCancelEvent)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PayOrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PayOrderMutation) ClearField(name string) error {
	switch name {
	case payorder.FieldDeactivatedAt:
		m.ClearDeactivatedAt()
		return nil
	case payorder.FieldTransactionNumber:
		m.ClearTransactionNumber()
		return nil
	case payorder.FieldThirdpartyNumber:
		m.ClearThirdpartyNumber()
		return nil
	case payorder.FieldMchID:
		m.ClearMchID()
		return nil
	case payorder.FieldOpenID:
		m.ClearOpenID()
		return nil
	case payorder.FieldMemberExpired:
		m.ClearMemberExpired()
		return nil
	case payorder.FieldCancelEvent:
		m.ClearCancelEvent()
		return nil
	}
	return fmt.Errorf("unknown PayOrder nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PayOrderMutation) ResetField(name string) error {
	switch name {
	case payorder.FieldUID:
		m.ResetUID()
		return nil
	case payorder.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case payorder.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case payorder.FieldDeactivatedAt:
		m.ResetDeactivatedAt()
		return nil
	case payorder.FieldOrderNumber:
		m.ResetOrderNumber()
		return nil
	case payorder.FieldOrderType:
		m.ResetOrderType()
		return nil
	case payorder.FieldUserUID:
		m.ResetUserUID()
		return nil
	case payorder.FieldPayMethod:
		m.ResetPayMethod()
		return nil
	case payorder.FieldPaymentAmount:
		m.ResetPaymentAmount()
		return nil
	case payorder.FieldTotalPrice:
		m.ResetTotalPrice()
		return nil
	case payorder.FieldRechargeRecord:
		m.ResetRechargeRecord()
		return nil
	case payorder.FieldStatus:
		m.ResetStatus()
		return nil
	case payorder.FieldTransactionNumber:
		m.ResetTransactionNumber()
		return nil
	case payorder.FieldThirdpartyNumber:
		m.ResetThirdpartyNumber()
		return nil
	case payorder.FieldMchID:
		m.ResetMchID()
		return nil
	case payorder.FieldOpenID:
		m.ResetOpenID()
		return nil
	case payorder.FieldMemberExpired:
		m.ResetMemberExpired()
		return nil
	case payorder.FieldCancelEvent:
		m.ResetCancelEvent()
		return nil
	}
	return fmt.Errorf("unknown PayOrder field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PayOrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PayOrderMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PayOrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PayOrderMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PayOrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PayOrderMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PayOrderMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PayOrder unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PayOrderMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PayOrder edge %s", name)
}

// PayOrderFeedbackMutation represents an operation that mutates the PayOrderFeedback nodes in the graph.
type PayOrderFeedbackMutation struct {
	config
	op             Op
	typ            string
	id             *uint64
	uid            *string
	created_at     *time.Time
	updated_at     *time.Time
	deactivated_at *time.Time
	user_uid       *string
	order_number   *string
	category       *string
	description    *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*PayOrderFeedback, error)
	predicates     []predicate.PayOrderFeedback
}

var _ ent.Mutation = (*PayOrderFeedbackMutation)(nil)

// payorderfeedbackOption allows management of the mutation configuration using functional options.
type payorderfeedbackOption func(*PayOrderFeedbackMutation)

// newPayOrderFeedbackMutation creates new mutation for the PayOrderFeedback entity.
func newPayOrderFeedbackMutation(c config, op Op, opts ...payorderfeedbackOption) *PayOrderFeedbackMutation {
	m := &PayOrderFeedbackMutation{
		config:        c,
		op:            op,
		typ:           TypePayOrderFeedback,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPayOrderFeedbackID sets the ID field of the mutation.
func withPayOrderFeedbackID(id uint64) payorderfeedbackOption {
	return func(m *PayOrderFeedbackMutation) {
		var (
			err   error
			once  sync.Once
			value *PayOrderFeedback
		)
		m.oldValue = func(ctx context.Context) (*PayOrderFeedback, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PayOrderFeedback.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPayOrderFeedback sets the old PayOrderFeedback of the mutation.
func withPayOrderFeedback(node *PayOrderFeedback) payorderfeedbackOption {
	return func(m *PayOrderFeedbackMutation) {
		m.oldValue = func(context.Context) (*PayOrderFeedback, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PayOrderFeedbackMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PayOrderFeedbackMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entschema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PayOrderFeedback entities.
func (m *PayOrderFeedbackMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PayOrderFeedbackMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PayOrderFeedbackMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PayOrderFeedback.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUID sets the "uid" field.
func (m *PayOrderFeedbackMutation) SetUID(s string) {
	m.uid = &s
}

// UID returns the value of the "uid" field in the mutation.
func (m *PayOrderFeedbackMutation) UID() (r string, exists bool) {
	v := m.uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old "uid" field's value of the PayOrderFeedback entity.
// If the PayOrderFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderFeedbackMutation) OldUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// ResetUID resets all changes to the "uid" field.
func (m *PayOrderFeedbackMutation) ResetUID() {
	m.uid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PayOrderFeedbackMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PayOrderFeedbackMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PayOrderFeedback entity.
// If the PayOrderFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderFeedbackMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PayOrderFeedbackMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PayOrderFeedbackMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PayOrderFeedbackMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PayOrderFeedback entity.
// If the PayOrderFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderFeedbackMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PayOrderFeedbackMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeactivatedAt sets the "deactivated_at" field.
func (m *PayOrderFeedbackMutation) SetDeactivatedAt(t time.Time) {
	m.deactivated_at = &t
}

// DeactivatedAt returns the value of the "deactivated_at" field in the mutation.
func (m *PayOrderFeedbackMutation) DeactivatedAt() (r time.Time, exists bool) {
	v := m.deactivated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeactivatedAt returns the old "deactivated_at" field's value of the PayOrderFeedback entity.
// If the PayOrderFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderFeedbackMutation) OldDeactivatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeactivatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeactivatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeactivatedAt: %w", err)
	}
	return oldValue.DeactivatedAt, nil
}

// ClearDeactivatedAt clears the value of the "deactivated_at" field.
func (m *PayOrderFeedbackMutation) ClearDeactivatedAt() {
	m.deactivated_at = nil
	m.clearedFields[payorderfeedback.FieldDeactivatedAt] = struct{}{}
}

// DeactivatedAtCleared returns if the "deactivated_at" field was cleared in this mutation.
func (m *PayOrderFeedbackMutation) DeactivatedAtCleared() bool {
	_, ok := m.clearedFields[payorderfeedback.FieldDeactivatedAt]
	return ok
}

// ResetDeactivatedAt resets all changes to the "deactivated_at" field.
func (m *PayOrderFeedbackMutation) ResetDeactivatedAt() {
	m.deactivated_at = nil
	delete(m.clearedFields, payorderfeedback.FieldDeactivatedAt)
}

// SetUserUID sets the "user_uid" field.
func (m *PayOrderFeedbackMutation) SetUserUID(s string) {
	m.user_uid = &s
}

// UserUID returns the value of the "user_uid" field in the mutation.
func (m *PayOrderFeedbackMutation) UserUID() (r string, exists bool) {
	v := m.user_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUserUID returns the old "user_uid" field's value of the PayOrderFeedback entity.
// If the PayOrderFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderFeedbackMutation) OldUserUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserUID: %w", err)
	}
	return oldValue.UserUID, nil
}

// ResetUserUID resets all changes to the "user_uid" field.
func (m *PayOrderFeedbackMutation) ResetUserUID() {
	m.user_uid = nil
}

// SetOrderNumber sets the "order_number" field.
func (m *PayOrderFeedbackMutation) SetOrderNumber(s string) {
	m.order_number = &s
}

// OrderNumber returns the value of the "order_number" field in the mutation.
func (m *PayOrderFeedbackMutation) OrderNumber() (r string, exists bool) {
	v := m.order_number
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderNumber returns the old "order_number" field's value of the PayOrderFeedback entity.
// If the PayOrderFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderFeedbackMutation) OldOrderNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderNumber: %w", err)
	}
	return oldValue.OrderNumber, nil
}

// ClearOrderNumber clears the value of the "order_number" field.
func (m *PayOrderFeedbackMutation) ClearOrderNumber() {
	m.order_number = nil
	m.clearedFields[payorderfeedback.FieldOrderNumber] = struct{}{}
}

// OrderNumberCleared returns if the "order_number" field was cleared in this mutation.
func (m *PayOrderFeedbackMutation) OrderNumberCleared() bool {
	_, ok := m.clearedFields[payorderfeedback.FieldOrderNumber]
	return ok
}

// ResetOrderNumber resets all changes to the "order_number" field.
func (m *PayOrderFeedbackMutation) ResetOrderNumber() {
	m.order_number = nil
	delete(m.clearedFields, payorderfeedback.FieldOrderNumber)
}

// SetCategory sets the "category" field.
func (m *PayOrderFeedbackMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *PayOrderFeedbackMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the PayOrderFeedback entity.
// If the PayOrderFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderFeedbackMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *PayOrderFeedbackMutation) ResetCategory() {
	m.category = nil
}

// SetDescription sets the "description" field.
func (m *PayOrderFeedbackMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PayOrderFeedbackMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the PayOrderFeedback entity.
// If the PayOrderFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderFeedbackMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PayOrderFeedbackMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[payorderfeedback.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PayOrderFeedbackMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[payorderfeedback.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PayOrderFeedbackMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, payorderfeedback.FieldDescription)
}

// Where appends a list predicates to the PayOrderFeedbackMutation builder.
func (m *PayOrderFeedbackMutation) Where(ps ...predicate.PayOrderFeedback) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PayOrderFeedbackMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PayOrderFeedback).
func (m *PayOrderFeedbackMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PayOrderFeedbackMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.uid != nil {
		fields = append(fields, payorderfeedback.FieldUID)
	}
	if m.created_at != nil {
		fields = append(fields, payorderfeedback.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, payorderfeedback.FieldUpdatedAt)
	}
	if m.deactivated_at != nil {
		fields = append(fields, payorderfeedback.FieldDeactivatedAt)
	}
	if m.user_uid != nil {
		fields = append(fields, payorderfeedback.FieldUserUID)
	}
	if m.order_number != nil {
		fields = append(fields, payorderfeedback.FieldOrderNumber)
	}
	if m.category != nil {
		fields = append(fields, payorderfeedback.FieldCategory)
	}
	if m.description != nil {
		fields = append(fields, payorderfeedback.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PayOrderFeedbackMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case payorderfeedback.FieldUID:
		return m.UID()
	case payorderfeedback.FieldCreatedAt:
		return m.CreatedAt()
	case payorderfeedback.FieldUpdatedAt:
		return m.UpdatedAt()
	case payorderfeedback.FieldDeactivatedAt:
		return m.DeactivatedAt()
	case payorderfeedback.FieldUserUID:
		return m.UserUID()
	case payorderfeedback.FieldOrderNumber:
		return m.OrderNumber()
	case payorderfeedback.FieldCategory:
		return m.Category()
	case payorderfeedback.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PayOrderFeedbackMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case payorderfeedback.FieldUID:
		return m.OldUID(ctx)
	case payorderfeedback.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case payorderfeedback.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case payorderfeedback.FieldDeactivatedAt:
		return m.OldDeactivatedAt(ctx)
	case payorderfeedback.FieldUserUID:
		return m.OldUserUID(ctx)
	case payorderfeedback.FieldOrderNumber:
		return m.OldOrderNumber(ctx)
	case payorderfeedback.FieldCategory:
		return m.OldCategory(ctx)
	case payorderfeedback.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown PayOrderFeedback field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PayOrderFeedbackMutation) SetField(name string, value ent.Value) error {
	switch name {
	case payorderfeedback.FieldUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case payorderfeedback.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case payorderfeedback.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case payorderfeedback.FieldDeactivatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeactivatedAt(v)
		return nil
	case payorderfeedback.FieldUserUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserUID(v)
		return nil
	case payorderfeedback.FieldOrderNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderNumber(v)
		return nil
	case payorderfeedback.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case payorderfeedback.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown PayOrderFeedback field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PayOrderFeedbackMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PayOrderFeedbackMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PayOrderFeedbackMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PayOrderFeedback numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PayOrderFeedbackMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(payorderfeedback.FieldDeactivatedAt) {
		fields = append(fields, payorderfeedback.FieldDeactivatedAt)
	}
	if m.FieldCleared(payorderfeedback.FieldOrderNumber) {
		fields = append(fields, payorderfeedback.FieldOrderNumber)
	}
	if m.FieldCleared(payorderfeedback.FieldDescription) {
		fields = append(fields, payorderfeedback.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PayOrderFeedbackMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PayOrderFeedbackMutation) ClearField(name string) error {
	switch name {
	case payorderfeedback.FieldDeactivatedAt:
		m.ClearDeactivatedAt()
		return nil
	case payorderfeedback.FieldOrderNumber:
		m.ClearOrderNumber()
		return nil
	case payorderfeedback.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown PayOrderFeedback nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PayOrderFeedbackMutation) ResetField(name string) error {
	switch name {
	case payorderfeedback.FieldUID:
		m.ResetUID()
		return nil
	case payorderfeedback.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case payorderfeedback.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case payorderfeedback.FieldDeactivatedAt:
		m.ResetDeactivatedAt()
		return nil
	case payorderfeedback.FieldUserUID:
		m.ResetUserUID()
		return nil
	case payorderfeedback.FieldOrderNumber:
		m.ResetOrderNumber()
		return nil
	case payorderfeedback.FieldCategory:
		m.ResetCategory()
		return nil
	case payorderfeedback.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown PayOrderFeedback field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PayOrderFeedbackMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PayOrderFeedbackMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PayOrderFeedbackMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PayOrderFeedbackMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PayOrderFeedbackMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PayOrderFeedbackMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PayOrderFeedbackMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PayOrderFeedback unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PayOrderFeedbackMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PayOrderFeedback edge %s", name)
}

// PersonalFolderMutation represents an operation that mutates the PersonalFolder nodes in the graph.
type PersonalFolderMutation struct {
	config
	op             Op
	typ            string
	id             *uint64
	uid            *string
	created_at     *time.Time
	updated_at     *time.Time
	deactivated_at *time.Time
	user_uid       *string
	folder_name    *string
	folder_number  *string
	has_open       *bool
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*PersonalFolder, error)
	predicates     []predicate.PersonalFolder
}

var _ ent.Mutation = (*PersonalFolderMutation)(nil)

// personalfolderOption allows management of the mutation configuration using functional options.
type personalfolderOption func(*PersonalFolderMutation)

// newPersonalFolderMutation creates new mutation for the PersonalFolder entity.
func newPersonalFolderMutation(c config, op Op, opts ...personalfolderOption) *PersonalFolderMutation {
	m := &PersonalFolderMutation{
		config:        c,
		op:            op,
		typ:           TypePersonalFolder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPersonalFolderID sets the ID field of the mutation.
func withPersonalFolderID(id uint64) personalfolderOption {
	return func(m *PersonalFolderMutation) {
		var (
			err   error
			once  sync.Once
			value *PersonalFolder
		)
		m.oldValue = func(ctx context.Context) (*PersonalFolder, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PersonalFolder.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPersonalFolder sets the old PersonalFolder of the mutation.
func withPersonalFolder(node *PersonalFolder) personalfolderOption {
	return func(m *PersonalFolderMutation) {
		m.oldValue = func(context.Context) (*PersonalFolder, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PersonalFolderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PersonalFolderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entschema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PersonalFolder entities.
func (m *PersonalFolderMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PersonalFolderMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PersonalFolderMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PersonalFolder.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUID sets the "uid" field.
func (m *PersonalFolderMutation) SetUID(s string) {
	m.uid = &s
}

// UID returns the value of the "uid" field in the mutation.
func (m *PersonalFolderMutation) UID() (r string, exists bool) {
	v := m.uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old "uid" field's value of the PersonalFolder entity.
// If the PersonalFolder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalFolderMutation) OldUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// ResetUID resets all changes to the "uid" field.
func (m *PersonalFolderMutation) ResetUID() {
	m.uid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PersonalFolderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PersonalFolderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PersonalFolder entity.
// If the PersonalFolder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalFolderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PersonalFolderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PersonalFolderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PersonalFolderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PersonalFolder entity.
// If the PersonalFolder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalFolderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PersonalFolderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeactivatedAt sets the "deactivated_at" field.
func (m *PersonalFolderMutation) SetDeactivatedAt(t time.Time) {
	m.deactivated_at = &t
}

// DeactivatedAt returns the value of the "deactivated_at" field in the mutation.
func (m *PersonalFolderMutation) DeactivatedAt() (r time.Time, exists bool) {
	v := m.deactivated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeactivatedAt returns the old "deactivated_at" field's value of the PersonalFolder entity.
// If the PersonalFolder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalFolderMutation) OldDeactivatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeactivatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeactivatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeactivatedAt: %w", err)
	}
	return oldValue.DeactivatedAt, nil
}

// ClearDeactivatedAt clears the value of the "deactivated_at" field.
func (m *PersonalFolderMutation) ClearDeactivatedAt() {
	m.deactivated_at = nil
	m.clearedFields[personalfolder.FieldDeactivatedAt] = struct{}{}
}

// DeactivatedAtCleared returns if the "deactivated_at" field was cleared in this mutation.
func (m *PersonalFolderMutation) DeactivatedAtCleared() bool {
	_, ok := m.clearedFields[personalfolder.FieldDeactivatedAt]
	return ok
}

// ResetDeactivatedAt resets all changes to the "deactivated_at" field.
func (m *PersonalFolderMutation) ResetDeactivatedAt() {
	m.deactivated_at = nil
	delete(m.clearedFields, personalfolder.FieldDeactivatedAt)
}

// SetUserUID sets the "user_uid" field.
func (m *PersonalFolderMutation) SetUserUID(s string) {
	m.user_uid = &s
}

// UserUID returns the value of the "user_uid" field in the mutation.
func (m *PersonalFolderMutation) UserUID() (r string, exists bool) {
	v := m.user_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUserUID returns the old "user_uid" field's value of the PersonalFolder entity.
// If the PersonalFolder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalFolderMutation) OldUserUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserUID: %w", err)
	}
	return oldValue.UserUID, nil
}

// ResetUserUID resets all changes to the "user_uid" field.
func (m *PersonalFolderMutation) ResetUserUID() {
	m.user_uid = nil
}

// SetFolderName sets the "folder_name" field.
func (m *PersonalFolderMutation) SetFolderName(s string) {
	m.folder_name = &s
}

// FolderName returns the value of the "folder_name" field in the mutation.
func (m *PersonalFolderMutation) FolderName() (r string, exists bool) {
	v := m.folder_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFolderName returns the old "folder_name" field's value of the PersonalFolder entity.
// If the PersonalFolder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalFolderMutation) OldFolderName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFolderName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFolderName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFolderName: %w", err)
	}
	return oldValue.FolderName, nil
}

// ResetFolderName resets all changes to the "folder_name" field.
func (m *PersonalFolderMutation) ResetFolderName() {
	m.folder_name = nil
}

// SetFolderNumber sets the "folder_number" field.
func (m *PersonalFolderMutation) SetFolderNumber(s string) {
	m.folder_number = &s
}

// FolderNumber returns the value of the "folder_number" field in the mutation.
func (m *PersonalFolderMutation) FolderNumber() (r string, exists bool) {
	v := m.folder_number
	if v == nil {
		return
	}
	return *v, true
}

// OldFolderNumber returns the old "folder_number" field's value of the PersonalFolder entity.
// If the PersonalFolder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalFolderMutation) OldFolderNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFolderNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFolderNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFolderNumber: %w", err)
	}
	return oldValue.FolderNumber, nil
}

// ResetFolderNumber resets all changes to the "folder_number" field.
func (m *PersonalFolderMutation) ResetFolderNumber() {
	m.folder_number = nil
}

// SetHasOpen sets the "has_open" field.
func (m *PersonalFolderMutation) SetHasOpen(b bool) {
	m.has_open = &b
}

// HasOpen returns the value of the "has_open" field in the mutation.
func (m *PersonalFolderMutation) HasOpen() (r bool, exists bool) {
	v := m.has_open
	if v == nil {
		return
	}
	return *v, true
}

// OldHasOpen returns the old "has_open" field's value of the PersonalFolder entity.
// If the PersonalFolder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalFolderMutation) OldHasOpen(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasOpen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasOpen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasOpen: %w", err)
	}
	return oldValue.HasOpen, nil
}

// ResetHasOpen resets all changes to the "has_open" field.
func (m *PersonalFolderMutation) ResetHasOpen() {
	m.has_open = nil
}

// Where appends a list predicates to the PersonalFolderMutation builder.
func (m *PersonalFolderMutation) Where(ps ...predicate.PersonalFolder) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PersonalFolderMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PersonalFolder).
func (m *PersonalFolderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PersonalFolderMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.uid != nil {
		fields = append(fields, personalfolder.FieldUID)
	}
	if m.created_at != nil {
		fields = append(fields, personalfolder.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, personalfolder.FieldUpdatedAt)
	}
	if m.deactivated_at != nil {
		fields = append(fields, personalfolder.FieldDeactivatedAt)
	}
	if m.user_uid != nil {
		fields = append(fields, personalfolder.FieldUserUID)
	}
	if m.folder_name != nil {
		fields = append(fields, personalfolder.FieldFolderName)
	}
	if m.folder_number != nil {
		fields = append(fields, personalfolder.FieldFolderNumber)
	}
	if m.has_open != nil {
		fields = append(fields, personalfolder.FieldHasOpen)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PersonalFolderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case personalfolder.FieldUID:
		return m.UID()
	case personalfolder.FieldCreatedAt:
		return m.CreatedAt()
	case personalfolder.FieldUpdatedAt:
		return m.UpdatedAt()
	case personalfolder.FieldDeactivatedAt:
		return m.DeactivatedAt()
	case personalfolder.FieldUserUID:
		return m.UserUID()
	case personalfolder.FieldFolderName:
		return m.FolderName()
	case personalfolder.FieldFolderNumber:
		return m.FolderNumber()
	case personalfolder.FieldHasOpen:
		return m.HasOpen()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PersonalFolderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case personalfolder.FieldUID:
		return m.OldUID(ctx)
	case personalfolder.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case personalfolder.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case personalfolder.FieldDeactivatedAt:
		return m.OldDeactivatedAt(ctx)
	case personalfolder.FieldUserUID:
		return m.OldUserUID(ctx)
	case personalfolder.FieldFolderName:
		return m.OldFolderName(ctx)
	case personalfolder.FieldFolderNumber:
		return m.OldFolderNumber(ctx)
	case personalfolder.FieldHasOpen:
		return m.OldHasOpen(ctx)
	}
	return nil, fmt.Errorf("unknown PersonalFolder field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonalFolderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case personalfolder.FieldUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case personalfolder.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case personalfolder.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case personalfolder.FieldDeactivatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeactivatedAt(v)
		return nil
	case personalfolder.FieldUserUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserUID(v)
		return nil
	case personalfolder.FieldFolderName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFolderName(v)
		return nil
	case personalfolder.FieldFolderNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFolderNumber(v)
		return nil
	case personalfolder.FieldHasOpen:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasOpen(v)
		return nil
	}
	return fmt.Errorf("unknown PersonalFolder field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PersonalFolderMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PersonalFolderMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonalFolderMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PersonalFolder numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PersonalFolderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(personalfolder.FieldDeactivatedAt) {
		fields = append(fields, personalfolder.FieldDeactivatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PersonalFolderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PersonalFolderMutation) ClearField(name string) error {
	switch name {
	case personalfolder.FieldDeactivatedAt:
		m.ClearDeactivatedAt()
		return nil
	}
	return fmt.Errorf("unknown PersonalFolder nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PersonalFolderMutation) ResetField(name string) error {
	switch name {
	case personalfolder.FieldUID:
		m.ResetUID()
		return nil
	case personalfolder.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case personalfolder.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case personalfolder.FieldDeactivatedAt:
		m.ResetDeactivatedAt()
		return nil
	case personalfolder.FieldUserUID:
		m.ResetUserUID()
		return nil
	case personalfolder.FieldFolderName:
		m.ResetFolderName()
		return nil
	case personalfolder.FieldFolderNumber:
		m.ResetFolderNumber()
		return nil
	case personalfolder.FieldHasOpen:
		m.ResetHasOpen()
		return nil
	}
	return fmt.Errorf("unknown PersonalFolder field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PersonalFolderMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PersonalFolderMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PersonalFolderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PersonalFolderMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PersonalFolderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PersonalFolderMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PersonalFolderMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PersonalFolder unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PersonalFolderMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PersonalFolder edge %s", name)
}

// RechargeMutation represents an operation that mutates the Recharge nodes in the graph.
type RechargeMutation struct {
	config
	op             Op
	typ            string
	id             *uint64
	uid            *string
	created_at     *time.Time
	updated_at     *time.Time
	deactivated_at *time.Time
	title          *string
	origin_amount  *string
	amount         *string
	descriptions   *[]string
	theme_color    *string
	year           *int
	addyear        *int
	month          *int
	addmonth       *int
	_default       *bool
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Recharge, error)
	predicates     []predicate.Recharge
}

var _ ent.Mutation = (*RechargeMutation)(nil)

// rechargeOption allows management of the mutation configuration using functional options.
type rechargeOption func(*RechargeMutation)

// newRechargeMutation creates new mutation for the Recharge entity.
func newRechargeMutation(c config, op Op, opts ...rechargeOption) *RechargeMutation {
	m := &RechargeMutation{
		config:        c,
		op:            op,
		typ:           TypeRecharge,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRechargeID sets the ID field of the mutation.
func withRechargeID(id uint64) rechargeOption {
	return func(m *RechargeMutation) {
		var (
			err   error
			once  sync.Once
			value *Recharge
		)
		m.oldValue = func(ctx context.Context) (*Recharge, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Recharge.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRecharge sets the old Recharge of the mutation.
func withRecharge(node *Recharge) rechargeOption {
	return func(m *RechargeMutation) {
		m.oldValue = func(context.Context) (*Recharge, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RechargeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RechargeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entschema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Recharge entities.
func (m *RechargeMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RechargeMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RechargeMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Recharge.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUID sets the "uid" field.
func (m *RechargeMutation) SetUID(s string) {
	m.uid = &s
}

// UID returns the value of the "uid" field in the mutation.
func (m *RechargeMutation) UID() (r string, exists bool) {
	v := m.uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old "uid" field's value of the Recharge entity.
// If the Recharge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeMutation) OldUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// ResetUID resets all changes to the "uid" field.
func (m *RechargeMutation) ResetUID() {
	m.uid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RechargeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RechargeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Recharge entity.
// If the Recharge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RechargeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RechargeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RechargeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Recharge entity.
// If the Recharge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RechargeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeactivatedAt sets the "deactivated_at" field.
func (m *RechargeMutation) SetDeactivatedAt(t time.Time) {
	m.deactivated_at = &t
}

// DeactivatedAt returns the value of the "deactivated_at" field in the mutation.
func (m *RechargeMutation) DeactivatedAt() (r time.Time, exists bool) {
	v := m.deactivated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeactivatedAt returns the old "deactivated_at" field's value of the Recharge entity.
// If the Recharge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeMutation) OldDeactivatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeactivatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeactivatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeactivatedAt: %w", err)
	}
	return oldValue.DeactivatedAt, nil
}

// ClearDeactivatedAt clears the value of the "deactivated_at" field.
func (m *RechargeMutation) ClearDeactivatedAt() {
	m.deactivated_at = nil
	m.clearedFields[recharge.FieldDeactivatedAt] = struct{}{}
}

// DeactivatedAtCleared returns if the "deactivated_at" field was cleared in this mutation.
func (m *RechargeMutation) DeactivatedAtCleared() bool {
	_, ok := m.clearedFields[recharge.FieldDeactivatedAt]
	return ok
}

// ResetDeactivatedAt resets all changes to the "deactivated_at" field.
func (m *RechargeMutation) ResetDeactivatedAt() {
	m.deactivated_at = nil
	delete(m.clearedFields, recharge.FieldDeactivatedAt)
}

// SetTitle sets the "title" field.
func (m *RechargeMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *RechargeMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Recharge entity.
// If the Recharge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *RechargeMutation) ResetTitle() {
	m.title = nil
}

// SetOriginAmount sets the "origin_amount" field.
func (m *RechargeMutation) SetOriginAmount(s string) {
	m.origin_amount = &s
}

// OriginAmount returns the value of the "origin_amount" field in the mutation.
func (m *RechargeMutation) OriginAmount() (r string, exists bool) {
	v := m.origin_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginAmount returns the old "origin_amount" field's value of the Recharge entity.
// If the Recharge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeMutation) OldOriginAmount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOriginAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOriginAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginAmount: %w", err)
	}
	return oldValue.OriginAmount, nil
}

// ResetOriginAmount resets all changes to the "origin_amount" field.
func (m *RechargeMutation) ResetOriginAmount() {
	m.origin_amount = nil
}

// SetAmount sets the "amount" field.
func (m *RechargeMutation) SetAmount(s string) {
	m.amount = &s
}

// Amount returns the value of the "amount" field in the mutation.
func (m *RechargeMutation) Amount() (r string, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Recharge entity.
// If the Recharge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeMutation) OldAmount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// ResetAmount resets all changes to the "amount" field.
func (m *RechargeMutation) ResetAmount() {
	m.amount = nil
}

// SetDescriptions sets the "descriptions" field.
func (m *RechargeMutation) SetDescriptions(s []string) {
	m.descriptions = &s
}

// Descriptions returns the value of the "descriptions" field in the mutation.
func (m *RechargeMutation) Descriptions() (r []string, exists bool) {
	v := m.descriptions
	if v == nil {
		return
	}
	return *v, true
}

// OldDescriptions returns the old "descriptions" field's value of the Recharge entity.
// If the Recharge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeMutation) OldDescriptions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescriptions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescriptions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescriptions: %w", err)
	}
	return oldValue.Descriptions, nil
}

// ResetDescriptions resets all changes to the "descriptions" field.
func (m *RechargeMutation) ResetDescriptions() {
	m.descriptions = nil
}

// SetThemeColor sets the "theme_color" field.
func (m *RechargeMutation) SetThemeColor(s string) {
	m.theme_color = &s
}

// ThemeColor returns the value of the "theme_color" field in the mutation.
func (m *RechargeMutation) ThemeColor() (r string, exists bool) {
	v := m.theme_color
	if v == nil {
		return
	}
	return *v, true
}

// OldThemeColor returns the old "theme_color" field's value of the Recharge entity.
// If the Recharge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeMutation) OldThemeColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThemeColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThemeColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThemeColor: %w", err)
	}
	return oldValue.ThemeColor, nil
}

// ClearThemeColor clears the value of the "theme_color" field.
func (m *RechargeMutation) ClearThemeColor() {
	m.theme_color = nil
	m.clearedFields[recharge.FieldThemeColor] = struct{}{}
}

// ThemeColorCleared returns if the "theme_color" field was cleared in this mutation.
func (m *RechargeMutation) ThemeColorCleared() bool {
	_, ok := m.clearedFields[recharge.FieldThemeColor]
	return ok
}

// ResetThemeColor resets all changes to the "theme_color" field.
func (m *RechargeMutation) ResetThemeColor() {
	m.theme_color = nil
	delete(m.clearedFields, recharge.FieldThemeColor)
}

// SetYear sets the "year" field.
func (m *RechargeMutation) SetYear(i int) {
	m.year = &i
	m.addyear = nil
}

// Year returns the value of the "year" field in the mutation.
func (m *RechargeMutation) Year() (r int, exists bool) {
	v := m.year
	if v == nil {
		return
	}
	return *v, true
}

// OldYear returns the old "year" field's value of the Recharge entity.
// If the Recharge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeMutation) OldYear(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYear: %w", err)
	}
	return oldValue.Year, nil
}

// AddYear adds i to the "year" field.
func (m *RechargeMutation) AddYear(i int) {
	if m.addyear != nil {
		*m.addyear += i
	} else {
		m.addyear = &i
	}
}

// AddedYear returns the value that was added to the "year" field in this mutation.
func (m *RechargeMutation) AddedYear() (r int, exists bool) {
	v := m.addyear
	if v == nil {
		return
	}
	return *v, true
}

// ResetYear resets all changes to the "year" field.
func (m *RechargeMutation) ResetYear() {
	m.year = nil
	m.addyear = nil
}

// SetMonth sets the "month" field.
func (m *RechargeMutation) SetMonth(i int) {
	m.month = &i
	m.addmonth = nil
}

// Month returns the value of the "month" field in the mutation.
func (m *RechargeMutation) Month() (r int, exists bool) {
	v := m.month
	if v == nil {
		return
	}
	return *v, true
}

// OldMonth returns the old "month" field's value of the Recharge entity.
// If the Recharge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeMutation) OldMonth(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMonth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMonth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMonth: %w", err)
	}
	return oldValue.Month, nil
}

// AddMonth adds i to the "month" field.
func (m *RechargeMutation) AddMonth(i int) {
	if m.addmonth != nil {
		*m.addmonth += i
	} else {
		m.addmonth = &i
	}
}

// AddedMonth returns the value that was added to the "month" field in this mutation.
func (m *RechargeMutation) AddedMonth() (r int, exists bool) {
	v := m.addmonth
	if v == nil {
		return
	}
	return *v, true
}

// ResetMonth resets all changes to the "month" field.
func (m *RechargeMutation) ResetMonth() {
	m.month = nil
	m.addmonth = nil
}

// SetDefault sets the "default" field.
func (m *RechargeMutation) SetDefault(b bool) {
	m._default = &b
}

// Default returns the value of the "default" field in the mutation.
func (m *RechargeMutation) Default() (r bool, exists bool) {
	v := m._default
	if v == nil {
		return
	}
	return *v, true
}

// OldDefault returns the old "default" field's value of the Recharge entity.
// If the Recharge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeMutation) OldDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefault: %w", err)
	}
	return oldValue.Default, nil
}

// ResetDefault resets all changes to the "default" field.
func (m *RechargeMutation) ResetDefault() {
	m._default = nil
}

// Where appends a list predicates to the RechargeMutation builder.
func (m *RechargeMutation) Where(ps ...predicate.Recharge) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *RechargeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Recharge).
func (m *RechargeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RechargeMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.uid != nil {
		fields = append(fields, recharge.FieldUID)
	}
	if m.created_at != nil {
		fields = append(fields, recharge.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, recharge.FieldUpdatedAt)
	}
	if m.deactivated_at != nil {
		fields = append(fields, recharge.FieldDeactivatedAt)
	}
	if m.title != nil {
		fields = append(fields, recharge.FieldTitle)
	}
	if m.origin_amount != nil {
		fields = append(fields, recharge.FieldOriginAmount)
	}
	if m.amount != nil {
		fields = append(fields, recharge.FieldAmount)
	}
	if m.descriptions != nil {
		fields = append(fields, recharge.FieldDescriptions)
	}
	if m.theme_color != nil {
		fields = append(fields, recharge.FieldThemeColor)
	}
	if m.year != nil {
		fields = append(fields, recharge.FieldYear)
	}
	if m.month != nil {
		fields = append(fields, recharge.FieldMonth)
	}
	if m._default != nil {
		fields = append(fields, recharge.FieldDefault)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RechargeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case recharge.FieldUID:
		return m.UID()
	case recharge.FieldCreatedAt:
		return m.CreatedAt()
	case recharge.FieldUpdatedAt:
		return m.UpdatedAt()
	case recharge.FieldDeactivatedAt:
		return m.DeactivatedAt()
	case recharge.FieldTitle:
		return m.Title()
	case recharge.FieldOriginAmount:
		return m.OriginAmount()
	case recharge.FieldAmount:
		return m.Amount()
	case recharge.FieldDescriptions:
		return m.Descriptions()
	case recharge.FieldThemeColor:
		return m.ThemeColor()
	case recharge.FieldYear:
		return m.Year()
	case recharge.FieldMonth:
		return m.Month()
	case recharge.FieldDefault:
		return m.Default()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RechargeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case recharge.FieldUID:
		return m.OldUID(ctx)
	case recharge.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case recharge.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case recharge.FieldDeactivatedAt:
		return m.OldDeactivatedAt(ctx)
	case recharge.FieldTitle:
		return m.OldTitle(ctx)
	case recharge.FieldOriginAmount:
		return m.OldOriginAmount(ctx)
	case recharge.FieldAmount:
		return m.OldAmount(ctx)
	case recharge.FieldDescriptions:
		return m.OldDescriptions(ctx)
	case recharge.FieldThemeColor:
		return m.OldThemeColor(ctx)
	case recharge.FieldYear:
		return m.OldYear(ctx)
	case recharge.FieldMonth:
		return m.OldMonth(ctx)
	case recharge.FieldDefault:
		return m.OldDefault(ctx)
	}
	return nil, fmt.Errorf("unknown Recharge field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RechargeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case recharge.FieldUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case recharge.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case recharge.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case recharge.FieldDeactivatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeactivatedAt(v)
		return nil
	case recharge.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case recharge.FieldOriginAmount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginAmount(v)
		return nil
	case recharge.FieldAmount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case recharge.FieldDescriptions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescriptions(v)
		return nil
	case recharge.FieldThemeColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThemeColor(v)
		return nil
	case recharge.FieldYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYear(v)
		return nil
	case recharge.FieldMonth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMonth(v)
		return nil
	case recharge.FieldDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefault(v)
		return nil
	}
	return fmt.Errorf("unknown Recharge field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RechargeMutation) AddedFields() []string {
	var fields []string
	if m.addyear != nil {
		fields = append(fields, recharge.FieldYear)
	}
	if m.addmonth != nil {
		fields = append(fields, recharge.FieldMonth)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RechargeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case recharge.FieldYear:
		return m.AddedYear()
	case recharge.FieldMonth:
		return m.AddedMonth()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RechargeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case recharge.FieldYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYear(v)
		return nil
	case recharge.FieldMonth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMonth(v)
		return nil
	}
	return fmt.Errorf("unknown Recharge numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RechargeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(recharge.FieldDeactivatedAt) {
		fields = append(fields, recharge.FieldDeactivatedAt)
	}
	if m.FieldCleared(recharge.FieldThemeColor) {
		fields = append(fields, recharge.FieldThemeColor)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RechargeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RechargeMutation) ClearField(name string) error {
	switch name {
	case recharge.FieldDeactivatedAt:
		m.ClearDeactivatedAt()
		return nil
	case recharge.FieldThemeColor:
		m.ClearThemeColor()
		return nil
	}
	return fmt.Errorf("unknown Recharge nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RechargeMutation) ResetField(name string) error {
	switch name {
	case recharge.FieldUID:
		m.ResetUID()
		return nil
	case recharge.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case recharge.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case recharge.FieldDeactivatedAt:
		m.ResetDeactivatedAt()
		return nil
	case recharge.FieldTitle:
		m.ResetTitle()
		return nil
	case recharge.FieldOriginAmount:
		m.ResetOriginAmount()
		return nil
	case recharge.FieldAmount:
		m.ResetAmount()
		return nil
	case recharge.FieldDescriptions:
		m.ResetDescriptions()
		return nil
	case recharge.FieldThemeColor:
		m.ResetThemeColor()
		return nil
	case recharge.FieldYear:
		m.ResetYear()
		return nil
	case recharge.FieldMonth:
		m.ResetMonth()
		return nil
	case recharge.FieldDefault:
		m.ResetDefault()
		return nil
	}
	return fmt.Errorf("unknown Recharge field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RechargeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RechargeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RechargeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RechargeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RechargeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RechargeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RechargeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Recharge unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RechargeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Recharge edge %s", name)
}

// ShareLinkMutation represents an operation that mutates the ShareLink nodes in the graph.
type ShareLinkMutation struct {
	config
	op             Op
	typ            string
	id             *uint64
	uid            *string
	created_at     *time.Time
	updated_at     *time.Time
	deactivated_at *time.Time
	folder_uid     *string
	user_uid       *string
	authority      *string
	valid_day      *int
	addvalid_day   *int
	expired_at     *time.Time
	recent_at      *time.Time
	folder_number  *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*ShareLink, error)
	predicates     []predicate.ShareLink
}

var _ ent.Mutation = (*ShareLinkMutation)(nil)

// sharelinkOption allows management of the mutation configuration using functional options.
type sharelinkOption func(*ShareLinkMutation)

// newShareLinkMutation creates new mutation for the ShareLink entity.
func newShareLinkMutation(c config, op Op, opts ...sharelinkOption) *ShareLinkMutation {
	m := &ShareLinkMutation{
		config:        c,
		op:            op,
		typ:           TypeShareLink,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShareLinkID sets the ID field of the mutation.
func withShareLinkID(id uint64) sharelinkOption {
	return func(m *ShareLinkMutation) {
		var (
			err   error
			once  sync.Once
			value *ShareLink
		)
		m.oldValue = func(ctx context.Context) (*ShareLink, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ShareLink.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShareLink sets the old ShareLink of the mutation.
func withShareLink(node *ShareLink) sharelinkOption {
	return func(m *ShareLinkMutation) {
		m.oldValue = func(context.Context) (*ShareLink, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShareLinkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShareLinkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entschema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ShareLink entities.
func (m *ShareLinkMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShareLinkMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ShareLinkMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ShareLink.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUID sets the "uid" field.
func (m *ShareLinkMutation) SetUID(s string) {
	m.uid = &s
}

// UID returns the value of the "uid" field in the mutation.
func (m *ShareLinkMutation) UID() (r string, exists bool) {
	v := m.uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old "uid" field's value of the ShareLink entity.
// If the ShareLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShareLinkMutation) OldUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// ResetUID resets all changes to the "uid" field.
func (m *ShareLinkMutation) ResetUID() {
	m.uid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ShareLinkMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ShareLinkMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ShareLink entity.
// If the ShareLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShareLinkMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ShareLinkMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ShareLinkMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ShareLinkMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ShareLink entity.
// If the ShareLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShareLinkMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ShareLinkMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeactivatedAt sets the "deactivated_at" field.
func (m *ShareLinkMutation) SetDeactivatedAt(t time.Time) {
	m.deactivated_at = &t
}

// DeactivatedAt returns the value of the "deactivated_at" field in the mutation.
func (m *ShareLinkMutation) DeactivatedAt() (r time.Time, exists bool) {
	v := m.deactivated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeactivatedAt returns the old "deactivated_at" field's value of the ShareLink entity.
// If the ShareLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShareLinkMutation) OldDeactivatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeactivatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeactivatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeactivatedAt: %w", err)
	}
	return oldValue.DeactivatedAt, nil
}

// ClearDeactivatedAt clears the value of the "deactivated_at" field.
func (m *ShareLinkMutation) ClearDeactivatedAt() {
	m.deactivated_at = nil
	m.clearedFields[sharelink.FieldDeactivatedAt] = struct{}{}
}

// DeactivatedAtCleared returns if the "deactivated_at" field was cleared in this mutation.
func (m *ShareLinkMutation) DeactivatedAtCleared() bool {
	_, ok := m.clearedFields[sharelink.FieldDeactivatedAt]
	return ok
}

// ResetDeactivatedAt resets all changes to the "deactivated_at" field.
func (m *ShareLinkMutation) ResetDeactivatedAt() {
	m.deactivated_at = nil
	delete(m.clearedFields, sharelink.FieldDeactivatedAt)
}

// SetFolderUID sets the "folder_uid" field.
func (m *ShareLinkMutation) SetFolderUID(s string) {
	m.folder_uid = &s
}

// FolderUID returns the value of the "folder_uid" field in the mutation.
func (m *ShareLinkMutation) FolderUID() (r string, exists bool) {
	v := m.folder_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldFolderUID returns the old "folder_uid" field's value of the ShareLink entity.
// If the ShareLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShareLinkMutation) OldFolderUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFolderUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFolderUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFolderUID: %w", err)
	}
	return oldValue.FolderUID, nil
}

// ResetFolderUID resets all changes to the "folder_uid" field.
func (m *ShareLinkMutation) ResetFolderUID() {
	m.folder_uid = nil
}

// SetUserUID sets the "user_uid" field.
func (m *ShareLinkMutation) SetUserUID(s string) {
	m.user_uid = &s
}

// UserUID returns the value of the "user_uid" field in the mutation.
func (m *ShareLinkMutation) UserUID() (r string, exists bool) {
	v := m.user_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUserUID returns the old "user_uid" field's value of the ShareLink entity.
// If the ShareLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShareLinkMutation) OldUserUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserUID: %w", err)
	}
	return oldValue.UserUID, nil
}

// ResetUserUID resets all changes to the "user_uid" field.
func (m *ShareLinkMutation) ResetUserUID() {
	m.user_uid = nil
}

// SetAuthority sets the "authority" field.
func (m *ShareLinkMutation) SetAuthority(s string) {
	m.authority = &s
}

// Authority returns the value of the "authority" field in the mutation.
func (m *ShareLinkMutation) Authority() (r string, exists bool) {
	v := m.authority
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthority returns the old "authority" field's value of the ShareLink entity.
// If the ShareLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShareLinkMutation) OldAuthority(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthority: %w", err)
	}
	return oldValue.Authority, nil
}

// ResetAuthority resets all changes to the "authority" field.
func (m *ShareLinkMutation) ResetAuthority() {
	m.authority = nil
}

// SetValidDay sets the "valid_day" field.
func (m *ShareLinkMutation) SetValidDay(i int) {
	m.valid_day = &i
	m.addvalid_day = nil
}

// ValidDay returns the value of the "valid_day" field in the mutation.
func (m *ShareLinkMutation) ValidDay() (r int, exists bool) {
	v := m.valid_day
	if v == nil {
		return
	}
	return *v, true
}

// OldValidDay returns the old "valid_day" field's value of the ShareLink entity.
// If the ShareLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShareLinkMutation) OldValidDay(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidDay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidDay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidDay: %w", err)
	}
	return oldValue.ValidDay, nil
}

// AddValidDay adds i to the "valid_day" field.
func (m *ShareLinkMutation) AddValidDay(i int) {
	if m.addvalid_day != nil {
		*m.addvalid_day += i
	} else {
		m.addvalid_day = &i
	}
}

// AddedValidDay returns the value that was added to the "valid_day" field in this mutation.
func (m *ShareLinkMutation) AddedValidDay() (r int, exists bool) {
	v := m.addvalid_day
	if v == nil {
		return
	}
	return *v, true
}

// ResetValidDay resets all changes to the "valid_day" field.
func (m *ShareLinkMutation) ResetValidDay() {
	m.valid_day = nil
	m.addvalid_day = nil
}

// SetExpiredAt sets the "expired_at" field.
func (m *ShareLinkMutation) SetExpiredAt(t time.Time) {
	m.expired_at = &t
}

// ExpiredAt returns the value of the "expired_at" field in the mutation.
func (m *ShareLinkMutation) ExpiredAt() (r time.Time, exists bool) {
	v := m.expired_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredAt returns the old "expired_at" field's value of the ShareLink entity.
// If the ShareLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShareLinkMutation) OldExpiredAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredAt: %w", err)
	}
	return oldValue.ExpiredAt, nil
}

// ResetExpiredAt resets all changes to the "expired_at" field.
func (m *ShareLinkMutation) ResetExpiredAt() {
	m.expired_at = nil
}

// SetRecentAt sets the "recent_at" field.
func (m *ShareLinkMutation) SetRecentAt(t time.Time) {
	m.recent_at = &t
}

// RecentAt returns the value of the "recent_at" field in the mutation.
func (m *ShareLinkMutation) RecentAt() (r time.Time, exists bool) {
	v := m.recent_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRecentAt returns the old "recent_at" field's value of the ShareLink entity.
// If the ShareLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShareLinkMutation) OldRecentAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecentAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecentAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecentAt: %w", err)
	}
	return oldValue.RecentAt, nil
}

// ResetRecentAt resets all changes to the "recent_at" field.
func (m *ShareLinkMutation) ResetRecentAt() {
	m.recent_at = nil
}

// SetFolderNumber sets the "folder_number" field.
func (m *ShareLinkMutation) SetFolderNumber(s string) {
	m.folder_number = &s
}

// FolderNumber returns the value of the "folder_number" field in the mutation.
func (m *ShareLinkMutation) FolderNumber() (r string, exists bool) {
	v := m.folder_number
	if v == nil {
		return
	}
	return *v, true
}

// OldFolderNumber returns the old "folder_number" field's value of the ShareLink entity.
// If the ShareLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShareLinkMutation) OldFolderNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFolderNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFolderNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFolderNumber: %w", err)
	}
	return oldValue.FolderNumber, nil
}

// ResetFolderNumber resets all changes to the "folder_number" field.
func (m *ShareLinkMutation) ResetFolderNumber() {
	m.folder_number = nil
}

// Where appends a list predicates to the ShareLinkMutation builder.
func (m *ShareLinkMutation) Where(ps ...predicate.ShareLink) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ShareLinkMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ShareLink).
func (m *ShareLinkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShareLinkMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.uid != nil {
		fields = append(fields, sharelink.FieldUID)
	}
	if m.created_at != nil {
		fields = append(fields, sharelink.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, sharelink.FieldUpdatedAt)
	}
	if m.deactivated_at != nil {
		fields = append(fields, sharelink.FieldDeactivatedAt)
	}
	if m.folder_uid != nil {
		fields = append(fields, sharelink.FieldFolderUID)
	}
	if m.user_uid != nil {
		fields = append(fields, sharelink.FieldUserUID)
	}
	if m.authority != nil {
		fields = append(fields, sharelink.FieldAuthority)
	}
	if m.valid_day != nil {
		fields = append(fields, sharelink.FieldValidDay)
	}
	if m.expired_at != nil {
		fields = append(fields, sharelink.FieldExpiredAt)
	}
	if m.recent_at != nil {
		fields = append(fields, sharelink.FieldRecentAt)
	}
	if m.folder_number != nil {
		fields = append(fields, sharelink.FieldFolderNumber)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShareLinkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sharelink.FieldUID:
		return m.UID()
	case sharelink.FieldCreatedAt:
		return m.CreatedAt()
	case sharelink.FieldUpdatedAt:
		return m.UpdatedAt()
	case sharelink.FieldDeactivatedAt:
		return m.DeactivatedAt()
	case sharelink.FieldFolderUID:
		return m.FolderUID()
	case sharelink.FieldUserUID:
		return m.UserUID()
	case sharelink.FieldAuthority:
		return m.Authority()
	case sharelink.FieldValidDay:
		return m.ValidDay()
	case sharelink.FieldExpiredAt:
		return m.ExpiredAt()
	case sharelink.FieldRecentAt:
		return m.RecentAt()
	case sharelink.FieldFolderNumber:
		return m.FolderNumber()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShareLinkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sharelink.FieldUID:
		return m.OldUID(ctx)
	case sharelink.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case sharelink.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case sharelink.FieldDeactivatedAt:
		return m.OldDeactivatedAt(ctx)
	case sharelink.FieldFolderUID:
		return m.OldFolderUID(ctx)
	case sharelink.FieldUserUID:
		return m.OldUserUID(ctx)
	case sharelink.FieldAuthority:
		return m.OldAuthority(ctx)
	case sharelink.FieldValidDay:
		return m.OldValidDay(ctx)
	case sharelink.FieldExpiredAt:
		return m.OldExpiredAt(ctx)
	case sharelink.FieldRecentAt:
		return m.OldRecentAt(ctx)
	case sharelink.FieldFolderNumber:
		return m.OldFolderNumber(ctx)
	}
	return nil, fmt.Errorf("unknown ShareLink field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShareLinkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sharelink.FieldUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case sharelink.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case sharelink.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case sharelink.FieldDeactivatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeactivatedAt(v)
		return nil
	case sharelink.FieldFolderUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFolderUID(v)
		return nil
	case sharelink.FieldUserUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserUID(v)
		return nil
	case sharelink.FieldAuthority:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthority(v)
		return nil
	case sharelink.FieldValidDay:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidDay(v)
		return nil
	case sharelink.FieldExpiredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredAt(v)
		return nil
	case sharelink.FieldRecentAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecentAt(v)
		return nil
	case sharelink.FieldFolderNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFolderNumber(v)
		return nil
	}
	return fmt.Errorf("unknown ShareLink field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShareLinkMutation) AddedFields() []string {
	var fields []string
	if m.addvalid_day != nil {
		fields = append(fields, sharelink.FieldValidDay)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShareLinkMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case sharelink.FieldValidDay:
		return m.AddedValidDay()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShareLinkMutation) AddField(name string, value ent.Value) error {
	switch name {
	case sharelink.FieldValidDay:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValidDay(v)
		return nil
	}
	return fmt.Errorf("unknown ShareLink numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShareLinkMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sharelink.FieldDeactivatedAt) {
		fields = append(fields, sharelink.FieldDeactivatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShareLinkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShareLinkMutation) ClearField(name string) error {
	switch name {
	case sharelink.FieldDeactivatedAt:
		m.ClearDeactivatedAt()
		return nil
	}
	return fmt.Errorf("unknown ShareLink nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShareLinkMutation) ResetField(name string) error {
	switch name {
	case sharelink.FieldUID:
		m.ResetUID()
		return nil
	case sharelink.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case sharelink.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case sharelink.FieldDeactivatedAt:
		m.ResetDeactivatedAt()
		return nil
	case sharelink.FieldFolderUID:
		m.ResetFolderUID()
		return nil
	case sharelink.FieldUserUID:
		m.ResetUserUID()
		return nil
	case sharelink.FieldAuthority:
		m.ResetAuthority()
		return nil
	case sharelink.FieldValidDay:
		m.ResetValidDay()
		return nil
	case sharelink.FieldExpiredAt:
		m.ResetExpiredAt()
		return nil
	case sharelink.FieldRecentAt:
		m.ResetRecentAt()
		return nil
	case sharelink.FieldFolderNumber:
		m.ResetFolderNumber()
		return nil
	}
	return fmt.Errorf("unknown ShareLink field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShareLinkMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShareLinkMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShareLinkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShareLinkMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShareLinkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShareLinkMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShareLinkMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ShareLink unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShareLinkMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ShareLink edge %s", name)
}

// StationMutation represents an operation that mutates the Station nodes in the graph.
type StationMutation struct {
	config
	op             Op
	typ            string
	id             *uint64
	uid            *string
	created_at     *time.Time
	updated_at     *time.Time
	deactivated_at *time.Time
	title          *string
	description    *string
	image          *string
	tags           *[]string
	icon           *string
	source         *string
	link           *string
	praise         *int
	addpraise      *int
	star           *int
	addstar        *int
	view           *int
	addview        *int
	user_uid       *string
	status         *bool
	category_uid   *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Station, error)
	predicates     []predicate.Station
}

var _ ent.Mutation = (*StationMutation)(nil)

// stationOption allows management of the mutation configuration using functional options.
type stationOption func(*StationMutation)

// newStationMutation creates new mutation for the Station entity.
func newStationMutation(c config, op Op, opts ...stationOption) *StationMutation {
	m := &StationMutation{
		config:        c,
		op:            op,
		typ:           TypeStation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStationID sets the ID field of the mutation.
func withStationID(id uint64) stationOption {
	return func(m *StationMutation) {
		var (
			err   error
			once  sync.Once
			value *Station
		)
		m.oldValue = func(ctx context.Context) (*Station, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Station.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStation sets the old Station of the mutation.
func withStation(node *Station) stationOption {
	return func(m *StationMutation) {
		m.oldValue = func(context.Context) (*Station, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entschema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Station entities.
func (m *StationMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StationMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StationMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Station.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUID sets the "uid" field.
func (m *StationMutation) SetUID(s string) {
	m.uid = &s
}

// UID returns the value of the "uid" field in the mutation.
func (m *StationMutation) UID() (r string, exists bool) {
	v := m.uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old "uid" field's value of the Station entity.
// If the Station object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StationMutation) OldUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// ResetUID resets all changes to the "uid" field.
func (m *StationMutation) ResetUID() {
	m.uid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *StationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Station entity.
// If the Station object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Station entity.
// If the Station object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeactivatedAt sets the "deactivated_at" field.
func (m *StationMutation) SetDeactivatedAt(t time.Time) {
	m.deactivated_at = &t
}

// DeactivatedAt returns the value of the "deactivated_at" field in the mutation.
func (m *StationMutation) DeactivatedAt() (r time.Time, exists bool) {
	v := m.deactivated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeactivatedAt returns the old "deactivated_at" field's value of the Station entity.
// If the Station object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StationMutation) OldDeactivatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeactivatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeactivatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeactivatedAt: %w", err)
	}
	return oldValue.DeactivatedAt, nil
}

// ClearDeactivatedAt clears the value of the "deactivated_at" field.
func (m *StationMutation) ClearDeactivatedAt() {
	m.deactivated_at = nil
	m.clearedFields[station.FieldDeactivatedAt] = struct{}{}
}

// DeactivatedAtCleared returns if the "deactivated_at" field was cleared in this mutation.
func (m *StationMutation) DeactivatedAtCleared() bool {
	_, ok := m.clearedFields[station.FieldDeactivatedAt]
	return ok
}

// ResetDeactivatedAt resets all changes to the "deactivated_at" field.
func (m *StationMutation) ResetDeactivatedAt() {
	m.deactivated_at = nil
	delete(m.clearedFields, station.FieldDeactivatedAt)
}

// SetTitle sets the "title" field.
func (m *StationMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *StationMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Station entity.
// If the Station object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StationMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *StationMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *StationMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *StationMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Station entity.
// If the Station object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StationMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *StationMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[station.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *StationMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[station.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *StationMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, station.FieldDescription)
}

// SetImage sets the "image" field.
func (m *StationMutation) SetImage(s string) {
	m.image = &s
}

// Image returns the value of the "image" field in the mutation.
func (m *StationMutation) Image() (r string, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the Station entity.
// If the Station object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StationMutation) OldImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ResetImage resets all changes to the "image" field.
func (m *StationMutation) ResetImage() {
	m.image = nil
}

// SetTags sets the "tags" field.
func (m *StationMutation) SetTags(s []string) {
	m.tags = &s
}

// Tags returns the value of the "tags" field in the mutation.
func (m *StationMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Station entity.
// If the Station object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StationMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ClearTags clears the value of the "tags" field.
func (m *StationMutation) ClearTags() {
	m.tags = nil
	m.clearedFields[station.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *StationMutation) TagsCleared() bool {
	_, ok := m.clearedFields[station.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *StationMutation) ResetTags() {
	m.tags = nil
	delete(m.clearedFields, station.FieldTags)
}

// SetIcon sets the "icon" field.
func (m *StationMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *StationMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the Station entity.
// If the Station object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StationMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ResetIcon resets all changes to the "icon" field.
func (m *StationMutation) ResetIcon() {
	m.icon = nil
}

// SetSource sets the "source" field.
func (m *StationMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *StationMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Station entity.
// If the Station object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StationMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *StationMutation) ResetSource() {
	m.source = nil
}

// SetLink sets the "link" field.
func (m *StationMutation) SetLink(s string) {
	m.link = &s
}

// Link returns the value of the "link" field in the mutation.
func (m *StationMutation) Link() (r string, exists bool) {
	v := m.link
	if v == nil {
		return
	}
	return *v, true
}

// OldLink returns the old "link" field's value of the Station entity.
// If the Station object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StationMutation) OldLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLink: %w", err)
	}
	return oldValue.Link, nil
}

// ResetLink resets all changes to the "link" field.
func (m *StationMutation) ResetLink() {
	m.link = nil
}

// SetPraise sets the "praise" field.
func (m *StationMutation) SetPraise(i int) {
	m.praise = &i
	m.addpraise = nil
}

// Praise returns the value of the "praise" field in the mutation.
func (m *StationMutation) Praise() (r int, exists bool) {
	v := m.praise
	if v == nil {
		return
	}
	return *v, true
}

// OldPraise returns the old "praise" field's value of the Station entity.
// If the Station object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StationMutation) OldPraise(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPraise is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPraise requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPraise: %w", err)
	}
	return oldValue.Praise, nil
}

// AddPraise adds i to the "praise" field.
func (m *StationMutation) AddPraise(i int) {
	if m.addpraise != nil {
		*m.addpraise += i
	} else {
		m.addpraise = &i
	}
}

// AddedPraise returns the value that was added to the "praise" field in this mutation.
func (m *StationMutation) AddedPraise() (r int, exists bool) {
	v := m.addpraise
	if v == nil {
		return
	}
	return *v, true
}

// ResetPraise resets all changes to the "praise" field.
func (m *StationMutation) ResetPraise() {
	m.praise = nil
	m.addpraise = nil
}

// SetStar sets the "star" field.
func (m *StationMutation) SetStar(i int) {
	m.star = &i
	m.addstar = nil
}

// Star returns the value of the "star" field in the mutation.
func (m *StationMutation) Star() (r int, exists bool) {
	v := m.star
	if v == nil {
		return
	}
	return *v, true
}

// OldStar returns the old "star" field's value of the Station entity.
// If the Station object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StationMutation) OldStar(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStar: %w", err)
	}
	return oldValue.Star, nil
}

// AddStar adds i to the "star" field.
func (m *StationMutation) AddStar(i int) {
	if m.addstar != nil {
		*m.addstar += i
	} else {
		m.addstar = &i
	}
}

// AddedStar returns the value that was added to the "star" field in this mutation.
func (m *StationMutation) AddedStar() (r int, exists bool) {
	v := m.addstar
	if v == nil {
		return
	}
	return *v, true
}

// ResetStar resets all changes to the "star" field.
func (m *StationMutation) ResetStar() {
	m.star = nil
	m.addstar = nil
}

// SetView sets the "view" field.
func (m *StationMutation) SetView(i int) {
	m.view = &i
	m.addview = nil
}

// View returns the value of the "view" field in the mutation.
func (m *StationMutation) View() (r int, exists bool) {
	v := m.view
	if v == nil {
		return
	}
	return *v, true
}

// OldView returns the old "view" field's value of the Station entity.
// If the Station object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StationMutation) OldView(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldView is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldView requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldView: %w", err)
	}
	return oldValue.View, nil
}

// AddView adds i to the "view" field.
func (m *StationMutation) AddView(i int) {
	if m.addview != nil {
		*m.addview += i
	} else {
		m.addview = &i
	}
}

// AddedView returns the value that was added to the "view" field in this mutation.
func (m *StationMutation) AddedView() (r int, exists bool) {
	v := m.addview
	if v == nil {
		return
	}
	return *v, true
}

// ResetView resets all changes to the "view" field.
func (m *StationMutation) ResetView() {
	m.view = nil
	m.addview = nil
}

// SetUserUID sets the "user_uid" field.
func (m *StationMutation) SetUserUID(s string) {
	m.user_uid = &s
}

// UserUID returns the value of the "user_uid" field in the mutation.
func (m *StationMutation) UserUID() (r string, exists bool) {
	v := m.user_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUserUID returns the old "user_uid" field's value of the Station entity.
// If the Station object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StationMutation) OldUserUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserUID: %w", err)
	}
	return oldValue.UserUID, nil
}

// ResetUserUID resets all changes to the "user_uid" field.
func (m *StationMutation) ResetUserUID() {
	m.user_uid = nil
}

// SetStatus sets the "status" field.
func (m *StationMutation) SetStatus(b bool) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *StationMutation) Status() (r bool, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Station entity.
// If the Station object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StationMutation) OldStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *StationMutation) ResetStatus() {
	m.status = nil
}

// SetCategoryUID sets the "category_uid" field.
func (m *StationMutation) SetCategoryUID(s string) {
	m.category_uid = &s
}

// CategoryUID returns the value of the "category_uid" field in the mutation.
func (m *StationMutation) CategoryUID() (r string, exists bool) {
	v := m.category_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryUID returns the old "category_uid" field's value of the Station entity.
// If the Station object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StationMutation) OldCategoryUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryUID: %w", err)
	}
	return oldValue.CategoryUID, nil
}

// ResetCategoryUID resets all changes to the "category_uid" field.
func (m *StationMutation) ResetCategoryUID() {
	m.category_uid = nil
}

// Where appends a list predicates to the StationMutation builder.
func (m *StationMutation) Where(ps ...predicate.Station) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *StationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Station).
func (m *StationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StationMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.uid != nil {
		fields = append(fields, station.FieldUID)
	}
	if m.created_at != nil {
		fields = append(fields, station.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, station.FieldUpdatedAt)
	}
	if m.deactivated_at != nil {
		fields = append(fields, station.FieldDeactivatedAt)
	}
	if m.title != nil {
		fields = append(fields, station.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, station.FieldDescription)
	}
	if m.image != nil {
		fields = append(fields, station.FieldImage)
	}
	if m.tags != nil {
		fields = append(fields, station.FieldTags)
	}
	if m.icon != nil {
		fields = append(fields, station.FieldIcon)
	}
	if m.source != nil {
		fields = append(fields, station.FieldSource)
	}
	if m.link != nil {
		fields = append(fields, station.FieldLink)
	}
	if m.praise != nil {
		fields = append(fields, station.FieldPraise)
	}
	if m.star != nil {
		fields = append(fields, station.FieldStar)
	}
	if m.view != nil {
		fields = append(fields, station.FieldView)
	}
	if m.user_uid != nil {
		fields = append(fields, station.FieldUserUID)
	}
	if m.status != nil {
		fields = append(fields, station.FieldStatus)
	}
	if m.category_uid != nil {
		fields = append(fields, station.FieldCategoryUID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case station.FieldUID:
		return m.UID()
	case station.FieldCreatedAt:
		return m.CreatedAt()
	case station.FieldUpdatedAt:
		return m.UpdatedAt()
	case station.FieldDeactivatedAt:
		return m.DeactivatedAt()
	case station.FieldTitle:
		return m.Title()
	case station.FieldDescription:
		return m.Description()
	case station.FieldImage:
		return m.Image()
	case station.FieldTags:
		return m.Tags()
	case station.FieldIcon:
		return m.Icon()
	case station.FieldSource:
		return m.Source()
	case station.FieldLink:
		return m.Link()
	case station.FieldPraise:
		return m.Praise()
	case station.FieldStar:
		return m.Star()
	case station.FieldView:
		return m.View()
	case station.FieldUserUID:
		return m.UserUID()
	case station.FieldStatus:
		return m.Status()
	case station.FieldCategoryUID:
		return m.CategoryUID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case station.FieldUID:
		return m.OldUID(ctx)
	case station.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case station.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case station.FieldDeactivatedAt:
		return m.OldDeactivatedAt(ctx)
	case station.FieldTitle:
		return m.OldTitle(ctx)
	case station.FieldDescription:
		return m.OldDescription(ctx)
	case station.FieldImage:
		return m.OldImage(ctx)
	case station.FieldTags:
		return m.OldTags(ctx)
	case station.FieldIcon:
		return m.OldIcon(ctx)
	case station.FieldSource:
		return m.OldSource(ctx)
	case station.FieldLink:
		return m.OldLink(ctx)
	case station.FieldPraise:
		return m.OldPraise(ctx)
	case station.FieldStar:
		return m.OldStar(ctx)
	case station.FieldView:
		return m.OldView(ctx)
	case station.FieldUserUID:
		return m.OldUserUID(ctx)
	case station.FieldStatus:
		return m.OldStatus(ctx)
	case station.FieldCategoryUID:
		return m.OldCategoryUID(ctx)
	}
	return nil, fmt.Errorf("unknown Station field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case station.FieldUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case station.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case station.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case station.FieldDeactivatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeactivatedAt(v)
		return nil
	case station.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case station.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case station.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	case station.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case station.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case station.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case station.FieldLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLink(v)
		return nil
	case station.FieldPraise:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPraise(v)
		return nil
	case station.FieldStar:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStar(v)
		return nil
	case station.FieldView:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetView(v)
		return nil
	case station.FieldUserUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserUID(v)
		return nil
	case station.FieldStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case station.FieldCategoryUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryUID(v)
		return nil
	}
	return fmt.Errorf("unknown Station field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StationMutation) AddedFields() []string {
	var fields []string
	if m.addpraise != nil {
		fields = append(fields, station.FieldPraise)
	}
	if m.addstar != nil {
		fields = append(fields, station.FieldStar)
	}
	if m.addview != nil {
		fields = append(fields, station.FieldView)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case station.FieldPraise:
		return m.AddedPraise()
	case station.FieldStar:
		return m.AddedStar()
	case station.FieldView:
		return m.AddedView()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case station.FieldPraise:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPraise(v)
		return nil
	case station.FieldStar:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStar(v)
		return nil
	case station.FieldView:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddView(v)
		return nil
	}
	return fmt.Errorf("unknown Station numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(station.FieldDeactivatedAt) {
		fields = append(fields, station.FieldDeactivatedAt)
	}
	if m.FieldCleared(station.FieldDescription) {
		fields = append(fields, station.FieldDescription)
	}
	if m.FieldCleared(station.FieldTags) {
		fields = append(fields, station.FieldTags)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StationMutation) ClearField(name string) error {
	switch name {
	case station.FieldDeactivatedAt:
		m.ClearDeactivatedAt()
		return nil
	case station.FieldDescription:
		m.ClearDescription()
		return nil
	case station.FieldTags:
		m.ClearTags()
		return nil
	}
	return fmt.Errorf("unknown Station nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StationMutation) ResetField(name string) error {
	switch name {
	case station.FieldUID:
		m.ResetUID()
		return nil
	case station.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case station.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case station.FieldDeactivatedAt:
		m.ResetDeactivatedAt()
		return nil
	case station.FieldTitle:
		m.ResetTitle()
		return nil
	case station.FieldDescription:
		m.ResetDescription()
		return nil
	case station.FieldImage:
		m.ResetImage()
		return nil
	case station.FieldTags:
		m.ResetTags()
		return nil
	case station.FieldIcon:
		m.ResetIcon()
		return nil
	case station.FieldSource:
		m.ResetSource()
		return nil
	case station.FieldLink:
		m.ResetLink()
		return nil
	case station.FieldPraise:
		m.ResetPraise()
		return nil
	case station.FieldStar:
		m.ResetStar()
		return nil
	case station.FieldView:
		m.ResetView()
		return nil
	case station.FieldUserUID:
		m.ResetUserUID()
		return nil
	case station.FieldStatus:
		m.ResetStatus()
		return nil
	case station.FieldCategoryUID:
		m.ResetCategoryUID()
		return nil
	}
	return fmt.Errorf("unknown Station field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Station unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Station edge %s", name)
}

// StationCategoryMutation represents an operation that mutates the StationCategory nodes in the graph.
type StationCategoryMutation struct {
	config
	op             Op
	typ            string
	id             *uint64
	uid            *string
	created_at     *time.Time
	updated_at     *time.Time
	deactivated_at *time.Time
	name           *string
	status         *bool
	sequence       *int
	addsequence    *int
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*StationCategory, error)
	predicates     []predicate.StationCategory
}

var _ ent.Mutation = (*StationCategoryMutation)(nil)

// stationcategoryOption allows management of the mutation configuration using functional options.
type stationcategoryOption func(*StationCategoryMutation)

// newStationCategoryMutation creates new mutation for the StationCategory entity.
func newStationCategoryMutation(c config, op Op, opts ...stationcategoryOption) *StationCategoryMutation {
	m := &StationCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeStationCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStationCategoryID sets the ID field of the mutation.
func withStationCategoryID(id uint64) stationcategoryOption {
	return func(m *StationCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *StationCategory
		)
		m.oldValue = func(ctx context.Context) (*StationCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StationCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStationCategory sets the old StationCategory of the mutation.
func withStationCategory(node *StationCategory) stationcategoryOption {
	return func(m *StationCategoryMutation) {
		m.oldValue = func(context.Context) (*StationCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StationCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StationCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entschema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of StationCategory entities.
func (m *StationCategoryMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StationCategoryMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StationCategoryMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StationCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUID sets the "uid" field.
func (m *StationCategoryMutation) SetUID(s string) {
	m.uid = &s
}

// UID returns the value of the "uid" field in the mutation.
func (m *StationCategoryMutation) UID() (r string, exists bool) {
	v := m.uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old "uid" field's value of the StationCategory entity.
// If the StationCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StationCategoryMutation) OldUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// ResetUID resets all changes to the "uid" field.
func (m *StationCategoryMutation) ResetUID() {
	m.uid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *StationCategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StationCategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the StationCategory entity.
// If the StationCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StationCategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StationCategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StationCategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StationCategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the StationCategory entity.
// If the StationCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StationCategoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StationCategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeactivatedAt sets the "deactivated_at" field.
func (m *StationCategoryMutation) SetDeactivatedAt(t time.Time) {
	m.deactivated_at = &t
}

// DeactivatedAt returns the value of the "deactivated_at" field in the mutation.
func (m *StationCategoryMutation) DeactivatedAt() (r time.Time, exists bool) {
	v := m.deactivated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeactivatedAt returns the old "deactivated_at" field's value of the StationCategory entity.
// If the StationCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StationCategoryMutation) OldDeactivatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeactivatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeactivatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeactivatedAt: %w", err)
	}
	return oldValue.DeactivatedAt, nil
}

// ClearDeactivatedAt clears the value of the "deactivated_at" field.
func (m *StationCategoryMutation) ClearDeactivatedAt() {
	m.deactivated_at = nil
	m.clearedFields[stationcategory.FieldDeactivatedAt] = struct{}{}
}

// DeactivatedAtCleared returns if the "deactivated_at" field was cleared in this mutation.
func (m *StationCategoryMutation) DeactivatedAtCleared() bool {
	_, ok := m.clearedFields[stationcategory.FieldDeactivatedAt]
	return ok
}

// ResetDeactivatedAt resets all changes to the "deactivated_at" field.
func (m *StationCategoryMutation) ResetDeactivatedAt() {
	m.deactivated_at = nil
	delete(m.clearedFields, stationcategory.FieldDeactivatedAt)
}

// SetName sets the "name" field.
func (m *StationCategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *StationCategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the StationCategory entity.
// If the StationCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StationCategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *StationCategoryMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the "status" field.
func (m *StationCategoryMutation) SetStatus(b bool) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *StationCategoryMutation) Status() (r bool, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the StationCategory entity.
// If the StationCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StationCategoryMutation) OldStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *StationCategoryMutation) ResetStatus() {
	m.status = nil
}

// SetSequence sets the "sequence" field.
func (m *StationCategoryMutation) SetSequence(i int) {
	m.sequence = &i
	m.addsequence = nil
}

// Sequence returns the value of the "sequence" field in the mutation.
func (m *StationCategoryMutation) Sequence() (r int, exists bool) {
	v := m.sequence
	if v == nil {
		return
	}
	return *v, true
}

// OldSequence returns the old "sequence" field's value of the StationCategory entity.
// If the StationCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StationCategoryMutation) OldSequence(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSequence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSequence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSequence: %w", err)
	}
	return oldValue.Sequence, nil
}

// AddSequence adds i to the "sequence" field.
func (m *StationCategoryMutation) AddSequence(i int) {
	if m.addsequence != nil {
		*m.addsequence += i
	} else {
		m.addsequence = &i
	}
}

// AddedSequence returns the value that was added to the "sequence" field in this mutation.
func (m *StationCategoryMutation) AddedSequence() (r int, exists bool) {
	v := m.addsequence
	if v == nil {
		return
	}
	return *v, true
}

// ResetSequence resets all changes to the "sequence" field.
func (m *StationCategoryMutation) ResetSequence() {
	m.sequence = nil
	m.addsequence = nil
}

// Where appends a list predicates to the StationCategoryMutation builder.
func (m *StationCategoryMutation) Where(ps ...predicate.StationCategory) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *StationCategoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (StationCategory).
func (m *StationCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StationCategoryMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.uid != nil {
		fields = append(fields, stationcategory.FieldUID)
	}
	if m.created_at != nil {
		fields = append(fields, stationcategory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, stationcategory.FieldUpdatedAt)
	}
	if m.deactivated_at != nil {
		fields = append(fields, stationcategory.FieldDeactivatedAt)
	}
	if m.name != nil {
		fields = append(fields, stationcategory.FieldName)
	}
	if m.status != nil {
		fields = append(fields, stationcategory.FieldStatus)
	}
	if m.sequence != nil {
		fields = append(fields, stationcategory.FieldSequence)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StationCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case stationcategory.FieldUID:
		return m.UID()
	case stationcategory.FieldCreatedAt:
		return m.CreatedAt()
	case stationcategory.FieldUpdatedAt:
		return m.UpdatedAt()
	case stationcategory.FieldDeactivatedAt:
		return m.DeactivatedAt()
	case stationcategory.FieldName:
		return m.Name()
	case stationcategory.FieldStatus:
		return m.Status()
	case stationcategory.FieldSequence:
		return m.Sequence()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StationCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case stationcategory.FieldUID:
		return m.OldUID(ctx)
	case stationcategory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case stationcategory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case stationcategory.FieldDeactivatedAt:
		return m.OldDeactivatedAt(ctx)
	case stationcategory.FieldName:
		return m.OldName(ctx)
	case stationcategory.FieldStatus:
		return m.OldStatus(ctx)
	case stationcategory.FieldSequence:
		return m.OldSequence(ctx)
	}
	return nil, fmt.Errorf("unknown StationCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StationCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case stationcategory.FieldUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case stationcategory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case stationcategory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case stationcategory.FieldDeactivatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeactivatedAt(v)
		return nil
	case stationcategory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case stationcategory.FieldStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case stationcategory.FieldSequence:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSequence(v)
		return nil
	}
	return fmt.Errorf("unknown StationCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StationCategoryMutation) AddedFields() []string {
	var fields []string
	if m.addsequence != nil {
		fields = append(fields, stationcategory.FieldSequence)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StationCategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case stationcategory.FieldSequence:
		return m.AddedSequence()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StationCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case stationcategory.FieldSequence:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSequence(v)
		return nil
	}
	return fmt.Errorf("unknown StationCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StationCategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(stationcategory.FieldDeactivatedAt) {
		fields = append(fields, stationcategory.FieldDeactivatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StationCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StationCategoryMutation) ClearField(name string) error {
	switch name {
	case stationcategory.FieldDeactivatedAt:
		m.ClearDeactivatedAt()
		return nil
	}
	return fmt.Errorf("unknown StationCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StationCategoryMutation) ResetField(name string) error {
	switch name {
	case stationcategory.FieldUID:
		m.ResetUID()
		return nil
	case stationcategory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case stationcategory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case stationcategory.FieldDeactivatedAt:
		m.ResetDeactivatedAt()
		return nil
	case stationcategory.FieldName:
		m.ResetName()
		return nil
	case stationcategory.FieldStatus:
		m.ResetStatus()
		return nil
	case stationcategory.FieldSequence:
		m.ResetSequence()
		return nil
	}
	return fmt.Errorf("unknown StationCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StationCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StationCategoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StationCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StationCategoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StationCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StationCategoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StationCategoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown StationCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StationCategoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown StationCategory edge %s", name)
}

// StationMetaMutation represents an operation that mutates the StationMeta nodes in the graph.
type StationMetaMutation struct {
	config
	op             Op
	typ            string
	id             *uint64
	uid            *string
	created_at     *time.Time
	updated_at     *time.Time
	deactivated_at *time.Time
	station_uid    *string
	user_uid       *string
	has_praise     *bool
	has_star       *bool
	has_view       *bool
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*StationMeta, error)
	predicates     []predicate.StationMeta
}

var _ ent.Mutation = (*StationMetaMutation)(nil)

// stationmetaOption allows management of the mutation configuration using functional options.
type stationmetaOption func(*StationMetaMutation)

// newStationMetaMutation creates new mutation for the StationMeta entity.
func newStationMetaMutation(c config, op Op, opts ...stationmetaOption) *StationMetaMutation {
	m := &StationMetaMutation{
		config:        c,
		op:            op,
		typ:           TypeStationMeta,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStationMetaID sets the ID field of the mutation.
func withStationMetaID(id uint64) stationmetaOption {
	return func(m *StationMetaMutation) {
		var (
			err   error
			once  sync.Once
			value *StationMeta
		)
		m.oldValue = func(ctx context.Context) (*StationMeta, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StationMeta.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStationMeta sets the old StationMeta of the mutation.
func withStationMeta(node *StationMeta) stationmetaOption {
	return func(m *StationMetaMutation) {
		m.oldValue = func(context.Context) (*StationMeta, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StationMetaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StationMetaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entschema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of StationMeta entities.
func (m *StationMetaMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StationMetaMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StationMetaMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StationMeta.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUID sets the "uid" field.
func (m *StationMetaMutation) SetUID(s string) {
	m.uid = &s
}

// UID returns the value of the "uid" field in the mutation.
func (m *StationMetaMutation) UID() (r string, exists bool) {
	v := m.uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old "uid" field's value of the StationMeta entity.
// If the StationMeta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StationMetaMutation) OldUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// ResetUID resets all changes to the "uid" field.
func (m *StationMetaMutation) ResetUID() {
	m.uid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *StationMetaMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StationMetaMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the StationMeta entity.
// If the StationMeta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StationMetaMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StationMetaMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StationMetaMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StationMetaMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the StationMeta entity.
// If the StationMeta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StationMetaMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StationMetaMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeactivatedAt sets the "deactivated_at" field.
func (m *StationMetaMutation) SetDeactivatedAt(t time.Time) {
	m.deactivated_at = &t
}

// DeactivatedAt returns the value of the "deactivated_at" field in the mutation.
func (m *StationMetaMutation) DeactivatedAt() (r time.Time, exists bool) {
	v := m.deactivated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeactivatedAt returns the old "deactivated_at" field's value of the StationMeta entity.
// If the StationMeta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StationMetaMutation) OldDeactivatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeactivatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeactivatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeactivatedAt: %w", err)
	}
	return oldValue.DeactivatedAt, nil
}

// ClearDeactivatedAt clears the value of the "deactivated_at" field.
func (m *StationMetaMutation) ClearDeactivatedAt() {
	m.deactivated_at = nil
	m.clearedFields[stationmeta.FieldDeactivatedAt] = struct{}{}
}

// DeactivatedAtCleared returns if the "deactivated_at" field was cleared in this mutation.
func (m *StationMetaMutation) DeactivatedAtCleared() bool {
	_, ok := m.clearedFields[stationmeta.FieldDeactivatedAt]
	return ok
}

// ResetDeactivatedAt resets all changes to the "deactivated_at" field.
func (m *StationMetaMutation) ResetDeactivatedAt() {
	m.deactivated_at = nil
	delete(m.clearedFields, stationmeta.FieldDeactivatedAt)
}

// SetStationUID sets the "station_uid" field.
func (m *StationMetaMutation) SetStationUID(s string) {
	m.station_uid = &s
}

// StationUID returns the value of the "station_uid" field in the mutation.
func (m *StationMetaMutation) StationUID() (r string, exists bool) {
	v := m.station_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldStationUID returns the old "station_uid" field's value of the StationMeta entity.
// If the StationMeta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StationMetaMutation) OldStationUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStationUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStationUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStationUID: %w", err)
	}
	return oldValue.StationUID, nil
}

// ResetStationUID resets all changes to the "station_uid" field.
func (m *StationMetaMutation) ResetStationUID() {
	m.station_uid = nil
}

// SetUserUID sets the "user_uid" field.
func (m *StationMetaMutation) SetUserUID(s string) {
	m.user_uid = &s
}

// UserUID returns the value of the "user_uid" field in the mutation.
func (m *StationMetaMutation) UserUID() (r string, exists bool) {
	v := m.user_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUserUID returns the old "user_uid" field's value of the StationMeta entity.
// If the StationMeta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StationMetaMutation) OldUserUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserUID: %w", err)
	}
	return oldValue.UserUID, nil
}

// ResetUserUID resets all changes to the "user_uid" field.
func (m *StationMetaMutation) ResetUserUID() {
	m.user_uid = nil
}

// SetHasPraise sets the "has_praise" field.
func (m *StationMetaMutation) SetHasPraise(b bool) {
	m.has_praise = &b
}

// HasPraise returns the value of the "has_praise" field in the mutation.
func (m *StationMetaMutation) HasPraise() (r bool, exists bool) {
	v := m.has_praise
	if v == nil {
		return
	}
	return *v, true
}

// OldHasPraise returns the old "has_praise" field's value of the StationMeta entity.
// If the StationMeta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StationMetaMutation) OldHasPraise(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasPraise is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasPraise requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasPraise: %w", err)
	}
	return oldValue.HasPraise, nil
}

// ResetHasPraise resets all changes to the "has_praise" field.
func (m *StationMetaMutation) ResetHasPraise() {
	m.has_praise = nil
}

// SetHasStar sets the "has_star" field.
func (m *StationMetaMutation) SetHasStar(b bool) {
	m.has_star = &b
}

// HasStar returns the value of the "has_star" field in the mutation.
func (m *StationMetaMutation) HasStar() (r bool, exists bool) {
	v := m.has_star
	if v == nil {
		return
	}
	return *v, true
}

// OldHasStar returns the old "has_star" field's value of the StationMeta entity.
// If the StationMeta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StationMetaMutation) OldHasStar(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasStar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasStar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasStar: %w", err)
	}
	return oldValue.HasStar, nil
}

// ResetHasStar resets all changes to the "has_star" field.
func (m *StationMetaMutation) ResetHasStar() {
	m.has_star = nil
}

// SetHasView sets the "has_view" field.
func (m *StationMetaMutation) SetHasView(b bool) {
	m.has_view = &b
}

// HasView returns the value of the "has_view" field in the mutation.
func (m *StationMetaMutation) HasView() (r bool, exists bool) {
	v := m.has_view
	if v == nil {
		return
	}
	return *v, true
}

// OldHasView returns the old "has_view" field's value of the StationMeta entity.
// If the StationMeta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StationMetaMutation) OldHasView(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasView is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasView requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasView: %w", err)
	}
	return oldValue.HasView, nil
}

// ResetHasView resets all changes to the "has_view" field.
func (m *StationMetaMutation) ResetHasView() {
	m.has_view = nil
}

// Where appends a list predicates to the StationMetaMutation builder.
func (m *StationMetaMutation) Where(ps ...predicate.StationMeta) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *StationMetaMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (StationMeta).
func (m *StationMetaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StationMetaMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.uid != nil {
		fields = append(fields, stationmeta.FieldUID)
	}
	if m.created_at != nil {
		fields = append(fields, stationmeta.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, stationmeta.FieldUpdatedAt)
	}
	if m.deactivated_at != nil {
		fields = append(fields, stationmeta.FieldDeactivatedAt)
	}
	if m.station_uid != nil {
		fields = append(fields, stationmeta.FieldStationUID)
	}
	if m.user_uid != nil {
		fields = append(fields, stationmeta.FieldUserUID)
	}
	if m.has_praise != nil {
		fields = append(fields, stationmeta.FieldHasPraise)
	}
	if m.has_star != nil {
		fields = append(fields, stationmeta.FieldHasStar)
	}
	if m.has_view != nil {
		fields = append(fields, stationmeta.FieldHasView)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StationMetaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case stationmeta.FieldUID:
		return m.UID()
	case stationmeta.FieldCreatedAt:
		return m.CreatedAt()
	case stationmeta.FieldUpdatedAt:
		return m.UpdatedAt()
	case stationmeta.FieldDeactivatedAt:
		return m.DeactivatedAt()
	case stationmeta.FieldStationUID:
		return m.StationUID()
	case stationmeta.FieldUserUID:
		return m.UserUID()
	case stationmeta.FieldHasPraise:
		return m.HasPraise()
	case stationmeta.FieldHasStar:
		return m.HasStar()
	case stationmeta.FieldHasView:
		return m.HasView()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StationMetaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case stationmeta.FieldUID:
		return m.OldUID(ctx)
	case stationmeta.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case stationmeta.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case stationmeta.FieldDeactivatedAt:
		return m.OldDeactivatedAt(ctx)
	case stationmeta.FieldStationUID:
		return m.OldStationUID(ctx)
	case stationmeta.FieldUserUID:
		return m.OldUserUID(ctx)
	case stationmeta.FieldHasPraise:
		return m.OldHasPraise(ctx)
	case stationmeta.FieldHasStar:
		return m.OldHasStar(ctx)
	case stationmeta.FieldHasView:
		return m.OldHasView(ctx)
	}
	return nil, fmt.Errorf("unknown StationMeta field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StationMetaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case stationmeta.FieldUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case stationmeta.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case stationmeta.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case stationmeta.FieldDeactivatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeactivatedAt(v)
		return nil
	case stationmeta.FieldStationUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStationUID(v)
		return nil
	case stationmeta.FieldUserUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserUID(v)
		return nil
	case stationmeta.FieldHasPraise:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasPraise(v)
		return nil
	case stationmeta.FieldHasStar:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasStar(v)
		return nil
	case stationmeta.FieldHasView:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasView(v)
		return nil
	}
	return fmt.Errorf("unknown StationMeta field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StationMetaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StationMetaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StationMetaMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown StationMeta numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StationMetaMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(stationmeta.FieldDeactivatedAt) {
		fields = append(fields, stationmeta.FieldDeactivatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StationMetaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StationMetaMutation) ClearField(name string) error {
	switch name {
	case stationmeta.FieldDeactivatedAt:
		m.ClearDeactivatedAt()
		return nil
	}
	return fmt.Errorf("unknown StationMeta nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StationMetaMutation) ResetField(name string) error {
	switch name {
	case stationmeta.FieldUID:
		m.ResetUID()
		return nil
	case stationmeta.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case stationmeta.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case stationmeta.FieldDeactivatedAt:
		m.ResetDeactivatedAt()
		return nil
	case stationmeta.FieldStationUID:
		m.ResetStationUID()
		return nil
	case stationmeta.FieldUserUID:
		m.ResetUserUID()
		return nil
	case stationmeta.FieldHasPraise:
		m.ResetHasPraise()
		return nil
	case stationmeta.FieldHasStar:
		m.ResetHasStar()
		return nil
	case stationmeta.FieldHasView:
		m.ResetHasView()
		return nil
	}
	return fmt.Errorf("unknown StationMeta field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StationMetaMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StationMetaMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StationMetaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StationMetaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StationMetaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StationMetaMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StationMetaMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown StationMeta unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StationMetaMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown StationMeta edge %s", name)
}

// TeamMutation represents an operation that mutates the Team nodes in the graph.
type TeamMutation struct {
	config
	op             Op
	typ            string
	id             *uint64
	uid            *string
	created_at     *time.Time
	updated_at     *time.Time
	deactivated_at *time.Time
	name           *string
	expired_at     *time.Time
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Team, error)
	predicates     []predicate.Team
}

var _ ent.Mutation = (*TeamMutation)(nil)

// teamOption allows management of the mutation configuration using functional options.
type teamOption func(*TeamMutation)

// newTeamMutation creates new mutation for the Team entity.
func newTeamMutation(c config, op Op, opts ...teamOption) *TeamMutation {
	m := &TeamMutation{
		config:        c,
		op:            op,
		typ:           TypeTeam,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeamID sets the ID field of the mutation.
func withTeamID(id uint64) teamOption {
	return func(m *TeamMutation) {
		var (
			err   error
			once  sync.Once
			value *Team
		)
		m.oldValue = func(ctx context.Context) (*Team, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Team.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeam sets the old Team of the mutation.
func withTeam(node *Team) teamOption {
	return func(m *TeamMutation) {
		m.oldValue = func(context.Context) (*Team, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeamMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeamMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entschema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Team entities.
func (m *TeamMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeamMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeamMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Team.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUID sets the "uid" field.
func (m *TeamMutation) SetUID(s string) {
	m.uid = &s
}

// UID returns the value of the "uid" field in the mutation.
func (m *TeamMutation) UID() (r string, exists bool) {
	v := m.uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old "uid" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// ResetUID resets all changes to the "uid" field.
func (m *TeamMutation) ResetUID() {
	m.uid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TeamMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TeamMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TeamMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TeamMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TeamMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TeamMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeactivatedAt sets the "deactivated_at" field.
func (m *TeamMutation) SetDeactivatedAt(t time.Time) {
	m.deactivated_at = &t
}

// DeactivatedAt returns the value of the "deactivated_at" field in the mutation.
func (m *TeamMutation) DeactivatedAt() (r time.Time, exists bool) {
	v := m.deactivated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeactivatedAt returns the old "deactivated_at" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldDeactivatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeactivatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeactivatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeactivatedAt: %w", err)
	}
	return oldValue.DeactivatedAt, nil
}

// ClearDeactivatedAt clears the value of the "deactivated_at" field.
func (m *TeamMutation) ClearDeactivatedAt() {
	m.deactivated_at = nil
	m.clearedFields[team.FieldDeactivatedAt] = struct{}{}
}

// DeactivatedAtCleared returns if the "deactivated_at" field was cleared in this mutation.
func (m *TeamMutation) DeactivatedAtCleared() bool {
	_, ok := m.clearedFields[team.FieldDeactivatedAt]
	return ok
}

// ResetDeactivatedAt resets all changes to the "deactivated_at" field.
func (m *TeamMutation) ResetDeactivatedAt() {
	m.deactivated_at = nil
	delete(m.clearedFields, team.FieldDeactivatedAt)
}

// SetName sets the "name" field.
func (m *TeamMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TeamMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TeamMutation) ResetName() {
	m.name = nil
}

// SetExpiredAt sets the "expired_at" field.
func (m *TeamMutation) SetExpiredAt(t time.Time) {
	m.expired_at = &t
}

// ExpiredAt returns the value of the "expired_at" field in the mutation.
func (m *TeamMutation) ExpiredAt() (r time.Time, exists bool) {
	v := m.expired_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredAt returns the old "expired_at" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldExpiredAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredAt: %w", err)
	}
	return oldValue.ExpiredAt, nil
}

// ResetExpiredAt resets all changes to the "expired_at" field.
func (m *TeamMutation) ResetExpiredAt() {
	m.expired_at = nil
}

// Where appends a list predicates to the TeamMutation builder.
func (m *TeamMutation) Where(ps ...predicate.Team) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TeamMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Team).
func (m *TeamMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeamMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.uid != nil {
		fields = append(fields, team.FieldUID)
	}
	if m.created_at != nil {
		fields = append(fields, team.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, team.FieldUpdatedAt)
	}
	if m.deactivated_at != nil {
		fields = append(fields, team.FieldDeactivatedAt)
	}
	if m.name != nil {
		fields = append(fields, team.FieldName)
	}
	if m.expired_at != nil {
		fields = append(fields, team.FieldExpiredAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeamMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case team.FieldUID:
		return m.UID()
	case team.FieldCreatedAt:
		return m.CreatedAt()
	case team.FieldUpdatedAt:
		return m.UpdatedAt()
	case team.FieldDeactivatedAt:
		return m.DeactivatedAt()
	case team.FieldName:
		return m.Name()
	case team.FieldExpiredAt:
		return m.ExpiredAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeamMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case team.FieldUID:
		return m.OldUID(ctx)
	case team.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case team.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case team.FieldDeactivatedAt:
		return m.OldDeactivatedAt(ctx)
	case team.FieldName:
		return m.OldName(ctx)
	case team.FieldExpiredAt:
		return m.OldExpiredAt(ctx)
	}
	return nil, fmt.Errorf("unknown Team field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) SetField(name string, value ent.Value) error {
	switch name {
	case team.FieldUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case team.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case team.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case team.FieldDeactivatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeactivatedAt(v)
		return nil
	case team.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case team.FieldExpiredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredAt(v)
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeamMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeamMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Team numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeamMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(team.FieldDeactivatedAt) {
		fields = append(fields, team.FieldDeactivatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeamMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeamMutation) ClearField(name string) error {
	switch name {
	case team.FieldDeactivatedAt:
		m.ClearDeactivatedAt()
		return nil
	}
	return fmt.Errorf("unknown Team nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeamMutation) ResetField(name string) error {
	switch name {
	case team.FieldUID:
		m.ResetUID()
		return nil
	case team.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case team.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case team.FieldDeactivatedAt:
		m.ResetDeactivatedAt()
		return nil
	case team.FieldName:
		m.ResetName()
		return nil
	case team.FieldExpiredAt:
		m.ResetExpiredAt()
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeamMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeamMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeamMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeamMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeamMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeamMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeamMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Team unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeamMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Team edge %s", name)
}

// TeamFolderMutation represents an operation that mutates the TeamFolder nodes in the graph.
type TeamFolderMutation struct {
	config
	op             Op
	typ            string
	id             *uint64
	uid            *string
	created_at     *time.Time
	updated_at     *time.Time
	deactivated_at *time.Time
	team_uid       *string
	file_name      *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*TeamFolder, error)
	predicates     []predicate.TeamFolder
}

var _ ent.Mutation = (*TeamFolderMutation)(nil)

// teamfolderOption allows management of the mutation configuration using functional options.
type teamfolderOption func(*TeamFolderMutation)

// newTeamFolderMutation creates new mutation for the TeamFolder entity.
func newTeamFolderMutation(c config, op Op, opts ...teamfolderOption) *TeamFolderMutation {
	m := &TeamFolderMutation{
		config:        c,
		op:            op,
		typ:           TypeTeamFolder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeamFolderID sets the ID field of the mutation.
func withTeamFolderID(id uint64) teamfolderOption {
	return func(m *TeamFolderMutation) {
		var (
			err   error
			once  sync.Once
			value *TeamFolder
		)
		m.oldValue = func(ctx context.Context) (*TeamFolder, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TeamFolder.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeamFolder sets the old TeamFolder of the mutation.
func withTeamFolder(node *TeamFolder) teamfolderOption {
	return func(m *TeamFolderMutation) {
		m.oldValue = func(context.Context) (*TeamFolder, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeamFolderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeamFolderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entschema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TeamFolder entities.
func (m *TeamFolderMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeamFolderMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeamFolderMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TeamFolder.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUID sets the "uid" field.
func (m *TeamFolderMutation) SetUID(s string) {
	m.uid = &s
}

// UID returns the value of the "uid" field in the mutation.
func (m *TeamFolderMutation) UID() (r string, exists bool) {
	v := m.uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old "uid" field's value of the TeamFolder entity.
// If the TeamFolder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamFolderMutation) OldUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// ResetUID resets all changes to the "uid" field.
func (m *TeamFolderMutation) ResetUID() {
	m.uid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TeamFolderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TeamFolderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TeamFolder entity.
// If the TeamFolder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamFolderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TeamFolderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TeamFolderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TeamFolderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TeamFolder entity.
// If the TeamFolder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamFolderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TeamFolderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeactivatedAt sets the "deactivated_at" field.
func (m *TeamFolderMutation) SetDeactivatedAt(t time.Time) {
	m.deactivated_at = &t
}

// DeactivatedAt returns the value of the "deactivated_at" field in the mutation.
func (m *TeamFolderMutation) DeactivatedAt() (r time.Time, exists bool) {
	v := m.deactivated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeactivatedAt returns the old "deactivated_at" field's value of the TeamFolder entity.
// If the TeamFolder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamFolderMutation) OldDeactivatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeactivatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeactivatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeactivatedAt: %w", err)
	}
	return oldValue.DeactivatedAt, nil
}

// ClearDeactivatedAt clears the value of the "deactivated_at" field.
func (m *TeamFolderMutation) ClearDeactivatedAt() {
	m.deactivated_at = nil
	m.clearedFields[teamfolder.FieldDeactivatedAt] = struct{}{}
}

// DeactivatedAtCleared returns if the "deactivated_at" field was cleared in this mutation.
func (m *TeamFolderMutation) DeactivatedAtCleared() bool {
	_, ok := m.clearedFields[teamfolder.FieldDeactivatedAt]
	return ok
}

// ResetDeactivatedAt resets all changes to the "deactivated_at" field.
func (m *TeamFolderMutation) ResetDeactivatedAt() {
	m.deactivated_at = nil
	delete(m.clearedFields, teamfolder.FieldDeactivatedAt)
}

// SetTeamUID sets the "team_uid" field.
func (m *TeamFolderMutation) SetTeamUID(s string) {
	m.team_uid = &s
}

// TeamUID returns the value of the "team_uid" field in the mutation.
func (m *TeamFolderMutation) TeamUID() (r string, exists bool) {
	v := m.team_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamUID returns the old "team_uid" field's value of the TeamFolder entity.
// If the TeamFolder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamFolderMutation) OldTeamUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeamUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeamUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamUID: %w", err)
	}
	return oldValue.TeamUID, nil
}

// ResetTeamUID resets all changes to the "team_uid" field.
func (m *TeamFolderMutation) ResetTeamUID() {
	m.team_uid = nil
}

// SetFileName sets the "file_name" field.
func (m *TeamFolderMutation) SetFileName(s string) {
	m.file_name = &s
}

// FileName returns the value of the "file_name" field in the mutation.
func (m *TeamFolderMutation) FileName() (r string, exists bool) {
	v := m.file_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFileName returns the old "file_name" field's value of the TeamFolder entity.
// If the TeamFolder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamFolderMutation) OldFileName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileName: %w", err)
	}
	return oldValue.FileName, nil
}

// ClearFileName clears the value of the "file_name" field.
func (m *TeamFolderMutation) ClearFileName() {
	m.file_name = nil
	m.clearedFields[teamfolder.FieldFileName] = struct{}{}
}

// FileNameCleared returns if the "file_name" field was cleared in this mutation.
func (m *TeamFolderMutation) FileNameCleared() bool {
	_, ok := m.clearedFields[teamfolder.FieldFileName]
	return ok
}

// ResetFileName resets all changes to the "file_name" field.
func (m *TeamFolderMutation) ResetFileName() {
	m.file_name = nil
	delete(m.clearedFields, teamfolder.FieldFileName)
}

// Where appends a list predicates to the TeamFolderMutation builder.
func (m *TeamFolderMutation) Where(ps ...predicate.TeamFolder) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TeamFolderMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TeamFolder).
func (m *TeamFolderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeamFolderMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.uid != nil {
		fields = append(fields, teamfolder.FieldUID)
	}
	if m.created_at != nil {
		fields = append(fields, teamfolder.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, teamfolder.FieldUpdatedAt)
	}
	if m.deactivated_at != nil {
		fields = append(fields, teamfolder.FieldDeactivatedAt)
	}
	if m.team_uid != nil {
		fields = append(fields, teamfolder.FieldTeamUID)
	}
	if m.file_name != nil {
		fields = append(fields, teamfolder.FieldFileName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeamFolderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case teamfolder.FieldUID:
		return m.UID()
	case teamfolder.FieldCreatedAt:
		return m.CreatedAt()
	case teamfolder.FieldUpdatedAt:
		return m.UpdatedAt()
	case teamfolder.FieldDeactivatedAt:
		return m.DeactivatedAt()
	case teamfolder.FieldTeamUID:
		return m.TeamUID()
	case teamfolder.FieldFileName:
		return m.FileName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeamFolderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case teamfolder.FieldUID:
		return m.OldUID(ctx)
	case teamfolder.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case teamfolder.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case teamfolder.FieldDeactivatedAt:
		return m.OldDeactivatedAt(ctx)
	case teamfolder.FieldTeamUID:
		return m.OldTeamUID(ctx)
	case teamfolder.FieldFileName:
		return m.OldFileName(ctx)
	}
	return nil, fmt.Errorf("unknown TeamFolder field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamFolderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case teamfolder.FieldUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case teamfolder.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case teamfolder.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case teamfolder.FieldDeactivatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeactivatedAt(v)
		return nil
	case teamfolder.FieldTeamUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamUID(v)
		return nil
	case teamfolder.FieldFileName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileName(v)
		return nil
	}
	return fmt.Errorf("unknown TeamFolder field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeamFolderMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeamFolderMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamFolderMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TeamFolder numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeamFolderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(teamfolder.FieldDeactivatedAt) {
		fields = append(fields, teamfolder.FieldDeactivatedAt)
	}
	if m.FieldCleared(teamfolder.FieldFileName) {
		fields = append(fields, teamfolder.FieldFileName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeamFolderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeamFolderMutation) ClearField(name string) error {
	switch name {
	case teamfolder.FieldDeactivatedAt:
		m.ClearDeactivatedAt()
		return nil
	case teamfolder.FieldFileName:
		m.ClearFileName()
		return nil
	}
	return fmt.Errorf("unknown TeamFolder nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeamFolderMutation) ResetField(name string) error {
	switch name {
	case teamfolder.FieldUID:
		m.ResetUID()
		return nil
	case teamfolder.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case teamfolder.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case teamfolder.FieldDeactivatedAt:
		m.ResetDeactivatedAt()
		return nil
	case teamfolder.FieldTeamUID:
		m.ResetTeamUID()
		return nil
	case teamfolder.FieldFileName:
		m.ResetFileName()
		return nil
	}
	return fmt.Errorf("unknown TeamFolder field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeamFolderMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeamFolderMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeamFolderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeamFolderMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeamFolderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeamFolderMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeamFolderMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TeamFolder unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeamFolderMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TeamFolder edge %s", name)
}

// TeamGroupMutation represents an operation that mutates the TeamGroup nodes in the graph.
type TeamGroupMutation struct {
	config
	op             Op
	typ            string
	id             *uint64
	uid            *string
	created_at     *time.Time
	updated_at     *time.Time
	deactivated_at *time.Time
	user_uid       *string
	team_uid       *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*TeamGroup, error)
	predicates     []predicate.TeamGroup
}

var _ ent.Mutation = (*TeamGroupMutation)(nil)

// teamgroupOption allows management of the mutation configuration using functional options.
type teamgroupOption func(*TeamGroupMutation)

// newTeamGroupMutation creates new mutation for the TeamGroup entity.
func newTeamGroupMutation(c config, op Op, opts ...teamgroupOption) *TeamGroupMutation {
	m := &TeamGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeTeamGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeamGroupID sets the ID field of the mutation.
func withTeamGroupID(id uint64) teamgroupOption {
	return func(m *TeamGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *TeamGroup
		)
		m.oldValue = func(ctx context.Context) (*TeamGroup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TeamGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeamGroup sets the old TeamGroup of the mutation.
func withTeamGroup(node *TeamGroup) teamgroupOption {
	return func(m *TeamGroupMutation) {
		m.oldValue = func(context.Context) (*TeamGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeamGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeamGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entschema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TeamGroup entities.
func (m *TeamGroupMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeamGroupMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeamGroupMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TeamGroup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUID sets the "uid" field.
func (m *TeamGroupMutation) SetUID(s string) {
	m.uid = &s
}

// UID returns the value of the "uid" field in the mutation.
func (m *TeamGroupMutation) UID() (r string, exists bool) {
	v := m.uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old "uid" field's value of the TeamGroup entity.
// If the TeamGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamGroupMutation) OldUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// ResetUID resets all changes to the "uid" field.
func (m *TeamGroupMutation) ResetUID() {
	m.uid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TeamGroupMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TeamGroupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TeamGroup entity.
// If the TeamGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamGroupMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TeamGroupMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TeamGroupMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TeamGroupMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TeamGroup entity.
// If the TeamGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamGroupMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TeamGroupMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeactivatedAt sets the "deactivated_at" field.
func (m *TeamGroupMutation) SetDeactivatedAt(t time.Time) {
	m.deactivated_at = &t
}

// DeactivatedAt returns the value of the "deactivated_at" field in the mutation.
func (m *TeamGroupMutation) DeactivatedAt() (r time.Time, exists bool) {
	v := m.deactivated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeactivatedAt returns the old "deactivated_at" field's value of the TeamGroup entity.
// If the TeamGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamGroupMutation) OldDeactivatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeactivatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeactivatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeactivatedAt: %w", err)
	}
	return oldValue.DeactivatedAt, nil
}

// ClearDeactivatedAt clears the value of the "deactivated_at" field.
func (m *TeamGroupMutation) ClearDeactivatedAt() {
	m.deactivated_at = nil
	m.clearedFields[teamgroup.FieldDeactivatedAt] = struct{}{}
}

// DeactivatedAtCleared returns if the "deactivated_at" field was cleared in this mutation.
func (m *TeamGroupMutation) DeactivatedAtCleared() bool {
	_, ok := m.clearedFields[teamgroup.FieldDeactivatedAt]
	return ok
}

// ResetDeactivatedAt resets all changes to the "deactivated_at" field.
func (m *TeamGroupMutation) ResetDeactivatedAt() {
	m.deactivated_at = nil
	delete(m.clearedFields, teamgroup.FieldDeactivatedAt)
}

// SetUserUID sets the "user_uid" field.
func (m *TeamGroupMutation) SetUserUID(s string) {
	m.user_uid = &s
}

// UserUID returns the value of the "user_uid" field in the mutation.
func (m *TeamGroupMutation) UserUID() (r string, exists bool) {
	v := m.user_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUserUID returns the old "user_uid" field's value of the TeamGroup entity.
// If the TeamGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamGroupMutation) OldUserUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserUID: %w", err)
	}
	return oldValue.UserUID, nil
}

// ResetUserUID resets all changes to the "user_uid" field.
func (m *TeamGroupMutation) ResetUserUID() {
	m.user_uid = nil
}

// SetTeamUID sets the "team_uid" field.
func (m *TeamGroupMutation) SetTeamUID(s string) {
	m.team_uid = &s
}

// TeamUID returns the value of the "team_uid" field in the mutation.
func (m *TeamGroupMutation) TeamUID() (r string, exists bool) {
	v := m.team_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamUID returns the old "team_uid" field's value of the TeamGroup entity.
// If the TeamGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamGroupMutation) OldTeamUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeamUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeamUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamUID: %w", err)
	}
	return oldValue.TeamUID, nil
}

// ResetTeamUID resets all changes to the "team_uid" field.
func (m *TeamGroupMutation) ResetTeamUID() {
	m.team_uid = nil
}

// Where appends a list predicates to the TeamGroupMutation builder.
func (m *TeamGroupMutation) Where(ps ...predicate.TeamGroup) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TeamGroupMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TeamGroup).
func (m *TeamGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeamGroupMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.uid != nil {
		fields = append(fields, teamgroup.FieldUID)
	}
	if m.created_at != nil {
		fields = append(fields, teamgroup.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, teamgroup.FieldUpdatedAt)
	}
	if m.deactivated_at != nil {
		fields = append(fields, teamgroup.FieldDeactivatedAt)
	}
	if m.user_uid != nil {
		fields = append(fields, teamgroup.FieldUserUID)
	}
	if m.team_uid != nil {
		fields = append(fields, teamgroup.FieldTeamUID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeamGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case teamgroup.FieldUID:
		return m.UID()
	case teamgroup.FieldCreatedAt:
		return m.CreatedAt()
	case teamgroup.FieldUpdatedAt:
		return m.UpdatedAt()
	case teamgroup.FieldDeactivatedAt:
		return m.DeactivatedAt()
	case teamgroup.FieldUserUID:
		return m.UserUID()
	case teamgroup.FieldTeamUID:
		return m.TeamUID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeamGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case teamgroup.FieldUID:
		return m.OldUID(ctx)
	case teamgroup.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case teamgroup.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case teamgroup.FieldDeactivatedAt:
		return m.OldDeactivatedAt(ctx)
	case teamgroup.FieldUserUID:
		return m.OldUserUID(ctx)
	case teamgroup.FieldTeamUID:
		return m.OldTeamUID(ctx)
	}
	return nil, fmt.Errorf("unknown TeamGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case teamgroup.FieldUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case teamgroup.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case teamgroup.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case teamgroup.FieldDeactivatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeactivatedAt(v)
		return nil
	case teamgroup.FieldUserUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserUID(v)
		return nil
	case teamgroup.FieldTeamUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamUID(v)
		return nil
	}
	return fmt.Errorf("unknown TeamGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeamGroupMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeamGroupMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TeamGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeamGroupMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(teamgroup.FieldDeactivatedAt) {
		fields = append(fields, teamgroup.FieldDeactivatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeamGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeamGroupMutation) ClearField(name string) error {
	switch name {
	case teamgroup.FieldDeactivatedAt:
		m.ClearDeactivatedAt()
		return nil
	}
	return fmt.Errorf("unknown TeamGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeamGroupMutation) ResetField(name string) error {
	switch name {
	case teamgroup.FieldUID:
		m.ResetUID()
		return nil
	case teamgroup.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case teamgroup.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case teamgroup.FieldDeactivatedAt:
		m.ResetDeactivatedAt()
		return nil
	case teamgroup.FieldUserUID:
		m.ResetUserUID()
		return nil
	case teamgroup.FieldTeamUID:
		m.ResetTeamUID()
		return nil
	}
	return fmt.Errorf("unknown TeamGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeamGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeamGroupMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeamGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeamGroupMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeamGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeamGroupMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeamGroupMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TeamGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeamGroupMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TeamGroup edge %s", name)
}

// UrlCrawlMutation represents an operation that mutates the UrlCrawl nodes in the graph.
type UrlCrawlMutation struct {
	config
	op             Op
	typ            string
	id             *uint64
	uid            *string
	created_at     *time.Time
	updated_at     *time.Time
	deactivated_at *time.Time
	url            *string
	community_uid  *string
	count          *int
	addcount       *int
	has_complete   *bool
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*UrlCrawl, error)
	predicates     []predicate.UrlCrawl
}

var _ ent.Mutation = (*UrlCrawlMutation)(nil)

// urlcrawlOption allows management of the mutation configuration using functional options.
type urlcrawlOption func(*UrlCrawlMutation)

// newUrlCrawlMutation creates new mutation for the UrlCrawl entity.
func newUrlCrawlMutation(c config, op Op, opts ...urlcrawlOption) *UrlCrawlMutation {
	m := &UrlCrawlMutation{
		config:        c,
		op:            op,
		typ:           TypeUrlCrawl,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUrlCrawlID sets the ID field of the mutation.
func withUrlCrawlID(id uint64) urlcrawlOption {
	return func(m *UrlCrawlMutation) {
		var (
			err   error
			once  sync.Once
			value *UrlCrawl
		)
		m.oldValue = func(ctx context.Context) (*UrlCrawl, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UrlCrawl.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUrlCrawl sets the old UrlCrawl of the mutation.
func withUrlCrawl(node *UrlCrawl) urlcrawlOption {
	return func(m *UrlCrawlMutation) {
		m.oldValue = func(context.Context) (*UrlCrawl, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UrlCrawlMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UrlCrawlMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entschema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UrlCrawl entities.
func (m *UrlCrawlMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UrlCrawlMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UrlCrawlMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UrlCrawl.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUID sets the "uid" field.
func (m *UrlCrawlMutation) SetUID(s string) {
	m.uid = &s
}

// UID returns the value of the "uid" field in the mutation.
func (m *UrlCrawlMutation) UID() (r string, exists bool) {
	v := m.uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old "uid" field's value of the UrlCrawl entity.
// If the UrlCrawl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UrlCrawlMutation) OldUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// ResetUID resets all changes to the "uid" field.
func (m *UrlCrawlMutation) ResetUID() {
	m.uid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UrlCrawlMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UrlCrawlMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UrlCrawl entity.
// If the UrlCrawl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UrlCrawlMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UrlCrawlMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UrlCrawlMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UrlCrawlMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UrlCrawl entity.
// If the UrlCrawl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UrlCrawlMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UrlCrawlMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeactivatedAt sets the "deactivated_at" field.
func (m *UrlCrawlMutation) SetDeactivatedAt(t time.Time) {
	m.deactivated_at = &t
}

// DeactivatedAt returns the value of the "deactivated_at" field in the mutation.
func (m *UrlCrawlMutation) DeactivatedAt() (r time.Time, exists bool) {
	v := m.deactivated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeactivatedAt returns the old "deactivated_at" field's value of the UrlCrawl entity.
// If the UrlCrawl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UrlCrawlMutation) OldDeactivatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeactivatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeactivatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeactivatedAt: %w", err)
	}
	return oldValue.DeactivatedAt, nil
}

// ClearDeactivatedAt clears the value of the "deactivated_at" field.
func (m *UrlCrawlMutation) ClearDeactivatedAt() {
	m.deactivated_at = nil
	m.clearedFields[urlcrawl.FieldDeactivatedAt] = struct{}{}
}

// DeactivatedAtCleared returns if the "deactivated_at" field was cleared in this mutation.
func (m *UrlCrawlMutation) DeactivatedAtCleared() bool {
	_, ok := m.clearedFields[urlcrawl.FieldDeactivatedAt]
	return ok
}

// ResetDeactivatedAt resets all changes to the "deactivated_at" field.
func (m *UrlCrawlMutation) ResetDeactivatedAt() {
	m.deactivated_at = nil
	delete(m.clearedFields, urlcrawl.FieldDeactivatedAt)
}

// SetURL sets the "url" field.
func (m *UrlCrawlMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *UrlCrawlMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the UrlCrawl entity.
// If the UrlCrawl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UrlCrawlMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *UrlCrawlMutation) ResetURL() {
	m.url = nil
}

// SetCommunityUID sets the "community_uid" field.
func (m *UrlCrawlMutation) SetCommunityUID(s string) {
	m.community_uid = &s
}

// CommunityUID returns the value of the "community_uid" field in the mutation.
func (m *UrlCrawlMutation) CommunityUID() (r string, exists bool) {
	v := m.community_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldCommunityUID returns the old "community_uid" field's value of the UrlCrawl entity.
// If the UrlCrawl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UrlCrawlMutation) OldCommunityUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommunityUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommunityUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommunityUID: %w", err)
	}
	return oldValue.CommunityUID, nil
}

// ClearCommunityUID clears the value of the "community_uid" field.
func (m *UrlCrawlMutation) ClearCommunityUID() {
	m.community_uid = nil
	m.clearedFields[urlcrawl.FieldCommunityUID] = struct{}{}
}

// CommunityUIDCleared returns if the "community_uid" field was cleared in this mutation.
func (m *UrlCrawlMutation) CommunityUIDCleared() bool {
	_, ok := m.clearedFields[urlcrawl.FieldCommunityUID]
	return ok
}

// ResetCommunityUID resets all changes to the "community_uid" field.
func (m *UrlCrawlMutation) ResetCommunityUID() {
	m.community_uid = nil
	delete(m.clearedFields, urlcrawl.FieldCommunityUID)
}

// SetCount sets the "count" field.
func (m *UrlCrawlMutation) SetCount(i int) {
	m.count = &i
	m.addcount = nil
}

// Count returns the value of the "count" field in the mutation.
func (m *UrlCrawlMutation) Count() (r int, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old "count" field's value of the UrlCrawl entity.
// If the UrlCrawl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UrlCrawlMutation) OldCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// AddCount adds i to the "count" field.
func (m *UrlCrawlMutation) AddCount(i int) {
	if m.addcount != nil {
		*m.addcount += i
	} else {
		m.addcount = &i
	}
}

// AddedCount returns the value that was added to the "count" field in this mutation.
func (m *UrlCrawlMutation) AddedCount() (r int, exists bool) {
	v := m.addcount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCount resets all changes to the "count" field.
func (m *UrlCrawlMutation) ResetCount() {
	m.count = nil
	m.addcount = nil
}

// SetHasComplete sets the "has_complete" field.
func (m *UrlCrawlMutation) SetHasComplete(b bool) {
	m.has_complete = &b
}

// HasComplete returns the value of the "has_complete" field in the mutation.
func (m *UrlCrawlMutation) HasComplete() (r bool, exists bool) {
	v := m.has_complete
	if v == nil {
		return
	}
	return *v, true
}

// OldHasComplete returns the old "has_complete" field's value of the UrlCrawl entity.
// If the UrlCrawl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UrlCrawlMutation) OldHasComplete(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasComplete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasComplete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasComplete: %w", err)
	}
	return oldValue.HasComplete, nil
}

// ResetHasComplete resets all changes to the "has_complete" field.
func (m *UrlCrawlMutation) ResetHasComplete() {
	m.has_complete = nil
}

// Where appends a list predicates to the UrlCrawlMutation builder.
func (m *UrlCrawlMutation) Where(ps ...predicate.UrlCrawl) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UrlCrawlMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UrlCrawl).
func (m *UrlCrawlMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UrlCrawlMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.uid != nil {
		fields = append(fields, urlcrawl.FieldUID)
	}
	if m.created_at != nil {
		fields = append(fields, urlcrawl.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, urlcrawl.FieldUpdatedAt)
	}
	if m.deactivated_at != nil {
		fields = append(fields, urlcrawl.FieldDeactivatedAt)
	}
	if m.url != nil {
		fields = append(fields, urlcrawl.FieldURL)
	}
	if m.community_uid != nil {
		fields = append(fields, urlcrawl.FieldCommunityUID)
	}
	if m.count != nil {
		fields = append(fields, urlcrawl.FieldCount)
	}
	if m.has_complete != nil {
		fields = append(fields, urlcrawl.FieldHasComplete)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UrlCrawlMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case urlcrawl.FieldUID:
		return m.UID()
	case urlcrawl.FieldCreatedAt:
		return m.CreatedAt()
	case urlcrawl.FieldUpdatedAt:
		return m.UpdatedAt()
	case urlcrawl.FieldDeactivatedAt:
		return m.DeactivatedAt()
	case urlcrawl.FieldURL:
		return m.URL()
	case urlcrawl.FieldCommunityUID:
		return m.CommunityUID()
	case urlcrawl.FieldCount:
		return m.Count()
	case urlcrawl.FieldHasComplete:
		return m.HasComplete()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UrlCrawlMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case urlcrawl.FieldUID:
		return m.OldUID(ctx)
	case urlcrawl.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case urlcrawl.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case urlcrawl.FieldDeactivatedAt:
		return m.OldDeactivatedAt(ctx)
	case urlcrawl.FieldURL:
		return m.OldURL(ctx)
	case urlcrawl.FieldCommunityUID:
		return m.OldCommunityUID(ctx)
	case urlcrawl.FieldCount:
		return m.OldCount(ctx)
	case urlcrawl.FieldHasComplete:
		return m.OldHasComplete(ctx)
	}
	return nil, fmt.Errorf("unknown UrlCrawl field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UrlCrawlMutation) SetField(name string, value ent.Value) error {
	switch name {
	case urlcrawl.FieldUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case urlcrawl.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case urlcrawl.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case urlcrawl.FieldDeactivatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeactivatedAt(v)
		return nil
	case urlcrawl.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case urlcrawl.FieldCommunityUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommunityUID(v)
		return nil
	case urlcrawl.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	case urlcrawl.FieldHasComplete:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasComplete(v)
		return nil
	}
	return fmt.Errorf("unknown UrlCrawl field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UrlCrawlMutation) AddedFields() []string {
	var fields []string
	if m.addcount != nil {
		fields = append(fields, urlcrawl.FieldCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UrlCrawlMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case urlcrawl.FieldCount:
		return m.AddedCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UrlCrawlMutation) AddField(name string, value ent.Value) error {
	switch name {
	case urlcrawl.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCount(v)
		return nil
	}
	return fmt.Errorf("unknown UrlCrawl numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UrlCrawlMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(urlcrawl.FieldDeactivatedAt) {
		fields = append(fields, urlcrawl.FieldDeactivatedAt)
	}
	if m.FieldCleared(urlcrawl.FieldCommunityUID) {
		fields = append(fields, urlcrawl.FieldCommunityUID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UrlCrawlMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UrlCrawlMutation) ClearField(name string) error {
	switch name {
	case urlcrawl.FieldDeactivatedAt:
		m.ClearDeactivatedAt()
		return nil
	case urlcrawl.FieldCommunityUID:
		m.ClearCommunityUID()
		return nil
	}
	return fmt.Errorf("unknown UrlCrawl nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UrlCrawlMutation) ResetField(name string) error {
	switch name {
	case urlcrawl.FieldUID:
		m.ResetUID()
		return nil
	case urlcrawl.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case urlcrawl.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case urlcrawl.FieldDeactivatedAt:
		m.ResetDeactivatedAt()
		return nil
	case urlcrawl.FieldURL:
		m.ResetURL()
		return nil
	case urlcrawl.FieldCommunityUID:
		m.ResetCommunityUID()
		return nil
	case urlcrawl.FieldCount:
		m.ResetCount()
		return nil
	case urlcrawl.FieldHasComplete:
		m.ResetHasComplete()
		return nil
	}
	return fmt.Errorf("unknown UrlCrawl field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UrlCrawlMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UrlCrawlMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UrlCrawlMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UrlCrawlMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UrlCrawlMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UrlCrawlMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UrlCrawlMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UrlCrawl unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UrlCrawlMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UrlCrawl edge %s", name)
}

// WebLinkMutation represents an operation that mutates the WebLink nodes in the graph.
type WebLinkMutation struct {
	config
	op             Op
	typ            string
	id             *uint64
	uid            *string
	created_at     *time.Time
	updated_at     *time.Time
	deactivated_at *time.Time
	title          *string
	image          *string
	link           *string
	description    *string
	file_type      *string
	sequence       *int
	addsequence    *int
	forever_delete *bool
	user_uid       *string
	workspace_uid  *string
	folder_uid     *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*WebLink, error)
	predicates     []predicate.WebLink
}

var _ ent.Mutation = (*WebLinkMutation)(nil)

// weblinkOption allows management of the mutation configuration using functional options.
type weblinkOption func(*WebLinkMutation)

// newWebLinkMutation creates new mutation for the WebLink entity.
func newWebLinkMutation(c config, op Op, opts ...weblinkOption) *WebLinkMutation {
	m := &WebLinkMutation{
		config:        c,
		op:            op,
		typ:           TypeWebLink,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWebLinkID sets the ID field of the mutation.
func withWebLinkID(id uint64) weblinkOption {
	return func(m *WebLinkMutation) {
		var (
			err   error
			once  sync.Once
			value *WebLink
		)
		m.oldValue = func(ctx context.Context) (*WebLink, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WebLink.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWebLink sets the old WebLink of the mutation.
func withWebLink(node *WebLink) weblinkOption {
	return func(m *WebLinkMutation) {
		m.oldValue = func(context.Context) (*WebLink, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WebLinkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WebLinkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entschema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WebLink entities.
func (m *WebLinkMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WebLinkMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WebLinkMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WebLink.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUID sets the "uid" field.
func (m *WebLinkMutation) SetUID(s string) {
	m.uid = &s
}

// UID returns the value of the "uid" field in the mutation.
func (m *WebLinkMutation) UID() (r string, exists bool) {
	v := m.uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old "uid" field's value of the WebLink entity.
// If the WebLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebLinkMutation) OldUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// ResetUID resets all changes to the "uid" field.
func (m *WebLinkMutation) ResetUID() {
	m.uid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WebLinkMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WebLinkMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WebLink entity.
// If the WebLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebLinkMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WebLinkMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WebLinkMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WebLinkMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WebLink entity.
// If the WebLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebLinkMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WebLinkMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeactivatedAt sets the "deactivated_at" field.
func (m *WebLinkMutation) SetDeactivatedAt(t time.Time) {
	m.deactivated_at = &t
}

// DeactivatedAt returns the value of the "deactivated_at" field in the mutation.
func (m *WebLinkMutation) DeactivatedAt() (r time.Time, exists bool) {
	v := m.deactivated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeactivatedAt returns the old "deactivated_at" field's value of the WebLink entity.
// If the WebLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebLinkMutation) OldDeactivatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeactivatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeactivatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeactivatedAt: %w", err)
	}
	return oldValue.DeactivatedAt, nil
}

// ClearDeactivatedAt clears the value of the "deactivated_at" field.
func (m *WebLinkMutation) ClearDeactivatedAt() {
	m.deactivated_at = nil
	m.clearedFields[weblink.FieldDeactivatedAt] = struct{}{}
}

// DeactivatedAtCleared returns if the "deactivated_at" field was cleared in this mutation.
func (m *WebLinkMutation) DeactivatedAtCleared() bool {
	_, ok := m.clearedFields[weblink.FieldDeactivatedAt]
	return ok
}

// ResetDeactivatedAt resets all changes to the "deactivated_at" field.
func (m *WebLinkMutation) ResetDeactivatedAt() {
	m.deactivated_at = nil
	delete(m.clearedFields, weblink.FieldDeactivatedAt)
}

// SetTitle sets the "title" field.
func (m *WebLinkMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *WebLinkMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the WebLink entity.
// If the WebLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebLinkMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *WebLinkMutation) ResetTitle() {
	m.title = nil
}

// SetImage sets the "image" field.
func (m *WebLinkMutation) SetImage(s string) {
	m.image = &s
}

// Image returns the value of the "image" field in the mutation.
func (m *WebLinkMutation) Image() (r string, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the WebLink entity.
// If the WebLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebLinkMutation) OldImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ResetImage resets all changes to the "image" field.
func (m *WebLinkMutation) ResetImage() {
	m.image = nil
}

// SetLink sets the "link" field.
func (m *WebLinkMutation) SetLink(s string) {
	m.link = &s
}

// Link returns the value of the "link" field in the mutation.
func (m *WebLinkMutation) Link() (r string, exists bool) {
	v := m.link
	if v == nil {
		return
	}
	return *v, true
}

// OldLink returns the old "link" field's value of the WebLink entity.
// If the WebLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebLinkMutation) OldLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLink: %w", err)
	}
	return oldValue.Link, nil
}

// ResetLink resets all changes to the "link" field.
func (m *WebLinkMutation) ResetLink() {
	m.link = nil
}

// SetDescription sets the "description" field.
func (m *WebLinkMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *WebLinkMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the WebLink entity.
// If the WebLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebLinkMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *WebLinkMutation) ResetDescription() {
	m.description = nil
}

// SetFileType sets the "file_type" field.
func (m *WebLinkMutation) SetFileType(s string) {
	m.file_type = &s
}

// FileType returns the value of the "file_type" field in the mutation.
func (m *WebLinkMutation) FileType() (r string, exists bool) {
	v := m.file_type
	if v == nil {
		return
	}
	return *v, true
}

// OldFileType returns the old "file_type" field's value of the WebLink entity.
// If the WebLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebLinkMutation) OldFileType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileType: %w", err)
	}
	return oldValue.FileType, nil
}

// ResetFileType resets all changes to the "file_type" field.
func (m *WebLinkMutation) ResetFileType() {
	m.file_type = nil
}

// SetSequence sets the "sequence" field.
func (m *WebLinkMutation) SetSequence(i int) {
	m.sequence = &i
	m.addsequence = nil
}

// Sequence returns the value of the "sequence" field in the mutation.
func (m *WebLinkMutation) Sequence() (r int, exists bool) {
	v := m.sequence
	if v == nil {
		return
	}
	return *v, true
}

// OldSequence returns the old "sequence" field's value of the WebLink entity.
// If the WebLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebLinkMutation) OldSequence(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSequence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSequence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSequence: %w", err)
	}
	return oldValue.Sequence, nil
}

// AddSequence adds i to the "sequence" field.
func (m *WebLinkMutation) AddSequence(i int) {
	if m.addsequence != nil {
		*m.addsequence += i
	} else {
		m.addsequence = &i
	}
}

// AddedSequence returns the value that was added to the "sequence" field in this mutation.
func (m *WebLinkMutation) AddedSequence() (r int, exists bool) {
	v := m.addsequence
	if v == nil {
		return
	}
	return *v, true
}

// ResetSequence resets all changes to the "sequence" field.
func (m *WebLinkMutation) ResetSequence() {
	m.sequence = nil
	m.addsequence = nil
}

// SetForeverDelete sets the "forever_delete" field.
func (m *WebLinkMutation) SetForeverDelete(b bool) {
	m.forever_delete = &b
}

// ForeverDelete returns the value of the "forever_delete" field in the mutation.
func (m *WebLinkMutation) ForeverDelete() (r bool, exists bool) {
	v := m.forever_delete
	if v == nil {
		return
	}
	return *v, true
}

// OldForeverDelete returns the old "forever_delete" field's value of the WebLink entity.
// If the WebLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebLinkMutation) OldForeverDelete(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForeverDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForeverDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForeverDelete: %w", err)
	}
	return oldValue.ForeverDelete, nil
}

// ResetForeverDelete resets all changes to the "forever_delete" field.
func (m *WebLinkMutation) ResetForeverDelete() {
	m.forever_delete = nil
}

// SetUserUID sets the "user_uid" field.
func (m *WebLinkMutation) SetUserUID(s string) {
	m.user_uid = &s
}

// UserUID returns the value of the "user_uid" field in the mutation.
func (m *WebLinkMutation) UserUID() (r string, exists bool) {
	v := m.user_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUserUID returns the old "user_uid" field's value of the WebLink entity.
// If the WebLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebLinkMutation) OldUserUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserUID: %w", err)
	}
	return oldValue.UserUID, nil
}

// ResetUserUID resets all changes to the "user_uid" field.
func (m *WebLinkMutation) ResetUserUID() {
	m.user_uid = nil
}

// SetWorkspaceUID sets the "workspace_uid" field.
func (m *WebLinkMutation) SetWorkspaceUID(s string) {
	m.workspace_uid = &s
}

// WorkspaceUID returns the value of the "workspace_uid" field in the mutation.
func (m *WebLinkMutation) WorkspaceUID() (r string, exists bool) {
	v := m.workspace_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkspaceUID returns the old "workspace_uid" field's value of the WebLink entity.
// If the WebLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebLinkMutation) OldWorkspaceUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkspaceUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkspaceUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkspaceUID: %w", err)
	}
	return oldValue.WorkspaceUID, nil
}

// ResetWorkspaceUID resets all changes to the "workspace_uid" field.
func (m *WebLinkMutation) ResetWorkspaceUID() {
	m.workspace_uid = nil
}

// SetFolderUID sets the "folder_uid" field.
func (m *WebLinkMutation) SetFolderUID(s string) {
	m.folder_uid = &s
}

// FolderUID returns the value of the "folder_uid" field in the mutation.
func (m *WebLinkMutation) FolderUID() (r string, exists bool) {
	v := m.folder_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldFolderUID returns the old "folder_uid" field's value of the WebLink entity.
// If the WebLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebLinkMutation) OldFolderUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFolderUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFolderUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFolderUID: %w", err)
	}
	return oldValue.FolderUID, nil
}

// ResetFolderUID resets all changes to the "folder_uid" field.
func (m *WebLinkMutation) ResetFolderUID() {
	m.folder_uid = nil
}

// Where appends a list predicates to the WebLinkMutation builder.
func (m *WebLinkMutation) Where(ps ...predicate.WebLink) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *WebLinkMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (WebLink).
func (m *WebLinkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WebLinkMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.uid != nil {
		fields = append(fields, weblink.FieldUID)
	}
	if m.created_at != nil {
		fields = append(fields, weblink.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, weblink.FieldUpdatedAt)
	}
	if m.deactivated_at != nil {
		fields = append(fields, weblink.FieldDeactivatedAt)
	}
	if m.title != nil {
		fields = append(fields, weblink.FieldTitle)
	}
	if m.image != nil {
		fields = append(fields, weblink.FieldImage)
	}
	if m.link != nil {
		fields = append(fields, weblink.FieldLink)
	}
	if m.description != nil {
		fields = append(fields, weblink.FieldDescription)
	}
	if m.file_type != nil {
		fields = append(fields, weblink.FieldFileType)
	}
	if m.sequence != nil {
		fields = append(fields, weblink.FieldSequence)
	}
	if m.forever_delete != nil {
		fields = append(fields, weblink.FieldForeverDelete)
	}
	if m.user_uid != nil {
		fields = append(fields, weblink.FieldUserUID)
	}
	if m.workspace_uid != nil {
		fields = append(fields, weblink.FieldWorkspaceUID)
	}
	if m.folder_uid != nil {
		fields = append(fields, weblink.FieldFolderUID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WebLinkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case weblink.FieldUID:
		return m.UID()
	case weblink.FieldCreatedAt:
		return m.CreatedAt()
	case weblink.FieldUpdatedAt:
		return m.UpdatedAt()
	case weblink.FieldDeactivatedAt:
		return m.DeactivatedAt()
	case weblink.FieldTitle:
		return m.Title()
	case weblink.FieldImage:
		return m.Image()
	case weblink.FieldLink:
		return m.Link()
	case weblink.FieldDescription:
		return m.Description()
	case weblink.FieldFileType:
		return m.FileType()
	case weblink.FieldSequence:
		return m.Sequence()
	case weblink.FieldForeverDelete:
		return m.ForeverDelete()
	case weblink.FieldUserUID:
		return m.UserUID()
	case weblink.FieldWorkspaceUID:
		return m.WorkspaceUID()
	case weblink.FieldFolderUID:
		return m.FolderUID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WebLinkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case weblink.FieldUID:
		return m.OldUID(ctx)
	case weblink.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case weblink.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case weblink.FieldDeactivatedAt:
		return m.OldDeactivatedAt(ctx)
	case weblink.FieldTitle:
		return m.OldTitle(ctx)
	case weblink.FieldImage:
		return m.OldImage(ctx)
	case weblink.FieldLink:
		return m.OldLink(ctx)
	case weblink.FieldDescription:
		return m.OldDescription(ctx)
	case weblink.FieldFileType:
		return m.OldFileType(ctx)
	case weblink.FieldSequence:
		return m.OldSequence(ctx)
	case weblink.FieldForeverDelete:
		return m.OldForeverDelete(ctx)
	case weblink.FieldUserUID:
		return m.OldUserUID(ctx)
	case weblink.FieldWorkspaceUID:
		return m.OldWorkspaceUID(ctx)
	case weblink.FieldFolderUID:
		return m.OldFolderUID(ctx)
	}
	return nil, fmt.Errorf("unknown WebLink field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WebLinkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case weblink.FieldUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case weblink.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case weblink.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case weblink.FieldDeactivatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeactivatedAt(v)
		return nil
	case weblink.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case weblink.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	case weblink.FieldLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLink(v)
		return nil
	case weblink.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case weblink.FieldFileType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileType(v)
		return nil
	case weblink.FieldSequence:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSequence(v)
		return nil
	case weblink.FieldForeverDelete:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForeverDelete(v)
		return nil
	case weblink.FieldUserUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserUID(v)
		return nil
	case weblink.FieldWorkspaceUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkspaceUID(v)
		return nil
	case weblink.FieldFolderUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFolderUID(v)
		return nil
	}
	return fmt.Errorf("unknown WebLink field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WebLinkMutation) AddedFields() []string {
	var fields []string
	if m.addsequence != nil {
		fields = append(fields, weblink.FieldSequence)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WebLinkMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case weblink.FieldSequence:
		return m.AddedSequence()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WebLinkMutation) AddField(name string, value ent.Value) error {
	switch name {
	case weblink.FieldSequence:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSequence(v)
		return nil
	}
	return fmt.Errorf("unknown WebLink numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WebLinkMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(weblink.FieldDeactivatedAt) {
		fields = append(fields, weblink.FieldDeactivatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WebLinkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WebLinkMutation) ClearField(name string) error {
	switch name {
	case weblink.FieldDeactivatedAt:
		m.ClearDeactivatedAt()
		return nil
	}
	return fmt.Errorf("unknown WebLink nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WebLinkMutation) ResetField(name string) error {
	switch name {
	case weblink.FieldUID:
		m.ResetUID()
		return nil
	case weblink.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case weblink.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case weblink.FieldDeactivatedAt:
		m.ResetDeactivatedAt()
		return nil
	case weblink.FieldTitle:
		m.ResetTitle()
		return nil
	case weblink.FieldImage:
		m.ResetImage()
		return nil
	case weblink.FieldLink:
		m.ResetLink()
		return nil
	case weblink.FieldDescription:
		m.ResetDescription()
		return nil
	case weblink.FieldFileType:
		m.ResetFileType()
		return nil
	case weblink.FieldSequence:
		m.ResetSequence()
		return nil
	case weblink.FieldForeverDelete:
		m.ResetForeverDelete()
		return nil
	case weblink.FieldUserUID:
		m.ResetUserUID()
		return nil
	case weblink.FieldWorkspaceUID:
		m.ResetWorkspaceUID()
		return nil
	case weblink.FieldFolderUID:
		m.ResetFolderUID()
		return nil
	}
	return fmt.Errorf("unknown WebLink field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WebLinkMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WebLinkMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WebLinkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WebLinkMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WebLinkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WebLinkMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WebLinkMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WebLink unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WebLinkMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WebLink edge %s", name)
}

// WorkspaceMutation represents an operation that mutates the Workspace nodes in the graph.
type WorkspaceMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uint64
	uid                 *string
	created_at          *time.Time
	updated_at          *time.Time
	deactivated_at      *time.Time
	name                *string
	_type               *int
	add_type            *int
	user_uid            *string
	personal_folder_uid *string
	team_folder_uid     *string
	is_open             *bool
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*Workspace, error)
	predicates          []predicate.Workspace
}

var _ ent.Mutation = (*WorkspaceMutation)(nil)

// workspaceOption allows management of the mutation configuration using functional options.
type workspaceOption func(*WorkspaceMutation)

// newWorkspaceMutation creates new mutation for the Workspace entity.
func newWorkspaceMutation(c config, op Op, opts ...workspaceOption) *WorkspaceMutation {
	m := &WorkspaceMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkspace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkspaceID sets the ID field of the mutation.
func withWorkspaceID(id uint64) workspaceOption {
	return func(m *WorkspaceMutation) {
		var (
			err   error
			once  sync.Once
			value *Workspace
		)
		m.oldValue = func(ctx context.Context) (*Workspace, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Workspace.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkspace sets the old Workspace of the mutation.
func withWorkspace(node *Workspace) workspaceOption {
	return func(m *WorkspaceMutation) {
		m.oldValue = func(context.Context) (*Workspace, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkspaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkspaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entschema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Workspace entities.
func (m *WorkspaceMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkspaceMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkspaceMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Workspace.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUID sets the "uid" field.
func (m *WorkspaceMutation) SetUID(s string) {
	m.uid = &s
}

// UID returns the value of the "uid" field in the mutation.
func (m *WorkspaceMutation) UID() (r string, exists bool) {
	v := m.uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old "uid" field's value of the Workspace entity.
// If the Workspace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceMutation) OldUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// ResetUID resets all changes to the "uid" field.
func (m *WorkspaceMutation) ResetUID() {
	m.uid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkspaceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkspaceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Workspace entity.
// If the Workspace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkspaceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WorkspaceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WorkspaceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Workspace entity.
// If the Workspace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WorkspaceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeactivatedAt sets the "deactivated_at" field.
func (m *WorkspaceMutation) SetDeactivatedAt(t time.Time) {
	m.deactivated_at = &t
}

// DeactivatedAt returns the value of the "deactivated_at" field in the mutation.
func (m *WorkspaceMutation) DeactivatedAt() (r time.Time, exists bool) {
	v := m.deactivated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeactivatedAt returns the old "deactivated_at" field's value of the Workspace entity.
// If the Workspace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceMutation) OldDeactivatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeactivatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeactivatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeactivatedAt: %w", err)
	}
	return oldValue.DeactivatedAt, nil
}

// ClearDeactivatedAt clears the value of the "deactivated_at" field.
func (m *WorkspaceMutation) ClearDeactivatedAt() {
	m.deactivated_at = nil
	m.clearedFields[workspace.FieldDeactivatedAt] = struct{}{}
}

// DeactivatedAtCleared returns if the "deactivated_at" field was cleared in this mutation.
func (m *WorkspaceMutation) DeactivatedAtCleared() bool {
	_, ok := m.clearedFields[workspace.FieldDeactivatedAt]
	return ok
}

// ResetDeactivatedAt resets all changes to the "deactivated_at" field.
func (m *WorkspaceMutation) ResetDeactivatedAt() {
	m.deactivated_at = nil
	delete(m.clearedFields, workspace.FieldDeactivatedAt)
}

// SetName sets the "name" field.
func (m *WorkspaceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *WorkspaceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Workspace entity.
// If the Workspace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *WorkspaceMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *WorkspaceMutation) SetType(i int) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *WorkspaceMutation) GetType() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Workspace entity.
// If the Workspace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceMutation) OldType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *WorkspaceMutation) AddType(i int) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *WorkspaceMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *WorkspaceMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetUserUID sets the "user_uid" field.
func (m *WorkspaceMutation) SetUserUID(s string) {
	m.user_uid = &s
}

// UserUID returns the value of the "user_uid" field in the mutation.
func (m *WorkspaceMutation) UserUID() (r string, exists bool) {
	v := m.user_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUserUID returns the old "user_uid" field's value of the Workspace entity.
// If the Workspace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceMutation) OldUserUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserUID: %w", err)
	}
	return oldValue.UserUID, nil
}

// ResetUserUID resets all changes to the "user_uid" field.
func (m *WorkspaceMutation) ResetUserUID() {
	m.user_uid = nil
}

// SetPersonalFolderUID sets the "personal_folder_uid" field.
func (m *WorkspaceMutation) SetPersonalFolderUID(s string) {
	m.personal_folder_uid = &s
}

// PersonalFolderUID returns the value of the "personal_folder_uid" field in the mutation.
func (m *WorkspaceMutation) PersonalFolderUID() (r string, exists bool) {
	v := m.personal_folder_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldPersonalFolderUID returns the old "personal_folder_uid" field's value of the Workspace entity.
// If the Workspace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceMutation) OldPersonalFolderUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPersonalFolderUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPersonalFolderUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPersonalFolderUID: %w", err)
	}
	return oldValue.PersonalFolderUID, nil
}

// ClearPersonalFolderUID clears the value of the "personal_folder_uid" field.
func (m *WorkspaceMutation) ClearPersonalFolderUID() {
	m.personal_folder_uid = nil
	m.clearedFields[workspace.FieldPersonalFolderUID] = struct{}{}
}

// PersonalFolderUIDCleared returns if the "personal_folder_uid" field was cleared in this mutation.
func (m *WorkspaceMutation) PersonalFolderUIDCleared() bool {
	_, ok := m.clearedFields[workspace.FieldPersonalFolderUID]
	return ok
}

// ResetPersonalFolderUID resets all changes to the "personal_folder_uid" field.
func (m *WorkspaceMutation) ResetPersonalFolderUID() {
	m.personal_folder_uid = nil
	delete(m.clearedFields, workspace.FieldPersonalFolderUID)
}

// SetTeamFolderUID sets the "team_folder_uid" field.
func (m *WorkspaceMutation) SetTeamFolderUID(s string) {
	m.team_folder_uid = &s
}

// TeamFolderUID returns the value of the "team_folder_uid" field in the mutation.
func (m *WorkspaceMutation) TeamFolderUID() (r string, exists bool) {
	v := m.team_folder_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamFolderUID returns the old "team_folder_uid" field's value of the Workspace entity.
// If the Workspace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceMutation) OldTeamFolderUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeamFolderUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeamFolderUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamFolderUID: %w", err)
	}
	return oldValue.TeamFolderUID, nil
}

// ClearTeamFolderUID clears the value of the "team_folder_uid" field.
func (m *WorkspaceMutation) ClearTeamFolderUID() {
	m.team_folder_uid = nil
	m.clearedFields[workspace.FieldTeamFolderUID] = struct{}{}
}

// TeamFolderUIDCleared returns if the "team_folder_uid" field was cleared in this mutation.
func (m *WorkspaceMutation) TeamFolderUIDCleared() bool {
	_, ok := m.clearedFields[workspace.FieldTeamFolderUID]
	return ok
}

// ResetTeamFolderUID resets all changes to the "team_folder_uid" field.
func (m *WorkspaceMutation) ResetTeamFolderUID() {
	m.team_folder_uid = nil
	delete(m.clearedFields, workspace.FieldTeamFolderUID)
}

// SetIsOpen sets the "is_open" field.
func (m *WorkspaceMutation) SetIsOpen(b bool) {
	m.is_open = &b
}

// IsOpen returns the value of the "is_open" field in the mutation.
func (m *WorkspaceMutation) IsOpen() (r bool, exists bool) {
	v := m.is_open
	if v == nil {
		return
	}
	return *v, true
}

// OldIsOpen returns the old "is_open" field's value of the Workspace entity.
// If the Workspace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceMutation) OldIsOpen(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsOpen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsOpen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsOpen: %w", err)
	}
	return oldValue.IsOpen, nil
}

// ResetIsOpen resets all changes to the "is_open" field.
func (m *WorkspaceMutation) ResetIsOpen() {
	m.is_open = nil
}

// Where appends a list predicates to the WorkspaceMutation builder.
func (m *WorkspaceMutation) Where(ps ...predicate.Workspace) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *WorkspaceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Workspace).
func (m *WorkspaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkspaceMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.uid != nil {
		fields = append(fields, workspace.FieldUID)
	}
	if m.created_at != nil {
		fields = append(fields, workspace.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, workspace.FieldUpdatedAt)
	}
	if m.deactivated_at != nil {
		fields = append(fields, workspace.FieldDeactivatedAt)
	}
	if m.name != nil {
		fields = append(fields, workspace.FieldName)
	}
	if m._type != nil {
		fields = append(fields, workspace.FieldType)
	}
	if m.user_uid != nil {
		fields = append(fields, workspace.FieldUserUID)
	}
	if m.personal_folder_uid != nil {
		fields = append(fields, workspace.FieldPersonalFolderUID)
	}
	if m.team_folder_uid != nil {
		fields = append(fields, workspace.FieldTeamFolderUID)
	}
	if m.is_open != nil {
		fields = append(fields, workspace.FieldIsOpen)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkspaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workspace.FieldUID:
		return m.UID()
	case workspace.FieldCreatedAt:
		return m.CreatedAt()
	case workspace.FieldUpdatedAt:
		return m.UpdatedAt()
	case workspace.FieldDeactivatedAt:
		return m.DeactivatedAt()
	case workspace.FieldName:
		return m.Name()
	case workspace.FieldType:
		return m.GetType()
	case workspace.FieldUserUID:
		return m.UserUID()
	case workspace.FieldPersonalFolderUID:
		return m.PersonalFolderUID()
	case workspace.FieldTeamFolderUID:
		return m.TeamFolderUID()
	case workspace.FieldIsOpen:
		return m.IsOpen()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkspaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workspace.FieldUID:
		return m.OldUID(ctx)
	case workspace.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case workspace.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case workspace.FieldDeactivatedAt:
		return m.OldDeactivatedAt(ctx)
	case workspace.FieldName:
		return m.OldName(ctx)
	case workspace.FieldType:
		return m.OldType(ctx)
	case workspace.FieldUserUID:
		return m.OldUserUID(ctx)
	case workspace.FieldPersonalFolderUID:
		return m.OldPersonalFolderUID(ctx)
	case workspace.FieldTeamFolderUID:
		return m.OldTeamFolderUID(ctx)
	case workspace.FieldIsOpen:
		return m.OldIsOpen(ctx)
	}
	return nil, fmt.Errorf("unknown Workspace field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkspaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workspace.FieldUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case workspace.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case workspace.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case workspace.FieldDeactivatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeactivatedAt(v)
		return nil
	case workspace.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case workspace.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case workspace.FieldUserUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserUID(v)
		return nil
	case workspace.FieldPersonalFolderUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPersonalFolderUID(v)
		return nil
	case workspace.FieldTeamFolderUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamFolderUID(v)
		return nil
	case workspace.FieldIsOpen:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsOpen(v)
		return nil
	}
	return fmt.Errorf("unknown Workspace field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkspaceMutation) AddedFields() []string {
	var fields []string
	if m.add_type != nil {
		fields = append(fields, workspace.FieldType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkspaceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case workspace.FieldType:
		return m.AddedType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkspaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case workspace.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	}
	return fmt.Errorf("unknown Workspace numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkspaceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workspace.FieldDeactivatedAt) {
		fields = append(fields, workspace.FieldDeactivatedAt)
	}
	if m.FieldCleared(workspace.FieldPersonalFolderUID) {
		fields = append(fields, workspace.FieldPersonalFolderUID)
	}
	if m.FieldCleared(workspace.FieldTeamFolderUID) {
		fields = append(fields, workspace.FieldTeamFolderUID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkspaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkspaceMutation) ClearField(name string) error {
	switch name {
	case workspace.FieldDeactivatedAt:
		m.ClearDeactivatedAt()
		return nil
	case workspace.FieldPersonalFolderUID:
		m.ClearPersonalFolderUID()
		return nil
	case workspace.FieldTeamFolderUID:
		m.ClearTeamFolderUID()
		return nil
	}
	return fmt.Errorf("unknown Workspace nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkspaceMutation) ResetField(name string) error {
	switch name {
	case workspace.FieldUID:
		m.ResetUID()
		return nil
	case workspace.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case workspace.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case workspace.FieldDeactivatedAt:
		m.ResetDeactivatedAt()
		return nil
	case workspace.FieldName:
		m.ResetName()
		return nil
	case workspace.FieldType:
		m.ResetType()
		return nil
	case workspace.FieldUserUID:
		m.ResetUserUID()
		return nil
	case workspace.FieldPersonalFolderUID:
		m.ResetPersonalFolderUID()
		return nil
	case workspace.FieldTeamFolderUID:
		m.ResetTeamFolderUID()
		return nil
	case workspace.FieldIsOpen:
		m.ResetIsOpen()
		return nil
	}
	return fmt.Errorf("unknown Workspace field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkspaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkspaceMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkspaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkspaceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkspaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkspaceMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkspaceMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Workspace unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkspaceMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Workspace edge %s", name)
}
