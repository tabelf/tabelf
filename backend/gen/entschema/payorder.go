// Code generated by entc, DO NOT EDIT.

package entschema

import (
	"encoding/json"
	"fmt"
	"strings"
	"tabelf/backend/gen/entschema/payorder"
	"tabelf/backend/spec/schema"
	"time"

	"entgo.io/ent/dialect/sql"
)

// PayOrder is the model entity for the PayOrder schema.
type PayOrder struct {
	config `json:"-"`
	// ID of the ent.
	ID uint64 `json:"id,omitempty"`
	// UID holds the value of the "uid" field.
	UID string `json:"uid,omitempty"`
	// CreatedAt holds the value of the "created_at" field.
	CreatedAt time.Time `json:"created_at,omitempty"`
	// UpdatedAt holds the value of the "updated_at" field.
	UpdatedAt time.Time `json:"updated_at,omitempty"`
	// DeactivatedAt holds the value of the "deactivated_at" field.
	DeactivatedAt *time.Time `json:"deactivated_at,omitempty"`
	// OrderNumber holds the value of the "order_number" field.
	// 订单号
	OrderNumber string `json:"order_number,omitempty"`
	// OrderType holds the value of the "order_type" field.
	// 订单类型
	OrderType string `json:"order_type,omitempty"`
	// UserUID holds the value of the "user_uid" field.
	// 用户uid
	UserUID string `json:"user_uid,omitempty"`
	// PayMethod holds the value of the "pay_method" field.
	// 支付方式
	PayMethod string `json:"pay_method,omitempty"`
	// PaymentAmount holds the value of the "payment_amount" field.
	// 实际支付金额
	PaymentAmount string `json:"payment_amount,omitempty"`
	// TotalPrice holds the value of the "total_price" field.
	// 总金额
	TotalPrice string `json:"total_price,omitempty"`
	// RechargeRecord holds the value of the "recharge_record" field.
	// 充值记录
	RechargeRecord schema.RechargeRecord `json:"recharge_record,omitempty"`
	// Status holds the value of the "status" field.
	// 订单状态
	Status string `json:"status,omitempty"`
	// TransactionNumber holds the value of the "transaction_number" field.
	// YunGouOS 系统交易单号
	TransactionNumber string `json:"transaction_number,omitempty"`
	// ThirdpartyNumber holds the value of the "thirdparty_number" field.
	// 第三方支付单号
	ThirdpartyNumber string `json:"thirdparty_number,omitempty"`
	// MchID holds the value of the "mch_id" field.
	// YunGouOS 商户号
	MchID string `json:"mch_id,omitempty"`
	// OpenID holds the value of the "open_id" field.
	// 用户openID
	OpenID string `json:"open_id,omitempty"`
	// MemberExpired holds the value of the "member_expired" field.
	// 会员过期时间
	MemberExpired time.Time `json:"member_expired,omitempty"`
	// CancelEvent holds the value of the "cancel_event" field.
	// 事件
	CancelEvent string `json:"cancel_event,omitempty"`
}

// scanValues returns the types for scanning values from sql.Rows.
func (*PayOrder) scanValues(columns []string) ([]interface{}, error) {
	values := make([]interface{}, len(columns))
	for i := range columns {
		switch columns[i] {
		case payorder.FieldRechargeRecord:
			values[i] = new([]byte)
		case payorder.FieldID:
			values[i] = new(sql.NullInt64)
		case payorder.FieldUID, payorder.FieldOrderNumber, payorder.FieldOrderType, payorder.FieldUserUID, payorder.FieldPayMethod, payorder.FieldPaymentAmount, payorder.FieldTotalPrice, payorder.FieldStatus, payorder.FieldTransactionNumber, payorder.FieldThirdpartyNumber, payorder.FieldMchID, payorder.FieldOpenID, payorder.FieldCancelEvent:
			values[i] = new(sql.NullString)
		case payorder.FieldCreatedAt, payorder.FieldUpdatedAt, payorder.FieldDeactivatedAt, payorder.FieldMemberExpired:
			values[i] = new(sql.NullTime)
		default:
			return nil, fmt.Errorf("unexpected column %q for type PayOrder", columns[i])
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the PayOrder fields.
func (po *PayOrder) assignValues(columns []string, values []interface{}) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case payorder.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			po.ID = uint64(value.Int64)
		case payorder.FieldUID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field uid", values[i])
			} else if value.Valid {
				po.UID = value.String
			}
		case payorder.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				po.CreatedAt = value.Time
			}
		case payorder.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				po.UpdatedAt = value.Time
			}
		case payorder.FieldDeactivatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field deactivated_at", values[i])
			} else if value.Valid {
				po.DeactivatedAt = new(time.Time)
				*po.DeactivatedAt = value.Time
			}
		case payorder.FieldOrderNumber:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field order_number", values[i])
			} else if value.Valid {
				po.OrderNumber = value.String
			}
		case payorder.FieldOrderType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field order_type", values[i])
			} else if value.Valid {
				po.OrderType = value.String
			}
		case payorder.FieldUserUID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field user_uid", values[i])
			} else if value.Valid {
				po.UserUID = value.String
			}
		case payorder.FieldPayMethod:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field pay_method", values[i])
			} else if value.Valid {
				po.PayMethod = value.String
			}
		case payorder.FieldPaymentAmount:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field payment_amount", values[i])
			} else if value.Valid {
				po.PaymentAmount = value.String
			}
		case payorder.FieldTotalPrice:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field total_price", values[i])
			} else if value.Valid {
				po.TotalPrice = value.String
			}
		case payorder.FieldRechargeRecord:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field recharge_record", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &po.RechargeRecord); err != nil {
					return fmt.Errorf("unmarshal field recharge_record: %w", err)
				}
			}
		case payorder.FieldStatus:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field status", values[i])
			} else if value.Valid {
				po.Status = value.String
			}
		case payorder.FieldTransactionNumber:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field transaction_number", values[i])
			} else if value.Valid {
				po.TransactionNumber = value.String
			}
		case payorder.FieldThirdpartyNumber:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field thirdparty_number", values[i])
			} else if value.Valid {
				po.ThirdpartyNumber = value.String
			}
		case payorder.FieldMchID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field mch_id", values[i])
			} else if value.Valid {
				po.MchID = value.String
			}
		case payorder.FieldOpenID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field open_id", values[i])
			} else if value.Valid {
				po.OpenID = value.String
			}
		case payorder.FieldMemberExpired:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field member_expired", values[i])
			} else if value.Valid {
				po.MemberExpired = value.Time
			}
		case payorder.FieldCancelEvent:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field cancel_event", values[i])
			} else if value.Valid {
				po.CancelEvent = value.String
			}
		}
	}
	return nil
}

// Update returns a builder for updating this PayOrder.
// Note that you need to call PayOrder.Unwrap() before calling this method if this PayOrder
// was returned from a transaction, and the transaction was committed or rolled back.
func (po *PayOrder) Update() *PayOrderUpdateOne {
	return (&PayOrderClient{config: po.config}).UpdateOne(po)
}

// Unwrap unwraps the PayOrder entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (po *PayOrder) Unwrap() *PayOrder {
	tx, ok := po.config.driver.(*txDriver)
	if !ok {
		panic("entschema: PayOrder is not a transactional entity")
	}
	po.config.driver = tx.drv
	return po
}

// String implements the fmt.Stringer.
func (po *PayOrder) String() string {
	var builder strings.Builder
	builder.WriteString("PayOrder(")
	builder.WriteString(fmt.Sprintf("id=%v", po.ID))
	builder.WriteString(", uid=")
	builder.WriteString(po.UID)
	builder.WriteString(", created_at=")
	builder.WriteString(po.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", updated_at=")
	builder.WriteString(po.UpdatedAt.Format(time.ANSIC))
	if v := po.DeactivatedAt; v != nil {
		builder.WriteString(", deactivated_at=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", order_number=")
	builder.WriteString(po.OrderNumber)
	builder.WriteString(", order_type=")
	builder.WriteString(po.OrderType)
	builder.WriteString(", user_uid=")
	builder.WriteString(po.UserUID)
	builder.WriteString(", pay_method=")
	builder.WriteString(po.PayMethod)
	builder.WriteString(", payment_amount=")
	builder.WriteString(po.PaymentAmount)
	builder.WriteString(", total_price=")
	builder.WriteString(po.TotalPrice)
	builder.WriteString(", recharge_record=")
	builder.WriteString(fmt.Sprintf("%v", po.RechargeRecord))
	builder.WriteString(", status=")
	builder.WriteString(po.Status)
	builder.WriteString(", transaction_number=")
	builder.WriteString(po.TransactionNumber)
	builder.WriteString(", thirdparty_number=")
	builder.WriteString(po.ThirdpartyNumber)
	builder.WriteString(", mch_id=")
	builder.WriteString(po.MchID)
	builder.WriteString(", open_id=")
	builder.WriteString(po.OpenID)
	builder.WriteString(", member_expired=")
	builder.WriteString(po.MemberExpired.Format(time.ANSIC))
	builder.WriteString(", cancel_event=")
	builder.WriteString(po.CancelEvent)
	builder.WriteByte(')')
	return builder.String()
}

// PayOrders is a parsable slice of PayOrder.
type PayOrders []*PayOrder

func (po PayOrders) config(cfg config) {
	for _i := range po {
		po[_i].config = cfg
	}
}
