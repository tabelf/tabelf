// Code generated by entc, DO NOT EDIT.

package entschema

import (
	"encoding/json"
	"fmt"
	"strings"
	"tabelf/backend/gen/entschema/recharge"
	"time"

	"entgo.io/ent/dialect/sql"
)

// Recharge is the model entity for the Recharge schema.
type Recharge struct {
	config `json:"-"`
	// ID of the ent.
	ID uint64 `json:"id,omitempty"`
	// UID holds the value of the "uid" field.
	UID string `json:"uid,omitempty"`
	// CreatedAt holds the value of the "created_at" field.
	CreatedAt time.Time `json:"created_at,omitempty"`
	// UpdatedAt holds the value of the "updated_at" field.
	UpdatedAt time.Time `json:"updated_at,omitempty"`
	// DeactivatedAt holds the value of the "deactivated_at" field.
	DeactivatedAt *time.Time `json:"deactivated_at,omitempty"`
	// Title holds the value of the "title" field.
	// 标题
	Title string `json:"title,omitempty"`
	// OriginAmount holds the value of the "origin_amount" field.
	// 原价
	OriginAmount string `json:"origin_amount,omitempty"`
	// Amount holds the value of the "amount" field.
	// 折扣价
	Amount string `json:"amount,omitempty"`
	// Descriptions holds the value of the "descriptions" field.
	// 描述列表
	Descriptions []string `json:"descriptions,omitempty"`
	// ThemeColor holds the value of the "theme_color" field.
	// 开通按钮的主题色
	ThemeColor string `json:"theme_color,omitempty"`
	// Year holds the value of the "year" field.
	// 开通增长年数限制
	Year int `json:"year,omitempty"`
	// Month holds the value of the "month" field.
	// 开通增长月数限制
	Month int `json:"month,omitempty"`
	// Default holds the value of the "default" field.
	// 是否作为默认金额
	Default bool `json:"default,omitempty"`
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Recharge) scanValues(columns []string) ([]interface{}, error) {
	values := make([]interface{}, len(columns))
	for i := range columns {
		switch columns[i] {
		case recharge.FieldDescriptions:
			values[i] = new([]byte)
		case recharge.FieldDefault:
			values[i] = new(sql.NullBool)
		case recharge.FieldID, recharge.FieldYear, recharge.FieldMonth:
			values[i] = new(sql.NullInt64)
		case recharge.FieldUID, recharge.FieldTitle, recharge.FieldOriginAmount, recharge.FieldAmount, recharge.FieldThemeColor:
			values[i] = new(sql.NullString)
		case recharge.FieldCreatedAt, recharge.FieldUpdatedAt, recharge.FieldDeactivatedAt:
			values[i] = new(sql.NullTime)
		default:
			return nil, fmt.Errorf("unexpected column %q for type Recharge", columns[i])
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Recharge fields.
func (r *Recharge) assignValues(columns []string, values []interface{}) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case recharge.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			r.ID = uint64(value.Int64)
		case recharge.FieldUID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field uid", values[i])
			} else if value.Valid {
				r.UID = value.String
			}
		case recharge.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				r.CreatedAt = value.Time
			}
		case recharge.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				r.UpdatedAt = value.Time
			}
		case recharge.FieldDeactivatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field deactivated_at", values[i])
			} else if value.Valid {
				r.DeactivatedAt = new(time.Time)
				*r.DeactivatedAt = value.Time
			}
		case recharge.FieldTitle:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field title", values[i])
			} else if value.Valid {
				r.Title = value.String
			}
		case recharge.FieldOriginAmount:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field origin_amount", values[i])
			} else if value.Valid {
				r.OriginAmount = value.String
			}
		case recharge.FieldAmount:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field amount", values[i])
			} else if value.Valid {
				r.Amount = value.String
			}
		case recharge.FieldDescriptions:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field descriptions", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &r.Descriptions); err != nil {
					return fmt.Errorf("unmarshal field descriptions: %w", err)
				}
			}
		case recharge.FieldThemeColor:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field theme_color", values[i])
			} else if value.Valid {
				r.ThemeColor = value.String
			}
		case recharge.FieldYear:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field year", values[i])
			} else if value.Valid {
				r.Year = int(value.Int64)
			}
		case recharge.FieldMonth:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field month", values[i])
			} else if value.Valid {
				r.Month = int(value.Int64)
			}
		case recharge.FieldDefault:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field default", values[i])
			} else if value.Valid {
				r.Default = value.Bool
			}
		}
	}
	return nil
}

// Update returns a builder for updating this Recharge.
// Note that you need to call Recharge.Unwrap() before calling this method if this Recharge
// was returned from a transaction, and the transaction was committed or rolled back.
func (r *Recharge) Update() *RechargeUpdateOne {
	return (&RechargeClient{config: r.config}).UpdateOne(r)
}

// Unwrap unwraps the Recharge entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (r *Recharge) Unwrap() *Recharge {
	tx, ok := r.config.driver.(*txDriver)
	if !ok {
		panic("entschema: Recharge is not a transactional entity")
	}
	r.config.driver = tx.drv
	return r
}

// String implements the fmt.Stringer.
func (r *Recharge) String() string {
	var builder strings.Builder
	builder.WriteString("Recharge(")
	builder.WriteString(fmt.Sprintf("id=%v", r.ID))
	builder.WriteString(", uid=")
	builder.WriteString(r.UID)
	builder.WriteString(", created_at=")
	builder.WriteString(r.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", updated_at=")
	builder.WriteString(r.UpdatedAt.Format(time.ANSIC))
	if v := r.DeactivatedAt; v != nil {
		builder.WriteString(", deactivated_at=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", title=")
	builder.WriteString(r.Title)
	builder.WriteString(", origin_amount=")
	builder.WriteString(r.OriginAmount)
	builder.WriteString(", amount=")
	builder.WriteString(r.Amount)
	builder.WriteString(", descriptions=")
	builder.WriteString(fmt.Sprintf("%v", r.Descriptions))
	builder.WriteString(", theme_color=")
	builder.WriteString(r.ThemeColor)
	builder.WriteString(", year=")
	builder.WriteString(fmt.Sprintf("%v", r.Year))
	builder.WriteString(", month=")
	builder.WriteString(fmt.Sprintf("%v", r.Month))
	builder.WriteString(", default=")
	builder.WriteString(fmt.Sprintf("%v", r.Default))
	builder.WriteByte(')')
	return builder.String()
}

// Recharges is a parsable slice of Recharge.
type Recharges []*Recharge

func (r Recharges) config(cfg config) {
	for _i := range r {
		r[_i].config = cfg
	}
}
